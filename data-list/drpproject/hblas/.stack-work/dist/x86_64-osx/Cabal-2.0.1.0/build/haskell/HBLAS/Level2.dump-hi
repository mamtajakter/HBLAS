
==================== FINAL INTERFACE ====================
2020-05-29 02:06:23.483662 UTC

interface hblas-0.0.0.0-F71I6QhmeyVEy1DCNMIf5j:HBLAS.Level2 8022
  interface hash: 9ceeea571ddb2cde33bc3feb4ea1c45a
  ABI hash: 18dc2a764d898d16849f3be8e377d40a
  export-list hash: 8c0dbf089e8471e2f16710691953be0c
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: e131b62417e854f9475d855932e64176
  sig of: Nothing
  used TH splices: False
  where
exports:
  HBLAS.Level2.gemv
  HBLAS.Level2.gemv'
  HBLAS.Level2.getLowerTotalMatrix
  HBLAS.Level2.getLowerTotalRow
  HBLAS.Level2.getUpperTotalMatrix
  HBLAS.Level2.getUpperTotalRow
  HBLAS.Level2.symv
  HBLAS.Level2.symvLower
  HBLAS.Level2.symvUpper
  HBLAS.Level2.trmv
  HBLAS.Level2.trmvHelper
  HBLAS.Level2.trmvLower
  HBLAS.Level2.trmvUpper
  HBLAS.Level2.trsv
  HBLAS.Level2.trsvHelper
  HBLAS.Level2.trsvLower
  HBLAS.Level2.trsvUpper
  HBLAS.Level2.update
module dependencies: HBLAS.Level1
package dependencies: base-4.10.1.0* ghc-prim-0.5.1.1
                      integer-gmp-1.0.1.0
orphans: base-4.10.1.0:GHC.Float base-4.10.1.0:GHC.Base
family instance modules: base-4.10.1.0:Control.Applicative
                         base-4.10.1.0:Data.Either base-4.10.1.0:Data.Functor.Const
                         base-4.10.1.0:Data.Functor.Identity base-4.10.1.0:Data.Monoid
                         base-4.10.1.0:Data.Type.Equality base-4.10.1.0:GHC.Generics
                         base-4.10.1.0:GHC.IO.Exception base-4.10.1.0:GHC.TypeLits
                         base-4.10.1.0:GHC.TypeNats
import  -/  base-4.10.1.0:Data.Foldable 9ed87455d68e87ff2b5b8725eae9897e
import  -/  base-4.10.1.0:Data.List 4ab7fa2a1b87502b23af891a384f0506
import  -/  base-4.10.1.0:Data.Monoid c0108b166e27f747671c7fe4ffb11019
import  -/  base-4.10.1.0:Data.Tuple 8fa1305aa5032ea35e2a54fa5f1e78f9
import  -/  base-4.10.1.0:GHC.Base 782fd99b5e36f3698a26179a49afca64
import  -/  base-4.10.1.0:GHC.List e3060fbeb44ce0038e6b4dedf2dd9cf1
import  -/  base-4.10.1.0:GHC.Num 6e1dc5d36d99a802edb39b92bb1923b8
import  -/  base-4.10.1.0:GHC.Real 3c62834bc25e762eabc44149c4cc142d
import  -/  base-4.10.1.0:Prelude 31945b7d0084063347fc52506d3a4020
import  -/  ghc-prim-0.5.1.1:GHC.Classes 93e2660065dce9329577e83d76d8f0d4
import  -/  HBLAS.Level1 bde81cafc81f9682234ab53ab9dc7311
  exports: 18b18fcb432d07a00a66ac1850e8668d
  axpy c238bfaef0a1ed6ce50f74c9a7fd7423
  dot 423b5942938bcf421ec88d8fdb822038
  scal b1b71ab39a7cc31981179a696c3d53fd
addDependentFile "/Users/mamtajakter/.stack/programs/x86_64-osx/ghc-8.2.2/lib/ghc-8.2.2/include/ghcversion.h"
addDependentFile ".stack-work/dist/x86_64-osx/Cabal-2.0.1.0/build/autogen/cabal_macros.h"
dcd481a959e968a8877d13131bd975b2
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   HBLAS.Level2.$trModule3
                   HBLAS.Level2.$trModule1) -}
27b2a3a84908b43962cb120a5b2baf5d
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS HBLAS.Level2.$trModule2) -}
3ce99e7ab061fc4b931e4fa9ea39dac0
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("HBLAS.Level2"#) -}
0a73f6d8e2b3c111b5d825d7e5135de4
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS HBLAS.Level2.$trModule4) -}
4ed83f8b6319eb5f790f893dd5f20705
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("hblas-0.0.0.0-F71I6QhmeyVEy1DCNMIf5j"#) -}
d4d9a3f982d1f98a9c33ea6a0ac13b39
  $wgetLowerTotalMatrix ::
    [[n]] -> GHC.Prim.Int# -> GHC.Prim.Int# -> (# [n], [[n]] #)
  {- Arity: 3, Strictness: <S,U><S,U><S,U>, Inline: [0],
     Unfolding(loop-breaker): <stable> (\ @ n
                                          (w :: [[n]])
                                          (ww :: GHC.Prim.Int#)
                                          (ww1 :: GHC.Prim.Int#) ->
                                        case w of a { DEFAULT ->
                                        case GHC.List.$w!! @ [n] a ww of x { DEFAULT ->
                                        case GHC.Prim.tagToEnum#
                                               @ GHC.Types.Bool
                                               (GHC.Prim.>=# ww ww1) of wild {
                                          GHC.Types.False
                                          -> (# HBLAS.Level2.$wgetLowerTotalRow @ n a x ww ww ww1,
                                                case HBLAS.Level2.$wgetLowerTotalMatrix
                                                       @ n
                                                       a
                                                       (GHC.Prim.+# ww 1#)
                                                       ww1 of ww2 { (#,#) ww3 ww4 ->
                                                GHC.Types.: @ [n] ww3 ww4 } #)
                                          GHC.Types.True
                                          -> (# GHC.Types.[] @ n, GHC.Types.[] @ [n] #) } } }) -}
ec2bc84e9c506796955dbe7f56e8369a
  $wgetLowerTotalRow ::
    [[n]]
    -> [n] -> GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Prim.Int# -> [n]
  {- Arity: 5, Strictness: <S,1*U><S,1*U><S,U><L,U><S,U>,
     Inline: [0],
     Unfolding(loop-breaker): <stable> (\ @ n
                                          (w :: [[n]])
                                          (w1 :: [n])
                                          (ww :: GHC.Prim.Int#)
                                          (ww1 :: GHC.Prim.Int#)
                                          (ww2 :: GHC.Prim.Int#) ->
                                        case w of a { DEFAULT ->
                                        case w1 of x { DEFAULT ->
                                        case GHC.Prim.tagToEnum#
                                               @ GHC.Types.Bool
                                               (GHC.Prim.>=# ww ww2) of wild {
                                          GHC.Types.False
                                          -> let {
                                               $j :: [n] -> [n] <join 1> {- Arity: 1 -}
                                               = \ (x1 :: [n])[OneShot] ->
                                                 case GHC.List.$w!!
                                                        @ n
                                                        (GHC.List.$w!! @ [n] a ww)
                                                        ww1 of aij { DEFAULT ->
                                                 let {
                                                   z :: [n] = GHC.Types.: @ n aij (GHC.Types.[] @ n)
                                                 } in
                                                 letrec {
                                                   go :: [n] -> [n] {- Arity: 1 -}
                                                   = \ (ds :: [n]) ->
                                                     case ds of wild1 {
                                                       [] -> z : y ys -> GHC.Types.: @ n y (go ys) }
                                                 } in
                                                 case go x1 of new_x { DEFAULT ->
                                                 HBLAS.Level2.$wgetLowerTotalRow
                                                   @ n
                                                   a
                                                   new_x
                                                   (GHC.Prim.+# ww 1#)
                                                   ww1
                                                   ww2 } }
                                             } in
                                             case GHC.Prim.tagToEnum#
                                                    @ GHC.Types.Bool
                                                    (GHC.Prim.<# 0# ww) of wild1 {
                                               GHC.Types.False -> $j (GHC.Types.[] @ n)
                                               GHC.Types.True
                                               -> let {
                                                    z :: GHC.Types.Int -> [n] {- Arity: 1 -}
                                                    = GHC.List.flipSeqTake @ [n] (GHC.Types.[] @ n)
                                                  } in
                                                  letrec {
                                                    go :: [n] -> GHC.Types.Int -> [n] {- Arity: 1 -}
                                                    = \ (ds :: [n]) ->
                                                      case ds of wild2 {
                                                        [] -> z
                                                        : y ys
                                                        -> let {
                                                             xs :: GHC.Types.Int -> [n] = go ys
                                                           } in
                                                           \ (m :: GHC.Types.Int) ->
                                                           case m of wild3 { GHC.Types.I# ds1 ->
                                                           case ds1 of ds2 {
                                                             DEFAULT
                                                             -> GHC.Types.:
                                                                  @ n
                                                                  y
                                                                  (xs
                                                                     (GHC.Types.I#
                                                                        (GHC.Prim.-# ds2 1#)))
                                                             1#
                                                             -> GHC.Types.:
                                                                  @ n
                                                                  y
                                                                  (GHC.Types.[] @ n) } } }
                                                  } in
                                                  case go x (GHC.Types.I# ww) of x1 { DEFAULT ->
                                                  $j x1 } }
                                          GHC.Types.True -> x } } }) -}
b3ae7b4a31feb493fb2517b05cd26ac0
  $wgetUpperTotalMatrix ::
    [[n]] -> GHC.Prim.Int# -> GHC.Prim.Int# -> (# [n], [[n]] #)
  {- Arity: 3, Strictness: <S,U><S,U><S,U>, Inline: [0],
     Unfolding(loop-breaker): <stable> (\ @ n
                                          (w :: [[n]])
                                          (ww :: GHC.Prim.Int#)
                                          (ww1 :: GHC.Prim.Int#) ->
                                        case w of a { DEFAULT ->
                                        case GHC.List.$w!! @ [n] a ww of x { DEFAULT ->
                                        case GHC.Prim.tagToEnum#
                                               @ GHC.Types.Bool
                                               (GHC.Prim.>=# ww ww1) of wild {
                                          GHC.Types.False
                                          -> (# HBLAS.Level2.$wgetUpperTotalRow @ n a x ww 0# 0#,
                                                case HBLAS.Level2.$wgetUpperTotalMatrix
                                                       @ n
                                                       a
                                                       (GHC.Prim.+# ww 1#)
                                                       ww1 of ww2 { (#,#) ww3 ww4 ->
                                                GHC.Types.: @ [n] ww3 ww4 } #)
                                          GHC.Types.True
                                          -> (# GHC.Types.[] @ n, GHC.Types.[] @ [n] #) } } }) -}
55c357bf3813cdb3bb0fc0b777c25f90
  $wgetUpperTotalRow ::
    [[n]]
    -> [n] -> GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Prim.Int# -> [n]
  {- Arity: 5, Strictness: <S,1*U><S,1*U><S,U><L,1*U><S,U>,
     Inline: [0],
     Unfolding(loop-breaker): <stable> (\ @ n
                                          (w :: [[n]])
                                          (w1 :: [n])
                                          (ww :: GHC.Prim.Int#)
                                          (ww1 :: GHC.Prim.Int#)
                                          (ww2 :: GHC.Prim.Int#) ->
                                        case w of a { DEFAULT ->
                                        case w1 of x { DEFAULT ->
                                        case GHC.Prim.tagToEnum#
                                               @ GHC.Types.Bool
                                               (GHC.Prim.<# ww ww2) of wild {
                                          GHC.Types.False
                                          -> case ww1 of wild1 {
                                               DEFAULT
                                               -> case GHC.List.$w!!
                                                         @ n
                                                         (GHC.List.$w!! @ [n] a ww)
                                                         wild1 of aij { DEFAULT ->
                                                  HBLAS.Level2.$wgetUpperTotalRow
                                                    @ n
                                                    a
                                                    (GHC.Types.: @ n aij x)
                                                    (GHC.Prim.-# ww 1#)
                                                    (GHC.Prim.+# wild1 1#)
                                                    ww2 }
                                               0#
                                               -> HBLAS.Level2.$wgetUpperTotalRow
                                                    @ n
                                                    a
                                                    x
                                                    (GHC.Prim.-# ww 1#)
                                                    1#
                                                    ww2 }
                                          GHC.Types.True -> x } } }) -}
0146ce3841116615e7068864b7cf9bc7
  $wtrmvLower ::
    GHC.Real.Fractional n =>
    [[n]] -> [n] -> [n] -> GHC.Prim.Int# -> GHC.Prim.Int# -> [n]
  {- Arity: 6,
     Strictness: <L,U(U(C(C1(U)),A,C(C1(U)),A,A,A,C(U)),A,A,A)><S,1*U><S,U><S,1*U><S,U><S,U>,
     Inline: [0],
     Unfolding(loop-breaker): <stable> (\ @ n
                                          (w :: GHC.Real.Fractional n)
                                          (w1 :: [[n]])
                                          (w2 :: [n])
                                          (w3 :: [n])
                                          (ww :: GHC.Prim.Int#)
                                          (ww1 :: GHC.Prim.Int#) ->
                                        let {
                                          $dNum :: GHC.Num.Num n = GHC.Real.$p1Fractional @ n w
                                        } in
                                        case w1 of a { DEFAULT ->
                                        case w2 of x { DEFAULT ->
                                        case w3 of b { DEFAULT ->
                                        case GHC.Prim.tagToEnum#
                                               @ GHC.Types.Bool
                                               (GHC.Prim.>=# ww ww1) of wild {
                                          GHC.Types.False
                                          -> let {
                                               n1 :: GHC.Prim.Int# = GHC.Prim.+# ww 1#
                                             } in
                                             let {
                                               $j :: [n] -> [n] <join 1> {- Arity: 1 -}
                                               = \ (bi :: [n])[OneShot] ->
                                                 let {
                                                   n2 :: GHC.Prim.Int# = GHC.Prim.+# ww 1#
                                                 } in
                                                 let {
                                                   $j1 :: [n] -> [n] <join 1> {- Arity: 1 -}
                                                   = \ (ai :: [n])[OneShot] ->
                                                     let {
                                                       k :: n -> n -> n = GHC.Num.+ @ n $dNum
                                                     } in
                                                     letrec {
                                                       go2 :: [n] -> [n] -> n -> n {- Arity: 2 -}
                                                       = \ (ds :: [n]) (_ys :: [n]) ->
                                                         case ds of wild1 {
                                                           [] -> GHC.Base.id @ n
                                                           : ipv ipv1
                                                           -> case _ys of wild2 {
                                                                [] -> GHC.Base.id @ n
                                                                : ipv2 ipv3
                                                                -> \ (v :: n)[OneShot] ->
                                                                   go2
                                                                     ipv1
                                                                     ipv3
                                                                     (k v
                                                                        (GHC.Num.*
                                                                           @ n
                                                                           $dNum
                                                                           ipv
                                                                           ipv2)) } }
                                                     } in
                                                     case go2
                                                            ai
                                                            bi
                                                            (GHC.Num.fromInteger
                                                               @ n
                                                               $dNum
                                                               0) of xi { DEFAULT ->
                                                     case HBLAS.Level2.$wupdate
                                                            @ n
                                                            x
                                                            ww
                                                            xi of ww2 { (#,#) ww3 ww4 ->
                                                     HBLAS.Level2.$wtrmvLower
                                                       @ n
                                                       w
                                                       a
                                                       (GHC.Types.: @ n ww3 ww4)
                                                       b
                                                       (GHC.Prim.+# ww 1#)
                                                       ww1 } }
                                                 } in
                                                 case GHC.Prim.tagToEnum#
                                                        @ GHC.Types.Bool
                                                        (GHC.Prim.<# 0# n2) of wild1 {
                                                   GHC.Types.False -> $j1 (GHC.Types.[] @ n)
                                                   GHC.Types.True
                                                   -> let {
                                                        z :: GHC.Types.Int -> [n] {- Arity: 1 -}
                                                        = GHC.List.flipSeqTake
                                                            @ [n]
                                                            (GHC.Types.[] @ n)
                                                      } in
                                                      letrec {
                                                        go :: [n] -> GHC.Types.Int -> [n]
                                                          {- Arity: 1 -}
                                                        = \ (ds :: [n]) ->
                                                          case ds of wild2 {
                                                            [] -> z
                                                            : y ys
                                                            -> let {
                                                                 xs :: GHC.Types.Int -> [n] = go ys
                                                               } in
                                                               \ (m :: GHC.Types.Int) ->
                                                               case m of wild3 { GHC.Types.I# ds1 ->
                                                               case ds1 of ds2 {
                                                                 DEFAULT
                                                                 -> GHC.Types.:
                                                                      @ n
                                                                      y
                                                                      (xs
                                                                         (GHC.Types.I#
                                                                            (GHC.Prim.-# ds2 1#)))
                                                                 1#
                                                                 -> GHC.Types.:
                                                                      @ n
                                                                      y
                                                                      (GHC.Types.[] @ n) } } }
                                                      } in
                                                      case go
                                                             (GHC.List.$w!! @ [n] a ww)
                                                             (GHC.Types.I# n2) of ai { DEFAULT ->
                                                      $j1 ai } }
                                             } in
                                             case GHC.Prim.tagToEnum#
                                                    @ GHC.Types.Bool
                                                    (GHC.Prim.<# 0# n1) of wild1 {
                                               GHC.Types.False -> $j (GHC.Types.[] @ n)
                                               GHC.Types.True
                                               -> let {
                                                    z :: GHC.Types.Int -> [n] {- Arity: 1 -}
                                                    = GHC.List.flipSeqTake @ [n] (GHC.Types.[] @ n)
                                                  } in
                                                  letrec {
                                                    go :: [n] -> GHC.Types.Int -> [n] {- Arity: 1 -}
                                                    = \ (ds :: [n]) ->
                                                      case ds of wild2 {
                                                        [] -> z
                                                        : y ys
                                                        -> let {
                                                             xs :: GHC.Types.Int -> [n] = go ys
                                                           } in
                                                           \ (m :: GHC.Types.Int) ->
                                                           case m of wild3 { GHC.Types.I# ds1 ->
                                                           case ds1 of ds2 {
                                                             DEFAULT
                                                             -> GHC.Types.:
                                                                  @ n
                                                                  y
                                                                  (xs
                                                                     (GHC.Types.I#
                                                                        (GHC.Prim.-# ds2 1#)))
                                                             1#
                                                             -> GHC.Types.:
                                                                  @ n
                                                                  y
                                                                  (GHC.Types.[] @ n) } } }
                                                  } in
                                                  case go b (GHC.Types.I# n1) of bi { DEFAULT ->
                                                  $j bi } }
                                          GHC.Types.True -> x } } } }) -}
4455a187885b4003ce6f694e72c38589
  $wtrmvUpper ::
    GHC.Real.Fractional n =>
    [[n]] -> [n] -> [n] -> GHC.Prim.Int# -> GHC.Prim.Int# -> [n]
  {- Arity: 6,
     Strictness: <L,U(U(C(C1(U)),A,C(C1(U)),A,A,A,C(U)),A,A,A)><S,1*U><S,U><S,1*U><S,U><S,U>,
     Inline: [0],
     Unfolding(loop-breaker): <stable> (\ @ n
                                          (w :: GHC.Real.Fractional n)
                                          (w1 :: [[n]])
                                          (w2 :: [n])
                                          (w3 :: [n])
                                          (ww :: GHC.Prim.Int#)
                                          (ww1 :: GHC.Prim.Int#) ->
                                        let {
                                          $dNum :: GHC.Num.Num n = GHC.Real.$p1Fractional @ n w
                                        } in
                                        case w1 of a { DEFAULT ->
                                        case w2 of x { DEFAULT ->
                                        case w3 of b { DEFAULT ->
                                        let {
                                          i :: GHC.Types.Int = GHC.Types.I# ww
                                        } in
                                        case GHC.Prim.tagToEnum#
                                               @ GHC.Types.Bool
                                               (GHC.Prim.>=# ww ww1) of wild {
                                          GHC.Types.False
                                          -> letrec {
                                               unsafeDrop :: forall a1.
                                                             GHC.Types.Int -> [a1] -> [a1]
                                                 {- Arity: 2 -}
                                               = \ @ a1 (ds :: GHC.Types.Int) (ds1 :: [a1]) ->
                                                 case ds of ds2 { GHC.Types.I# ipv ->
                                                 case ds1 of wild1 {
                                                   [] -> GHC.Types.[] @ a1
                                                   : ipv1 ipv2
                                                   -> case ipv of ds3 {
                                                        DEFAULT
                                                        -> unsafeDrop
                                                             @ a1
                                                             (GHC.Types.I# (GHC.Prim.-# ds3 1#))
                                                             ipv2
                                                        1# -> ipv2 } } }
                                             } in
                                             let {
                                               $j :: [n] -> [n] <join 1> {- Arity: 1 -}
                                               = \ (bi :: [n])[OneShot] ->
                                                 letrec {
                                                   unsafeDrop1 :: forall a1.
                                                                  GHC.Types.Int -> [a1] -> [a1]
                                                     {- Arity: 2 -}
                                                   = \ @ a1 (ds :: GHC.Types.Int) (ds1 :: [a1]) ->
                                                     case ds of ds2 { GHC.Types.I# ipv ->
                                                     case ds1 of wild1 {
                                                       [] -> GHC.Types.[] @ a1
                                                       : ipv1 ipv2
                                                       -> case ipv of ds3 {
                                                            DEFAULT
                                                            -> unsafeDrop1
                                                                 @ a1
                                                                 (GHC.Types.I# (GHC.Prim.-# ds3 1#))
                                                                 ipv2
                                                            1# -> ipv2 } } }
                                                 } in
                                                 let {
                                                   $j1 :: [n] -> [n] <join 1> {- Arity: 1 -}
                                                   = \ (ai :: [n])[OneShot] ->
                                                     let {
                                                       k :: n -> n -> n = GHC.Num.+ @ n $dNum
                                                     } in
                                                     letrec {
                                                       go2 :: [n] -> [n] -> n -> n {- Arity: 2 -}
                                                       = \ (ds :: [n]) (_ys :: [n]) ->
                                                         case ds of wild1 {
                                                           [] -> GHC.Base.id @ n
                                                           : ipv ipv1
                                                           -> case _ys of wild2 {
                                                                [] -> GHC.Base.id @ n
                                                                : ipv2 ipv3
                                                                -> \ (v :: n)[OneShot] ->
                                                                   go2
                                                                     ipv1
                                                                     ipv3
                                                                     (k v
                                                                        (GHC.Num.*
                                                                           @ n
                                                                           $dNum
                                                                           ipv
                                                                           ipv2)) } }
                                                     } in
                                                     case go2
                                                            ai
                                                            bi
                                                            (GHC.Num.fromInteger
                                                               @ n
                                                               $dNum
                                                               0) of xi { DEFAULT ->
                                                     case HBLAS.Level2.$wupdate
                                                            @ n
                                                            x
                                                            ww
                                                            xi of ww2 { (#,#) ww3 ww4 ->
                                                     HBLAS.Level2.$wtrmvUpper
                                                       @ n
                                                       w
                                                       a
                                                       (GHC.Types.: @ n ww3 ww4)
                                                       b
                                                       (GHC.Prim.+# ww 1#)
                                                       ww1 } }
                                                 } in
                                                 case GHC.Prim.tagToEnum#
                                                        @ GHC.Types.Bool
                                                        (GHC.Prim.<=# ww 0#) of wild1 {
                                                   GHC.Types.False
                                                   -> case unsafeDrop1
                                                             @ n
                                                             i
                                                             (GHC.List.$w!!
                                                                @ [n]
                                                                a
                                                                ww) of ai { DEFAULT ->
                                                      $j1 ai }
                                                   GHC.Types.True
                                                   -> case GHC.List.$w!!
                                                             @ [n]
                                                             a
                                                             ww of ai { DEFAULT ->
                                                      $j1 ai } }
                                             } in
                                             case GHC.Prim.tagToEnum#
                                                    @ GHC.Types.Bool
                                                    (GHC.Prim.<=# ww 0#) of wild1 {
                                               GHC.Types.False
                                               -> case unsafeDrop @ n i b of bi { DEFAULT -> $j bi }
                                               GHC.Types.True -> $j b }
                                          GHC.Types.True -> x } } } }) -}
9ec36b18ec4b70c329990c193529bbfa
  $wtrsvLower ::
    GHC.Real.Fractional n =>
    [[n]]
    -> [n] -> [n] -> GHC.Prim.Int# -> GHC.Prim.Int# -> (# [n], [n] #)
  {- Arity: 6,
     Strictness: <L,U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,C(U)),C(C1(U)),A,A)><S,1*U><S,1*U><S,1*U><S,U><S,U>,
     Inline: [0],
     Unfolding(loop-breaker): <stable> (\ @ n
                                          (w :: GHC.Real.Fractional n)
                                          (w1 :: [[n]])
                                          (w2 :: [n])
                                          (w3 :: [n])
                                          (ww :: GHC.Prim.Int#)
                                          (ww1 :: GHC.Prim.Int#) ->
                                        let {
                                          $dNum :: GHC.Num.Num n = GHC.Real.$p1Fractional @ n w
                                        } in
                                        case w1 of a { DEFAULT ->
                                        case w2 of x { DEFAULT ->
                                        case w3 of b { DEFAULT ->
                                        case GHC.Prim.tagToEnum#
                                               @ GHC.Types.Bool
                                               (GHC.Prim.>=# ww ww1) of wild {
                                          GHC.Types.False
                                          -> case GHC.List.$w!!
                                                    @ n
                                                    (GHC.List.$w!! @ [n] a ww)
                                                    ww of aii { DEFAULT ->
                                             case GHC.List.$w!! @ [n] a ww of veca { DEFAULT ->
                                             case GHC.List.$w!! @ n b ww of valueb { DEFAULT ->
                                             case GHC.Num.-
                                                    @ n
                                                    $dNum
                                                    valueb
                                                    (let {
                                                       k :: n -> n -> n = GHC.Num.+ @ n $dNum
                                                     } in
                                                     letrec {
                                                       go2 :: [n] -> [n] -> n -> n {- Arity: 2 -}
                                                       = \ (ds :: [n]) (_ys :: [n]) ->
                                                         case ds of wild1 {
                                                           [] -> GHC.Base.id @ n
                                                           : ipv ipv1
                                                           -> case _ys of wild2 {
                                                                [] -> GHC.Base.id @ n
                                                                : ipv2 ipv3
                                                                -> \ (v :: n)[OneShot] ->
                                                                   go2
                                                                     ipv1
                                                                     ipv3
                                                                     (k v
                                                                        (GHC.Num.*
                                                                           @ n
                                                                           $dNum
                                                                           ipv
                                                                           ipv2)) } }
                                                     } in
                                                     go2
                                                       veca
                                                       x
                                                       (GHC.Num.fromInteger
                                                          @ n
                                                          $dNum
                                                          0)) of new_bi { DEFAULT ->
                                             case HBLAS.Level2.$wupdate
                                                    @ n
                                                    b
                                                    ww
                                                    new_bi of ww2 { (#,#) ww3 ww4 ->
                                             case HBLAS.Level2.$wupdate
                                                    @ n
                                                    x
                                                    ww
                                                    (GHC.Real./
                                                       @ n
                                                       w
                                                       new_bi
                                                       aii) of ww5 { (#,#) ww6 ww7 ->
                                             HBLAS.Level2.$wtrsvLower
                                               @ n
                                               w
                                               a
                                               (GHC.Types.: @ n ww6 ww7)
                                               (GHC.Types.: @ n ww3 ww4)
                                               (GHC.Prim.+# ww 1#)
                                               ww1 } } } } } }
                                          GHC.Types.True -> (# x, b #) } } } }) -}
7ae4b97b845b37ba8e7657f5fa2ade46
  $wtrsvUpper ::
    GHC.Real.Fractional n =>
    [[n]]
    -> [n] -> [n] -> GHC.Prim.Int# -> GHC.Prim.Int# -> (# [n], [n] #)
  {- Arity: 6,
     Strictness: <L,U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,C(U)),C(C1(U)),A,A)><S,1*U><S,1*U><S,1*U><S,U><S,U>,
     Inline: [0],
     Unfolding(loop-breaker): <stable> (\ @ n
                                          (w :: GHC.Real.Fractional n)
                                          (w1 :: [[n]])
                                          (w2 :: [n])
                                          (w3 :: [n])
                                          (ww :: GHC.Prim.Int#)
                                          (ww1 :: GHC.Prim.Int#) ->
                                        let {
                                          $dNum :: GHC.Num.Num n = GHC.Real.$p1Fractional @ n w
                                        } in
                                        case w1 of a { DEFAULT ->
                                        case w2 of x { DEFAULT ->
                                        case w3 of b { DEFAULT ->
                                        case GHC.Prim.tagToEnum#
                                               @ GHC.Types.Bool
                                               (GHC.Prim.<=# ww ww1) of wild {
                                          GHC.Types.False
                                          -> case GHC.List.$w!!
                                                    @ n
                                                    (GHC.List.$w!! @ [n] a ww)
                                                    ww of aii { DEFAULT ->
                                             case GHC.List.$w!! @ [n] a ww of veca { DEFAULT ->
                                             case GHC.List.$w!! @ n b ww of valueb { DEFAULT ->
                                             case GHC.Num.-
                                                    @ n
                                                    $dNum
                                                    valueb
                                                    (let {
                                                       k :: n -> n -> n = GHC.Num.+ @ n $dNum
                                                     } in
                                                     letrec {
                                                       go2 :: [n] -> [n] -> n -> n {- Arity: 2 -}
                                                       = \ (ds :: [n]) (_ys :: [n]) ->
                                                         case ds of wild1 {
                                                           [] -> GHC.Base.id @ n
                                                           : ipv ipv1
                                                           -> case _ys of wild2 {
                                                                [] -> GHC.Base.id @ n
                                                                : ipv2 ipv3
                                                                -> \ (v :: n)[OneShot] ->
                                                                   go2
                                                                     ipv1
                                                                     ipv3
                                                                     (k v
                                                                        (GHC.Num.*
                                                                           @ n
                                                                           $dNum
                                                                           ipv
                                                                           ipv2)) } }
                                                     } in
                                                     go2
                                                       veca
                                                       x
                                                       (GHC.Num.fromInteger
                                                          @ n
                                                          $dNum
                                                          0)) of new_bi { DEFAULT ->
                                             case HBLAS.Level2.$wupdate
                                                    @ n
                                                    b
                                                    ww
                                                    new_bi of ww2 { (#,#) ww3 ww4 ->
                                             case HBLAS.Level2.$wupdate
                                                    @ n
                                                    x
                                                    ww
                                                    (GHC.Real./
                                                       @ n
                                                       w
                                                       new_bi
                                                       aii) of ww5 { (#,#) ww6 ww7 ->
                                             HBLAS.Level2.$wtrsvUpper
                                               @ n
                                               w
                                               a
                                               (GHC.Types.: @ n ww6 ww7)
                                               (GHC.Types.: @ n ww3 ww4)
                                               (GHC.Prim.-# ww 1#)
                                               ww1 } } } } } }
                                          GHC.Types.True -> (# x, b #) } } } }) -}
56a209fcbae6ebb742e6d0f311d49cd1
  $wupdate :: [n] -> GHC.Prim.Int# -> n -> (# n, [n] #)
  {- Arity: 3, Strictness: <S,1*U><S,U><S,1*U>, Inline: [0],
     Unfolding(loop-breaker): <stable> (\ @ n
                                          (w :: [n])
                                          (ww :: GHC.Prim.Int#)
                                          (w1 :: n) ->
                                        case w of wild {
                                          []
                                          -> case Control.Exception.Base.patError
                                                    @ 'GHC.Types.LiftedRep
                                                    @ [n]
                                                    "haskell/HBLAS/Level2.hs:(164,1)-(166,31)|function update"#
                                             ret_ty (# n, [n] #)
                                             of {}
                                          : x xs
                                          -> case w1 of value { DEFAULT ->
                                             case GHC.Prim.tagToEnum#
                                                    @ GHC.Types.Bool
                                                    (GHC.Prim.># ww 0#) of wild1 {
                                               GHC.Types.False -> (# value, xs #)
                                               GHC.Types.True
                                               -> (# x,
                                                     case HBLAS.Level2.$wupdate
                                                            @ n
                                                            xs
                                                            (GHC.Prim.-# ww 1#)
                                                            value of ww1 { (#,#) ww2 ww3 ->
                                                     GHC.Types.: @ n ww2 ww3 } #) } } }) -}
1e95a28f38c73ce02b44d371405d4eac
  gemv :: GHC.Num.Num n => [[n]] -> [n] -> [n] -> n -> n -> [n]
  {- Arity: 6, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A,C(C(U)),A,A,A,C(U))><S,1*U><S,1*U><S,1*U><S,1*U><S,1*U>,
     Inline: (sat-args=5),
     Unfolding: InlineRule (6, False, False)
                (\ @ n
                   ($dNum :: GHC.Num.Num n)
                   (matA :: [[n]])
                   (vecX :: [n])
                   (vecY :: [n])
                   (alpha :: n)
                   (beta :: n) ->
                 case matA of matA1 { DEFAULT ->
                 case vecX of vecX1 { DEFAULT ->
                 case vecY of vecY1 { DEFAULT ->
                 case alpha of alpha1 { DEFAULT ->
                 case beta of beta1 { DEFAULT ->
                 case GHC.Base.build
                        @ n
                        (\ @ b1 (c :: n -> b1 -> b1)[OneShot] (n1 :: b1)[OneShot] ->
                         GHC.Base.foldr
                           @ n
                           @ b1
                           (GHC.Base.mapFB @ n @ b1 @ n c (GHC.Num.* @ n $dNum beta1))
                           n1
                           vecY1) of y1 { DEFAULT ->
                 case GHC.Base.build
                        @ n
                        (\ @ b1 (c :: n -> b1 -> b1)[OneShot] (n1 :: b1)[OneShot] ->
                         GHC.Base.foldr
                           @ [n]
                           @ b1
                           (GHC.Base.mapFB
                              @ n
                              @ b1
                              @ [n]
                              c
                              (HBLAS.Level1.dot @ n $dNum vecX1))
                           n1
                           matA1) of x1 { DEFAULT ->
                 GHC.Base.build
                   @ n
                   (\ @ b1 (c1 :: n -> b1 -> b1)[OneShot] (n1 :: b1)[OneShot] ->
                    GHC.List.foldr2
                      @ n
                      @ n
                      @ b1
                      (GHC.List.zipWithFB
                         @ n
                         @ b1
                         @ b1
                         @ n
                         @ n
                         c1
                         (\ (x :: n) (y :: n)[OneShot] ->
                          GHC.Num.+ @ n $dNum y (GHC.Num.* @ n $dNum alpha1 x)))
                      n1
                      x1
                      y1) } } } } } } }) -}
d8dd8dc589f6114decf9233df3977b77
  gemv' :: GHC.Num.Num n => [[n]] -> [n] -> [n]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A,C(C1(U)),A,A,A,C(U))><S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ n ($dNum :: GHC.Num.Num n) (matA :: [[n]]) (vecX :: [n]) ->
                 case matA of matA1 { DEFAULT ->
                 case vecX of vecX1 { DEFAULT ->
                 GHC.Base.build
                   @ n
                   (\ @ b1 (c :: n -> b1 -> b1)[OneShot] (n1 :: b1)[OneShot] ->
                    GHC.Base.foldr
                      @ [n]
                      @ b1
                      (GHC.Base.mapFB
                         @ n
                         @ b1
                         @ [n]
                         c
                         (HBLAS.Level1.dot @ n $dNum vecX1))
                      n1
                      matA1) } }) -}
b83bc563b0258f7ad857d3409161f76e
  getLowerTotalMatrix ::
    GHC.Num.Num n => [[n]] -> GHC.Types.Int -> GHC.Types.Int -> [[n]]
  {- Arity: 4, Strictness: <L,A><S,U><S(S),1*U(U)><S(S),1*U(U)>m2,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ n
                   (w :: GHC.Num.Num n)
                   (w1 :: [[n]])
                   (w2 :: GHC.Types.Int)
                   (w3 :: GHC.Types.Int) ->
                 case w2 of ww { GHC.Types.I# ww1 ->
                 case w3 of ww2 { GHC.Types.I# ww3 ->
                 case HBLAS.Level2.$wgetLowerTotalMatrix
                        @ n
                        w1
                        ww1
                        ww3 of ww4 { (#,#) ww5 ww6 ->
                 GHC.Types.: @ [n] ww5 ww6 } } }) -}
e03140c65eb183428440fcdeb28649ad
  getLowerTotalRow ::
    GHC.Num.Num n =>
    [[n]]
    -> [n] -> GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int -> [n]
  {- Arity: 6,
     Strictness: <L,A><S,1*U><S,1*U><S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)>,
     Inline: [0],
     Unfolding: InlineRule (6, True, False)
                (\ @ n
                   (w :: GHC.Num.Num n)
                   (w1 :: [[n]])
                   (w2 :: [n])
                   (w3 :: GHC.Types.Int)
                   (w4 :: GHC.Types.Int)
                   (w5 :: GHC.Types.Int) ->
                 case w3 of ww { GHC.Types.I# ww1 ->
                 case w4 of ww2 { GHC.Types.I# ww3 ->
                 case w5 of ww4 { GHC.Types.I# ww5 ->
                 HBLAS.Level2.$wgetLowerTotalRow @ n w1 w2 ww1 ww3 ww5 } } }) -}
be44b09579c9182904ed9369772ce982
  getUpperTotalMatrix ::
    GHC.Num.Num n => [[n]] -> GHC.Types.Int -> GHC.Types.Int -> [[n]]
  {- Arity: 4, Strictness: <L,A><S,U><S(S),1*U(U)><S(S),1*U(U)>m2,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ n
                   (w :: GHC.Num.Num n)
                   (w1 :: [[n]])
                   (w2 :: GHC.Types.Int)
                   (w3 :: GHC.Types.Int) ->
                 case w2 of ww { GHC.Types.I# ww1 ->
                 case w3 of ww2 { GHC.Types.I# ww3 ->
                 case HBLAS.Level2.$wgetUpperTotalMatrix
                        @ n
                        w1
                        ww1
                        ww3 of ww4 { (#,#) ww5 ww6 ->
                 GHC.Types.: @ [n] ww5 ww6 } } }) -}
dbe817c478853d7124da8b52e27aaae5
  getUpperTotalRow ::
    GHC.Num.Num n =>
    [[n]]
    -> [n] -> GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int -> [n]
  {- Arity: 6,
     Strictness: <L,A><S,1*U><S,1*U><S(S),1*U(U)><S(S),1*U(1*U)><S(S),1*U(U)>,
     Inline: [0],
     Unfolding: InlineRule (6, True, False)
                (\ @ n
                   (w :: GHC.Num.Num n)
                   (w1 :: [[n]])
                   (w2 :: [n])
                   (w3 :: GHC.Types.Int)
                   (w4 :: GHC.Types.Int)
                   (w5 :: GHC.Types.Int) ->
                 case w3 of ww { GHC.Types.I# ww1 ->
                 case w4 of ww2 { GHC.Types.I# ww3 ->
                 case w5 of ww4 { GHC.Types.I# ww5 ->
                 HBLAS.Level2.$wgetUpperTotalRow @ n w1 w2 ww1 ww3 ww5 } } }) -}
c2d3b874202b6067b7f30d46d1a83ad1
  symv ::
    GHC.Num.Num n =>
    [[n]] -> [n] -> [n] -> n -> n -> GHC.Types.Char -> [n]
  {- Arity: 7,
     Strictness: <L,U(C(C1(U)),A,C(C(U)),A,A,A,C(U))><S,U><S,U><S,1*U><S,1*U><S,1*U><S(S),1*U(1*U)>,
     Inline: (sat-args=6),
     Unfolding: InlineRule (7, False, False)
                (\ @ n
                   ($dNum :: GHC.Num.Num n)
                   (matA :: [[n]])
                   (vecX :: [n])
                   (vecY :: [n])
                   (alpha :: n)
                   (beta :: n)
                   (uplo :: GHC.Types.Char) ->
                 case matA of matA1 { DEFAULT ->
                 case vecX of vecX1 { DEFAULT ->
                 case vecY of vecY1 { DEFAULT ->
                 case alpha of alpha1 { DEFAULT ->
                 case beta of beta1 { DEFAULT ->
                 case uplo of uplo1 { GHC.Types.C# ipv ->
                 case GHC.Classes.eqChar uplo1 (GHC.Types.C# 'l'#) of wild {
                   GHC.Types.False
                   -> case GHC.Base.build
                             @ n
                             (\ @ b1 (c :: n -> b1 -> b1)[OneShot] (n1 :: b1)[OneShot] ->
                              GHC.Base.foldr
                                @ n
                                @ b1
                                (GHC.Base.mapFB @ n @ b1 @ n c (GHC.Num.* @ n $dNum beta1))
                                n1
                                vecY1) of y1 { DEFAULT ->
                      case GHC.Base.foldr
                             @ n
                             @ (GHC.Types.Int -> GHC.Types.Int)
                             (GHC.List.lengthFB @ n)
                             GHC.List.idLength
                             vecX1
                             (GHC.Types.I# 0#) of n1 { GHC.Types.I# ipv1 ->
                      case HBLAS.Level2.getUpperTotalMatrix
                             @ n
                             $dNum
                             matA1
                             (GHC.Types.I# 0#)
                             n1 of mat { DEFAULT ->
                      case GHC.Base.build
                             @ n
                             (\ @ b1 (c :: n -> b1 -> b1)[OneShot] (n2 :: b1)[OneShot] ->
                              GHC.Base.foldr
                                @ [n]
                                @ b1
                                (GHC.Base.mapFB
                                   @ n
                                   @ b1
                                   @ [n]
                                   c
                                   (HBLAS.Level1.dot @ n $dNum vecX1))
                                n2
                                mat) of x1 { DEFAULT ->
                      GHC.Base.build
                        @ n
                        (\ @ b1 (c1 :: n -> b1 -> b1)[OneShot] (n2 :: b1)[OneShot] ->
                         GHC.List.foldr2
                           @ n
                           @ n
                           @ b1
                           (GHC.List.zipWithFB
                              @ n
                              @ b1
                              @ b1
                              @ n
                              @ n
                              c1
                              (\ (x :: n) (y :: n)[OneShot] ->
                               GHC.Num.+ @ n $dNum y (GHC.Num.* @ n $dNum alpha1 x)))
                           n2
                           x1
                           y1) } } } }
                   GHC.Types.True
                   -> case GHC.Base.build
                             @ n
                             (\ @ b1 (c :: n -> b1 -> b1)[OneShot] (n1 :: b1)[OneShot] ->
                              GHC.Base.foldr
                                @ n
                                @ b1
                                (GHC.Base.mapFB @ n @ b1 @ n c (GHC.Num.* @ n $dNum beta1))
                                n1
                                vecY1) of y1 { DEFAULT ->
                      case GHC.Base.foldr
                             @ n
                             @ (GHC.Types.Int -> GHC.Types.Int)
                             (GHC.List.lengthFB @ n)
                             GHC.List.idLength
                             vecX1
                             (GHC.Types.I# 0#) of n1 { GHC.Types.I# ipv1 ->
                      case HBLAS.Level2.getLowerTotalMatrix
                             @ n
                             $dNum
                             matA1
                             (GHC.Types.I# 0#)
                             n1 of mat { DEFAULT ->
                      case GHC.Base.build
                             @ n
                             (\ @ b1 (c :: n -> b1 -> b1)[OneShot] (n2 :: b1)[OneShot] ->
                              GHC.Base.foldr
                                @ [n]
                                @ b1
                                (GHC.Base.mapFB
                                   @ n
                                   @ b1
                                   @ [n]
                                   c
                                   (HBLAS.Level1.dot @ n $dNum vecX1))
                                n2
                                mat) of x1 { DEFAULT ->
                      GHC.Base.build
                        @ n
                        (\ @ b1 (c1 :: n -> b1 -> b1)[OneShot] (n2 :: b1)[OneShot] ->
                         GHC.List.foldr2
                           @ n
                           @ n
                           @ b1
                           (GHC.List.zipWithFB
                              @ n
                              @ b1
                              @ b1
                              @ n
                              @ n
                              c1
                              (\ (x :: n) (y :: n)[OneShot] ->
                               GHC.Num.+ @ n $dNum y (GHC.Num.* @ n $dNum alpha1 x)))
                           n2
                           x1
                           y1) } } } } } } } } } } }) -}
b2947279b0bbdda3ab000e7ef2841169
  symvLower :: GHC.Num.Num n => [[n]] -> [n] -> [n] -> n -> n -> [n]
  {- Arity: 6,
     Strictness: <L,U(C(C1(U)),A,C(C(U)),A,A,A,C(U))><S,U><S,U><S,1*U><S,1*U><S,1*U>,
     Inline: (sat-args=5),
     Unfolding: InlineRule (6, False, False)
                (\ @ n
                   ($dNum :: GHC.Num.Num n)
                   (matA :: [[n]])
                   (vecX :: [n])
                   (vecY :: [n])
                   (alpha :: n)
                   (beta :: n) ->
                 case matA of matA1 { DEFAULT ->
                 case vecX of vecX1 { DEFAULT ->
                 case vecY of vecY1 { DEFAULT ->
                 case alpha of alpha1 { DEFAULT ->
                 case beta of beta1 { DEFAULT ->
                 case GHC.Base.build
                        @ n
                        (\ @ b1 (c :: n -> b1 -> b1)[OneShot] (n1 :: b1)[OneShot] ->
                         GHC.Base.foldr
                           @ n
                           @ b1
                           (GHC.Base.mapFB @ n @ b1 @ n c (GHC.Num.* @ n $dNum beta1))
                           n1
                           vecY1) of y1 { DEFAULT ->
                 case GHC.Base.foldr
                        @ n
                        @ (GHC.Types.Int -> GHC.Types.Int)
                        (GHC.List.lengthFB @ n)
                        GHC.List.idLength
                        vecX1
                        (GHC.Types.I# 0#) of n1 { GHC.Types.I# ipv ->
                 case HBLAS.Level2.getLowerTotalMatrix
                        @ n
                        $dNum
                        matA1
                        (GHC.Types.I# 0#)
                        n1 of mat { DEFAULT ->
                 case GHC.Base.build
                        @ n
                        (\ @ b1 (c :: n -> b1 -> b1)[OneShot] (n2 :: b1)[OneShot] ->
                         GHC.Base.foldr
                           @ [n]
                           @ b1
                           (GHC.Base.mapFB
                              @ n
                              @ b1
                              @ [n]
                              c
                              (HBLAS.Level1.dot @ n $dNum vecX1))
                           n2
                           mat) of x1 { DEFAULT ->
                 GHC.Base.build
                   @ n
                   (\ @ b1 (c1 :: n -> b1 -> b1)[OneShot] (n2 :: b1)[OneShot] ->
                    GHC.List.foldr2
                      @ n
                      @ n
                      @ b1
                      (GHC.List.zipWithFB
                         @ n
                         @ b1
                         @ b1
                         @ n
                         @ n
                         c1
                         (\ (x :: n) (y :: n)[OneShot] ->
                          GHC.Num.+ @ n $dNum y (GHC.Num.* @ n $dNum alpha1 x)))
                      n2
                      x1
                      y1) } } } } } } } } }) -}
9112a3bd9ed7d17a7e99b4eea409b693
  symvUpper :: GHC.Num.Num n => [[n]] -> [n] -> [n] -> n -> n -> [n]
  {- Arity: 6,
     Strictness: <L,U(C(C1(U)),A,C(C(U)),A,A,A,C(U))><S,U><S,U><S,1*U><S,1*U><S,1*U>,
     Inline: (sat-args=5),
     Unfolding: InlineRule (6, False, False)
                (\ @ n
                   ($dNum :: GHC.Num.Num n)
                   (matA :: [[n]])
                   (vecX :: [n])
                   (vecY :: [n])
                   (alpha :: n)
                   (beta :: n) ->
                 case matA of matA1 { DEFAULT ->
                 case vecX of vecX1 { DEFAULT ->
                 case vecY of vecY1 { DEFAULT ->
                 case alpha of alpha1 { DEFAULT ->
                 case beta of beta1 { DEFAULT ->
                 case GHC.Base.build
                        @ n
                        (\ @ b1 (c :: n -> b1 -> b1)[OneShot] (n1 :: b1)[OneShot] ->
                         GHC.Base.foldr
                           @ n
                           @ b1
                           (GHC.Base.mapFB @ n @ b1 @ n c (GHC.Num.* @ n $dNum beta1))
                           n1
                           vecY1) of y1 { DEFAULT ->
                 case GHC.Base.foldr
                        @ n
                        @ (GHC.Types.Int -> GHC.Types.Int)
                        (GHC.List.lengthFB @ n)
                        GHC.List.idLength
                        vecX1
                        (GHC.Types.I# 0#) of n1 { GHC.Types.I# ipv ->
                 case HBLAS.Level2.getUpperTotalMatrix
                        @ n
                        $dNum
                        matA1
                        (GHC.Types.I# 0#)
                        n1 of mat { DEFAULT ->
                 case GHC.Base.build
                        @ n
                        (\ @ b1 (c :: n -> b1 -> b1)[OneShot] (n2 :: b1)[OneShot] ->
                         GHC.Base.foldr
                           @ [n]
                           @ b1
                           (GHC.Base.mapFB
                              @ n
                              @ b1
                              @ [n]
                              c
                              (HBLAS.Level1.dot @ n $dNum vecX1))
                           n2
                           mat) of x1 { DEFAULT ->
                 GHC.Base.build
                   @ n
                   (\ @ b1 (c1 :: n -> b1 -> b1)[OneShot] (n2 :: b1)[OneShot] ->
                    GHC.List.foldr2
                      @ n
                      @ n
                      @ b1
                      (GHC.List.zipWithFB
                         @ n
                         @ b1
                         @ b1
                         @ n
                         @ n
                         c1
                         (\ (x :: n) (y :: n)[OneShot] ->
                          GHC.Num.+ @ n $dNum y (GHC.Num.* @ n $dNum alpha1 x)))
                      n2
                      x1
                      y1) } } } } } } } } }) -}
107d1e9a681d44f4bf48e6c92f81f0cb
  trmv ::
    (GHC.Num.Num n, GHC.Real.Fractional n) =>
    [[n]] -> [n] -> GHC.Types.Char -> [n]
  {- Arity: 5,
     Strictness: <L,A><L,U(U(C(C1(U)),A,C(C1(U)),A,A,A,C(U)),A,A,A)><S,1*U><S,U><S(S),1*U(1*U)>,
     Inline: (sat-args=3),
     Unfolding: InlineRule (5, False, False)
                (\ @ n
                   ($dNum :: GHC.Num.Num n)
                   ($dFractional :: GHC.Real.Fractional n) ->
                 let {
                   $dNum1 :: GHC.Num.Num n = GHC.Real.$p1Fractional @ n $dFractional
                 } in
                 \ (a :: [[n]]) (b :: [n]) (uplo :: GHC.Types.Char) ->
                 case a of a1 { DEFAULT ->
                 case b of b1 { DEFAULT ->
                 case uplo of uplo1 { GHC.Types.C# ipv ->
                 case GHC.Base.foldr
                        @ n
                        @ (GHC.Types.Int -> GHC.Types.Int)
                        (GHC.List.lengthFB @ n)
                        GHC.List.idLength
                        b1
                        (GHC.Types.I# 0#) of n1 { GHC.Types.I# ipv1 ->
                 case GHC.Classes.eqChar uplo1 (GHC.Types.C# 'l'#) of wild {
                   GHC.Types.False
                   -> HBLAS.Level2.trmvUpper
                        @ n
                        $dNum1
                        $dFractional
                        a1
                        (GHC.Base.build
                           @ n
                           (\ @ b2 (c :: n -> b2 -> b2)[OneShot] (nil :: b2)[OneShot] ->
                            case GHC.Classes.ltInt (GHC.Types.I# 0#) n1 of wild1 {
                              GHC.Types.False -> nil
                              GHC.Types.True
                              -> GHC.List.repeatFB
                                   @ n
                                   @ (GHC.Types.Int -> b2)
                                   (GHC.List.takeFB @ n @ b2 c nil)
                                   (GHC.Num.fromInteger @ n $dNum1 0)
                                   n1 }))
                        b1
                        (GHC.Types.I# 0#)
                        n1
                   GHC.Types.True
                   -> HBLAS.Level2.trmvLower
                        @ n
                        $dNum1
                        $dFractional
                        a1
                        (GHC.Base.build
                           @ n
                           (\ @ b2 (c :: n -> b2 -> b2)[OneShot] (nil :: b2)[OneShot] ->
                            case GHC.Classes.ltInt (GHC.Types.I# 0#) n1 of wild1 {
                              GHC.Types.False -> nil
                              GHC.Types.True
                              -> GHC.List.repeatFB
                                   @ n
                                   @ (GHC.Types.Int -> b2)
                                   (GHC.List.takeFB @ n @ b2 c nil)
                                   (GHC.Num.fromInteger @ n $dNum1 0)
                                   n1 }))
                        b1
                        (GHC.Types.I# 0#)
                        n1 } } } } }) -}
edc12d688089049e1a588eae3744312a
  trmvHelper :: GHC.Num.Num n => [n] -> [n] -> n
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A,C(C1(U)),A,A,A,1*C1(U))><S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ n ($dNum :: GHC.Num.Num n) (veca :: [n]) (vecx :: [n]) ->
                 case veca of veca1 { DEFAULT ->
                 case vecx of vecx1 { DEFAULT ->
                 let {
                   k :: n -> n -> n = GHC.Num.+ @ n $dNum
                 } in
                 GHC.List.foldr2
                   @ n
                   @ n
                   @ (n -> n)
                   (GHC.List.zipWithFB
                      @ n
                      @ (n -> n)
                      @ (n -> n)
                      @ n
                      @ n
                      (\ (ds :: n) (ds1 :: n -> n)[OneShot] (v :: n)[OneShot] ->
                       ds1 (k v ds))
                      (\ (x :: n) (y :: n)[OneShot] -> GHC.Num.* @ n $dNum x y))
                   (GHC.Base.id @ n)
                   veca1
                   vecx1
                   (GHC.Num.fromInteger @ n $dNum 0) } }) -}
489207b13967488d4ef6beba00767add
  trmvLower ::
    (GHC.Num.Num n, GHC.Real.Fractional n) =>
    [[n]] -> [n] -> [n] -> GHC.Types.Int -> GHC.Types.Int -> [n]
  {- Arity: 7,
     Strictness: <L,A><L,U(U(C(C1(U)),A,C(C1(U)),A,A,A,C(U)),A,A,A)><S,1*U><S,U><S,1*U><S(S),1*U(U)><S(S),1*U(U)>,
     Inline: [0],
     Unfolding: InlineRule (7, True, False)
                (\ @ n
                   (w :: GHC.Num.Num n)
                   (w1 :: GHC.Real.Fractional n)
                   (w2 :: [[n]])
                   (w3 :: [n])
                   (w4 :: [n])
                   (w5 :: GHC.Types.Int)
                   (w6 :: GHC.Types.Int) ->
                 case w5 of ww { GHC.Types.I# ww1 ->
                 case w6 of ww2 { GHC.Types.I# ww3 ->
                 HBLAS.Level2.$wtrmvLower @ n w1 w2 w3 w4 ww1 ww3 } }) -}
07b462a855954a1e5424302a60d4c6c1
  trmvUpper ::
    (GHC.Num.Num n, GHC.Real.Fractional n) =>
    [[n]] -> [n] -> [n] -> GHC.Types.Int -> GHC.Types.Int -> [n]
  {- Arity: 7,
     Strictness: <L,A><L,U(U(C(C1(U)),A,C(C1(U)),A,A,A,C(U)),A,A,A)><S,1*U><S,U><S,1*U><S(S),1*U(U)><S(S),1*U(U)>,
     Inline: [0],
     Unfolding: InlineRule (7, True, False)
                (\ @ n
                   (w :: GHC.Num.Num n)
                   (w1 :: GHC.Real.Fractional n)
                   (w2 :: [[n]])
                   (w3 :: [n])
                   (w4 :: [n])
                   (w5 :: GHC.Types.Int)
                   (w6 :: GHC.Types.Int) ->
                 case w5 of ww { GHC.Types.I# ww1 ->
                 case w6 of ww2 { GHC.Types.I# ww3 ->
                 HBLAS.Level2.$wtrmvUpper @ n w1 w2 w3 w4 ww1 ww3 } }) -}
c7a91930e6b444393f7066a381fe5163
  trsv ::
    (GHC.Num.Num n, GHC.Real.Fractional n) =>
    [[n]] -> [n] -> GHC.Types.Char -> [n]
  {- Arity: 5,
     Strictness: <L,A><L,U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,C(U)),C(C1(U)),A,A)><S,1*U><S,U><S(S),1*U(1*U)>,
     Inline: (sat-args=3),
     Unfolding: InlineRule (5, False, False)
                (\ @ n
                   ($dNum :: GHC.Num.Num n)
                   ($dFractional :: GHC.Real.Fractional n) ->
                 let {
                   $dNum1 :: GHC.Num.Num n = GHC.Real.$p1Fractional @ n $dFractional
                 } in
                 \ (a :: [[n]]) (b :: [n]) (uplo :: GHC.Types.Char) ->
                 case a of a1 { DEFAULT ->
                 case b of b1 { DEFAULT ->
                 case uplo of uplo1 { GHC.Types.C# ipv ->
                 case GHC.Base.foldr
                        @ n
                        @ (GHC.Types.Int -> GHC.Types.Int)
                        (GHC.List.lengthFB @ n)
                        GHC.List.idLength
                        b1
                        (GHC.Types.I# 0#) of n1 { GHC.Types.I# ipv1 ->
                 case GHC.Classes.eqChar uplo1 (GHC.Types.C# 'l'#) of wild {
                   GHC.Types.False
                   -> case HBLAS.Level2.trsvUpper
                             @ n
                             $dNum1
                             $dFractional
                             a1
                             (GHC.Base.build
                                @ n
                                (\ @ b2 (c :: n -> b2 -> b2)[OneShot] (nil :: b2)[OneShot] ->
                                 case GHC.Classes.ltInt (GHC.Types.I# 0#) n1 of wild1 {
                                   GHC.Types.False -> nil
                                   GHC.Types.True
                                   -> GHC.List.repeatFB
                                        @ n
                                        @ (GHC.Types.Int -> b2)
                                        (GHC.List.takeFB @ n @ b2 c nil)
                                        (GHC.Num.fromInteger @ n $dNum1 0)
                                        n1 }))
                             b1
                             (GHC.Types.I# (GHC.Prim.-# ipv1 1#))
                             (GHC.Types.I# -1#) of wild1 { (,) x ds1 ->
                      x }
                   GHC.Types.True
                   -> case HBLAS.Level2.trsvLower
                             @ n
                             $dNum1
                             $dFractional
                             a1
                             (GHC.Base.build
                                @ n
                                (\ @ b2 (c :: n -> b2 -> b2)[OneShot] (nil :: b2)[OneShot] ->
                                 case GHC.Classes.ltInt (GHC.Types.I# 0#) n1 of wild1 {
                                   GHC.Types.False -> nil
                                   GHC.Types.True
                                   -> GHC.List.repeatFB
                                        @ n
                                        @ (GHC.Types.Int -> b2)
                                        (GHC.List.takeFB @ n @ b2 c nil)
                                        (GHC.Num.fromInteger @ n $dNum1 0)
                                        n1 }))
                             b1
                             (GHC.Types.I# 0#)
                             n1 of wild1 { (,) x ds1 ->
                      x } } } } } }) -}
0edabec1fa09e35c5ab77466bd261fff
  trsvHelper :: GHC.Num.Num n => [n] -> [n] -> n -> n
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLLLL),U(C(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,1*C1(U))><S,1*U><S,1*U><S,1*U>,
     Inline: (sat-args=3),
     Unfolding: InlineRule (4, False, False)
                (\ @ n
                   ($dNum :: GHC.Num.Num n)
                   (veca :: [n])
                   (vecx :: [n])
                   (valueb :: n) ->
                 case veca of veca1 { DEFAULT ->
                 case vecx of vecx1 { DEFAULT ->
                 case valueb of valueb1 { DEFAULT ->
                 GHC.Num.-
                   @ n
                   $dNum
                   valueb1
                   (let {
                      k :: n -> n -> n = GHC.Num.+ @ n $dNum
                    } in
                    GHC.List.foldr2
                      @ n
                      @ n
                      @ (n -> n)
                      (GHC.List.zipWithFB
                         @ n
                         @ (n -> n)
                         @ (n -> n)
                         @ n
                         @ n
                         (\ (ds :: n) (ds1 :: n -> n)[OneShot] (v :: n)[OneShot] ->
                          ds1 (k v ds))
                         (\ (x :: n) (y :: n)[OneShot] -> GHC.Num.* @ n $dNum x y))
                      (GHC.Base.id @ n)
                      veca1
                      vecx1
                      (GHC.Num.fromInteger @ n $dNum 0)) } } }) -}
e6c484738480f0eb66241aa4275c433f
  trsvLower ::
    (GHC.Num.Num n, GHC.Real.Fractional n) =>
    [[n]] -> [n] -> [n] -> GHC.Types.Int -> GHC.Types.Int -> ([n], [n])
  {- Arity: 7,
     Strictness: <L,A><L,U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,C(U)),C(C1(U)),A,A)><S,1*U><S,1*U><S,1*U><S(S),1*U(U)><S(S),1*U(U)>m,
     Inline: [0],
     Unfolding: InlineRule (7, True, False)
                (\ @ n
                   (w :: GHC.Num.Num n)
                   (w1 :: GHC.Real.Fractional n)
                   (w2 :: [[n]])
                   (w3 :: [n])
                   (w4 :: [n])
                   (w5 :: GHC.Types.Int)
                   (w6 :: GHC.Types.Int) ->
                 case w5 of ww { GHC.Types.I# ww1 ->
                 case w6 of ww2 { GHC.Types.I# ww3 ->
                 case HBLAS.Level2.$wtrsvLower
                        @ n
                        w1
                        w2
                        w3
                        w4
                        ww1
                        ww3 of ww4 { (#,#) ww5 ww6 ->
                 (ww5, ww6) } } }) -}
e19b3b894a5739696ebd1a906a410259
  trsvUpper ::
    (GHC.Num.Num n, GHC.Real.Fractional n) =>
    [[n]] -> [n] -> [n] -> GHC.Types.Int -> GHC.Types.Int -> ([n], [n])
  {- Arity: 7,
     Strictness: <L,A><L,U(U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,C(U)),C(C1(U)),A,A)><S,1*U><S,1*U><S,1*U><S(S),1*U(U)><S(S),1*U(U)>m,
     Inline: [0],
     Unfolding: InlineRule (7, True, False)
                (\ @ n
                   (w :: GHC.Num.Num n)
                   (w1 :: GHC.Real.Fractional n)
                   (w2 :: [[n]])
                   (w3 :: [n])
                   (w4 :: [n])
                   (w5 :: GHC.Types.Int)
                   (w6 :: GHC.Types.Int) ->
                 case w5 of ww { GHC.Types.I# ww1 ->
                 case w6 of ww2 { GHC.Types.I# ww3 ->
                 case HBLAS.Level2.$wtrsvUpper
                        @ n
                        w1
                        w2
                        w3
                        w4
                        ww1
                        ww3 of ww4 { (#,#) ww5 ww6 ->
                 (ww5, ww6) } } }) -}
6716a2ac7328f08535a398f65c4b8178
  update :: GHC.Num.Num n => [n] -> GHC.Types.Int -> n -> [n]
  {- Arity: 4, Strictness: <L,A><S,1*U><S(S),1*U(U)><S,1*U>m2,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ n
                   (w :: GHC.Num.Num n)
                   (w1 :: [n])
                   (w2 :: GHC.Types.Int)
                   (w3 :: n) ->
                 case w2 of ww { GHC.Types.I# ww1 ->
                 case HBLAS.Level2.$wupdate @ n w1 ww1 w3 of ww2 { (#,#) ww3 ww4 ->
                 GHC.Types.: @ n ww3 ww4 } }) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

