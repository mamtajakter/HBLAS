
==================== FINAL INTERFACE ====================
2020-05-31 21:52:57.816373 UTC

interface hblas-0.0.0.0-F71I6QhmeyVEy1DCNMIf5j:HBLAS.Level1 8022
  interface hash: 8de5fbe48ebcc6d42a22b5a212916b4b
  ABI hash: e5a5f8e86bcdadfbf727a29482339dde
  export-list hash: d6427fbb44e4769752ec04d4c68c80d8
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 2804918ffae816c69890ef0538da0f0c
  sig of: Nothing
  used TH splices: False
  where
exports:
  HBLAS.Level1.asum
  HBLAS.Level1.axpy
  HBLAS.Level1.axpy'
  HBLAS.Level1.axpyaxpy
  HBLAS.Level1.axpyaxpy'
  HBLAS.Level1.copy
  HBLAS.Level1.dot
  HBLAS.Level1.idamax
  HBLAS.Level1.idamin
  HBLAS.Level1.nrm2
  HBLAS.Level1.rot
  HBLAS.Level1.scal
  HBLAS.Level1.swap
module dependencies:
package dependencies: array-0.5.2.0 base-4.10.1.0 deepseq-1.4.3.0
                      ghc-prim-0.5.1.1 integer-gmp-1.0.1.0 primitive-0.6.3.0
                      transformers-0.5.2.0 vector-0.12.0.1
orphans: vector-0.12.0.1:Data.Vector.Unboxed
         vector-0.12.0.1:Data.Vector.Fusion.Bundle
         transformers-0.5.2.0:Control.Monad.Trans.Error
         base-4.10.1.0:GHC.Float base-4.10.1.0:GHC.Base
family instance modules: base-4.10.1.0:Control.Applicative
                         base-4.10.1.0:Data.Complex base-4.10.1.0:Data.Either
                         base-4.10.1.0:Data.Functor.Compose base-4.10.1.0:Data.Functor.Const
                         base-4.10.1.0:Data.Functor.Identity
                         base-4.10.1.0:Data.Functor.Product base-4.10.1.0:Data.Functor.Sum
                         base-4.10.1.0:Data.List.NonEmpty base-4.10.1.0:Data.Monoid
                         base-4.10.1.0:Data.Semigroup base-4.10.1.0:Data.Type.Equality
                         base-4.10.1.0:Data.Version base-4.10.1.0:Data.Void
                         base-4.10.1.0:GHC.Exts base-4.10.1.0:GHC.Generics
                         base-4.10.1.0:GHC.IO.Exception base-4.10.1.0:GHC.TypeLits
                         base-4.10.1.0:GHC.TypeNats
                         primitive-0.6.3.0:Control.Monad.Primitive
                         primitive-0.6.3.0:Data.Primitive.Array
                         primitive-0.6.3.0:Data.Primitive.ByteArray
                         vector-0.12.0.1:Data.Vector.Primitive
                         vector-0.12.0.1:Data.Vector.Unboxed
                         vector-0.12.0.1:Data.Vector.Unboxed.Base
import  -/  base-4.10.1.0:Control.Applicative 99577a9c463ffe4790a1d37547a345bd
import  -/  base-4.10.1.0:Data.Monoid c0108b166e27f747671c7fe4ffb11019
import  -/  base-4.10.1.0:GHC.Base 782fd99b5e36f3698a26179a49afca64
import  -/  base-4.10.1.0:GHC.Float 28e3bf9e258278ac8084e9cab43fd542
import  -/  base-4.10.1.0:GHC.Num 6e1dc5d36d99a802edb39b92bb1923b8
import  -/  base-4.10.1.0:Prelude 31945b7d0084063347fc52506d3a4020
import  -/  ghc-prim-0.5.1.1:GHC.Classes 93e2660065dce9329577e83d76d8f0d4
import  -/  vector-0.12.0.1:Data.Vector.Unboxed 479ef134bc2fb9694c4fd3a0ff5e0b8d
import  -/  vector-0.12.0.1:Data.Vector.Unboxed.Base a76f45e9ab7025ce49d09aaa12d53b96
addDependentFile "/Users/mamtajakter/.stack/programs/x86_64-osx/ghc-8.2.2/lib/ghc-8.2.2/include/ghcversion.h"
addDependentFile ".stack-work/dist/x86_64-osx/Cabal-2.0.1.0/build/autogen/cabal_macros.h"
2eeb708e44e6c4a7af869d9993e9e008
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   HBLAS.Level1.$trModule3
                   HBLAS.Level1.$trModule1) -}
c44253ee5427dc112e586e8776da3f23
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS HBLAS.Level1.$trModule2) -}
c371dde1ef740894add33616a3ad86a8
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("HBLAS.Level1"#) -}
e23c6a87076d249ec94fd9fd40d09c55
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS HBLAS.Level1.$trModule4) -}
a4c389d24fde62519a28ea844402d2c0
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("hblas-0.0.0.0-F71I6QhmeyVEy1DCNMIf5j"#) -}
1843f61b70e72a671d82a9a091330f1c
  asum ::
    (GHC.Num.Num n, Data.Vector.Unboxed.Base.Unbox n) =>
    Data.Vector.Unboxed.Base.Vector n -> n
  {- Arity: 3,
     Strictness: <S(LLLLLLC(S)),U(C(C1(U)),A,A,A,C(U),A,1*C1(U))><S(S(LLLC(S(S))LLLL)L),1*U(1*U(A,A,A,1*C1(U(1*U)),A,C(C1(C1(U))),A,A),A)><S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (3, False, False)
                (\ @ n
                   ($dNum :: GHC.Num.Num n)
                   ($dUnbox :: Data.Vector.Unboxed.Base.Unbox n)
                   (y :: Data.Vector.Unboxed.Base.Vector n) ->
                 case y of y1 { DEFAULT ->
                 (Data.Vector.Fusion.Bundle.Monadic.foldlM'
                    @ Data.Vector.Fusion.Util.Id
                    @ n
                    @ n
                    @ GHC.Types.Any
                    Data.Vector.Fusion.Util.$fMonadId
                    (\ (a1 :: n) (b1 :: n)[OneShot] ->
                     GHC.Num.+ @ n $dNum (GHC.Num.abs @ n $dNum b1) a1)
                      `cast`
                    (<n>_R ->_R <n>_R ->_R Sym (Data.Vector.Fusion.Util.N:Id[0] <n>_R))
                    (GHC.Num.fromInteger @ n $dNum 0)
                    (Data.Vector.Generic.streamR
                       @ Data.Vector.Unboxed.Base.Vector
                       @ n
                       @ GHC.Types.Any
                       (Data.Vector.Unboxed.Base.$p1Unbox @ n $dUnbox)
                       y1))
                   `cast`
                 (Data.Vector.Fusion.Util.N:Id[0] <n>_R) }) -}
7154468e31c1d74b95d07dcb4af71dbb
  axpy ::
    (GHC.Num.Num n, Data.Vector.Unboxed.Base.Unbox n) =>
    n
    -> Data.Vector.Unboxed.Base.Vector n
    -> Data.Vector.Unboxed.Base.Vector n
    -> Data.Vector.Unboxed.Base.Vector n
  {- Arity: 5,
     Strictness: <L,U(C(C1(U)),A,C(C1(U)),A,A,A,A)><S(S(S(LLLC(C(S))LLLLLLLLL)LLC(S)LLLL)L),1*U(1*U(1*U(A,C(C1(C1(U))),A,1*C1(C1(U)),A,A,A,C(C1(C1(C1(U)))),A,A,A,A,A),C(C1(U)),A,C(U(U)),A,C(C1(C1(U))),A,A),A)><S,1*U><S,1*U><S,1*U>,
     Inline: (sat-args=3),
     Unfolding: InlineRule (5, False, False)
                (\ @ n
                   ($dNum :: GHC.Num.Num n)
                   ($dUnbox :: Data.Vector.Unboxed.Base.Unbox n)
                   (alpha :: n)
                   (xs :: Data.Vector.Unboxed.Base.Vector n)
                   (ys :: Data.Vector.Unboxed.Base.Vector n) ->
                 case alpha of alpha1 { DEFAULT ->
                 case xs of xs1 { DEFAULT ->
                 case ys of ys1 { DEFAULT ->
                 let {
                   $dVector2 :: Data.Vector.Generic.Base.Vector
                                  Data.Vector.Unboxed.Base.Vector n
                   = Data.Vector.Unboxed.Base.$p1Unbox @ n $dUnbox
                 } in
                 Data.Vector.Generic.new
                   @ Data.Vector.Unboxed.Base.Vector
                   @ n
                   $dVector2
                   (Data.Vector.Generic.New.unstream
                      @ Data.Vector.Unboxed.Base.Vector
                      @ n
                      $dVector2
                      (Data.Vector.Fusion.Bundle.Monadic.zipWithM
                         @ Data.Vector.Fusion.Util.Id
                         @ n
                         @ n
                         @ n
                         @ Data.Vector.Unboxed.Base.Vector
                         Data.Vector.Fusion.Util.$fMonadId
                         (\ (a1 :: n) (b1 :: n)[OneShot] ->
                          GHC.Num.+ @ n $dNum b1 (GHC.Num.* @ n $dNum alpha1 a1))
                           `cast`
                         (<n>_R ->_R <n>_R ->_R Sym (Data.Vector.Fusion.Util.N:Id[0] <n>_R))
                         (Data.Vector.Generic.stream
                            @ Data.Vector.Unboxed.Base.Vector
                            @ n
                            (Data.Vector.Unboxed.Base.$p1Unbox @ n $dUnbox)
                            xs1)
                         (Data.Vector.Generic.stream
                            @ Data.Vector.Unboxed.Base.Vector
                            @ n
                            (Data.Vector.Unboxed.Base.$p1Unbox @ n $dUnbox)
                            ys1))) } } }) -}
0aae02d52619f47afc6fdf40c2f7a501
  axpy' ::
    (GHC.Num.Num n, Data.Vector.Unboxed.Base.Unbox n) =>
    n
    -> Data.Vector.Unboxed.Base.Vector n
    -> Data.Vector.Unboxed.Base.Vector n
    -> Data.Vector.Unboxed.Base.Vector n
    -> Data.Vector.Unboxed.Base.Vector n
  {- Arity: 6,
     Strictness: <S(LLLLLLC(S)),U(C(C1(U)),A,C(C1(U)),A,A,A,1*C1(U))><S(S(S(LLLC(C(S))LLLLLLLLL)LLC(S)LLLL)L),1*U(1*U(U(A,C(C1(C1(U))),A,C(C1(U)),A,A,A,C(C1(C1(C1(U)))),A,A,A,A,A),C(C1(U)),A,C(U(U)),A,C(C1(C1(U))),A,A),A)><S,1*U><S,1*U><S,1*U><S,1*U>,
     Inline: (sat-args=4),
     Unfolding: InlineRule (6, False, False)
                (\ @ n
                   ($dNum :: GHC.Num.Num n)
                   ($dUnbox :: Data.Vector.Unboxed.Base.Unbox n)
                   (alpha :: n)
                   (x :: Data.Vector.Unboxed.Base.Vector n)
                   (y :: Data.Vector.Unboxed.Base.Vector n)
                   (vec0 :: Data.Vector.Unboxed.Base.Vector n) ->
                 case alpha of alpha1 { DEFAULT ->
                 case x of x1 { DEFAULT ->
                 case y of y1 { DEFAULT ->
                 case vec0 of vec1 { DEFAULT ->
                 case GHC.Num.fromInteger @ n $dNum 1 of alpha2 { DEFAULT ->
                 let {
                   $dVector2 :: Data.Vector.Generic.Base.Vector
                                  Data.Vector.Unboxed.Base.Vector n
                   = Data.Vector.Unboxed.Base.$p1Unbox @ n $dUnbox
                 } in
                 case Data.Vector.Generic.new
                        @ Data.Vector.Unboxed.Base.Vector
                        @ n
                        $dVector2
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Unboxed.Base.Vector
                           @ n
                           $dVector2
                           (Data.Vector.Fusion.Bundle.Monadic.zipWithM
                              @ Data.Vector.Fusion.Util.Id
                              @ n
                              @ n
                              @ n
                              @ Data.Vector.Unboxed.Base.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              (\ (a1 :: n) (b1 :: n)[OneShot] ->
                               GHC.Num.+ @ n $dNum b1 (GHC.Num.* @ n $dNum alpha1 a1))
                                `cast`
                              (<n>_R ->_R <n>_R ->_R Sym (Data.Vector.Fusion.Util.N:Id[0] <n>_R))
                              (Data.Vector.Generic.stream
                                 @ Data.Vector.Unboxed.Base.Vector
                                 @ n
                                 (Data.Vector.Unboxed.Base.$p1Unbox @ n $dUnbox)
                                 x1)
                              (Data.Vector.Generic.stream
                                 @ Data.Vector.Unboxed.Base.Vector
                                 @ n
                                 (Data.Vector.Unboxed.Base.$p1Unbox @ n $dUnbox)
                                 vec1))) of xs { DEFAULT ->
                 let {
                   $dVector1 :: Data.Vector.Generic.Base.Vector
                                  Data.Vector.Unboxed.Base.Vector n
                   = Data.Vector.Unboxed.Base.$p1Unbox @ n $dUnbox
                 } in
                 Data.Vector.Generic.new
                   @ Data.Vector.Unboxed.Base.Vector
                   @ n
                   $dVector1
                   (Data.Vector.Generic.New.unstream
                      @ Data.Vector.Unboxed.Base.Vector
                      @ n
                      $dVector1
                      (Data.Vector.Fusion.Bundle.Monadic.zipWithM
                         @ Data.Vector.Fusion.Util.Id
                         @ n
                         @ n
                         @ n
                         @ Data.Vector.Unboxed.Base.Vector
                         Data.Vector.Fusion.Util.$fMonadId
                         (\ (a1 :: n) (b1 :: n)[OneShot] ->
                          GHC.Num.+ @ n $dNum b1 (GHC.Num.* @ n $dNum alpha2 a1))
                           `cast`
                         (<n>_R ->_R <n>_R ->_R Sym (Data.Vector.Fusion.Util.N:Id[0] <n>_R))
                         (Data.Vector.Generic.stream
                            @ Data.Vector.Unboxed.Base.Vector
                            @ n
                            (Data.Vector.Unboxed.Base.$p1Unbox @ n $dUnbox)
                            xs)
                         (Data.Vector.Generic.stream
                            @ Data.Vector.Unboxed.Base.Vector
                            @ n
                            (Data.Vector.Unboxed.Base.$p1Unbox @ n $dUnbox)
                            y1))) } } } } } }) -}
7919945a92187c6eeb8a0bbe265b38cd
  axpyaxpy ::
    (GHC.Num.Num n, Data.Vector.Unboxed.Base.Unbox n) =>
    n
    -> n
    -> Data.Vector.Unboxed.Base.Vector n
    -> Data.Vector.Unboxed.Base.Vector n
    -> Data.Vector.Unboxed.Base.Vector n
  {- Arity: 6,
     Strictness: <L,U(C(C1(U)),A,C(C1(U)),A,A,A,A)><S(S(S(LLLC(C(S))LLLLLLLLL)LLC(S)LLLL)L),1*U(1*U(U(A,C(C1(C1(U))),A,C(C1(U)),A,A,A,C(C1(C1(C1(U)))),A,A,A,A,A),C(C1(U)),A,C(U(U)),A,C(C1(C1(U))),A,A),A)><S,1*U><S,1*U><S,1*U><S,1*U>,
     Inline: (sat-args=4),
     Unfolding: InlineRule (6, False, False)
                (\ @ n
                   ($dNum :: GHC.Num.Num n)
                   ($dUnbox :: Data.Vector.Unboxed.Base.Unbox n)
                   (a1 :: n)
                   (a2 :: n)
                   (x :: Data.Vector.Unboxed.Base.Vector n)
                   (y :: Data.Vector.Unboxed.Base.Vector n) ->
                 case a1 of a4 { DEFAULT ->
                 case a2 of a5 { DEFAULT ->
                 case x of x1 { DEFAULT ->
                 case y of y1 { DEFAULT ->
                 let {
                   $dVector2 :: Data.Vector.Generic.Base.Vector
                                  Data.Vector.Unboxed.Base.Vector n
                   = Data.Vector.Unboxed.Base.$p1Unbox @ n $dUnbox
                 } in
                 case Data.Vector.Generic.new
                        @ Data.Vector.Unboxed.Base.Vector
                        @ n
                        $dVector2
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Unboxed.Base.Vector
                           @ n
                           $dVector2
                           (Data.Vector.Fusion.Bundle.Monadic.zipWithM
                              @ Data.Vector.Fusion.Util.Id
                              @ n
                              @ n
                              @ n
                              @ Data.Vector.Unboxed.Base.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              (\ (a6 :: n) (b1 :: n)[OneShot] ->
                               GHC.Num.+ @ n $dNum b1 (GHC.Num.* @ n $dNum a4 a6))
                                `cast`
                              (<n>_R ->_R <n>_R ->_R Sym (Data.Vector.Fusion.Util.N:Id[0] <n>_R))
                              (Data.Vector.Generic.stream
                                 @ Data.Vector.Unboxed.Base.Vector
                                 @ n
                                 (Data.Vector.Unboxed.Base.$p1Unbox @ n $dUnbox)
                                 x1)
                              (Data.Vector.Generic.stream
                                 @ Data.Vector.Unboxed.Base.Vector
                                 @ n
                                 (Data.Vector.Unboxed.Base.$p1Unbox @ n $dUnbox)
                                 y1))) of t1 { DEFAULT ->
                 let {
                   $dVector1 :: Data.Vector.Generic.Base.Vector
                                  Data.Vector.Unboxed.Base.Vector n
                   = Data.Vector.Unboxed.Base.$p1Unbox @ n $dUnbox
                 } in
                 Data.Vector.Generic.new
                   @ Data.Vector.Unboxed.Base.Vector
                   @ n
                   $dVector1
                   (Data.Vector.Generic.New.unstream
                      @ Data.Vector.Unboxed.Base.Vector
                      @ n
                      $dVector1
                      (Data.Vector.Fusion.Bundle.Monadic.zipWithM
                         @ Data.Vector.Fusion.Util.Id
                         @ n
                         @ n
                         @ n
                         @ Data.Vector.Unboxed.Base.Vector
                         Data.Vector.Fusion.Util.$fMonadId
                         (\ (a6 :: n) (b1 :: n)[OneShot] ->
                          GHC.Num.+ @ n $dNum b1 (GHC.Num.* @ n $dNum a5 a6))
                           `cast`
                         (<n>_R ->_R <n>_R ->_R Sym (Data.Vector.Fusion.Util.N:Id[0] <n>_R))
                         (Data.Vector.Generic.stream
                            @ Data.Vector.Unboxed.Base.Vector
                            @ n
                            (Data.Vector.Unboxed.Base.$p1Unbox @ n $dUnbox)
                            t1)
                         (Data.Vector.Generic.stream
                            @ Data.Vector.Unboxed.Base.Vector
                            @ n
                            (Data.Vector.Unboxed.Base.$p1Unbox @ n $dUnbox)
                            x1))) } } } } }) -}
fa806dd139d1e00279f4499de7b49c59
  axpyaxpy' ::
    (GHC.Num.Num n, Data.Vector.Unboxed.Base.Unbox n) =>
    n
    -> n
    -> Data.Vector.Unboxed.Base.Vector n
    -> Data.Vector.Unboxed.Base.Vector n
    -> Data.Vector.Unboxed.Base.Vector n
    -> Data.Vector.Unboxed.Base.Vector n
  {- Arity: 7,
     Strictness: <L,U(C(C1(U)),A,C(C1(U)),A,A,A,A)><S(S(S(LLLC(C(S))LLLLLLLLL)LLC(S)LLLL)L),1*U(1*U(U(A,C(C1(C1(U))),A,C(C1(U)),A,A,A,C(C1(C1(C1(U)))),A,A,A,A,A),C(C1(U)),A,C(U(U)),A,C(C1(C1(U))),A,A),A)><S,1*U><S,1*U><S,1*U><S,1*U><S,1*U>,
     Inline: (sat-args=5),
     Unfolding: InlineRule (7, False, False)
                (\ @ n
                   ($dNum :: GHC.Num.Num n)
                   ($dUnbox :: Data.Vector.Unboxed.Base.Unbox n)
                   (a :: n)
                   (b :: n)
                   (x :: Data.Vector.Unboxed.Base.Vector n)
                   (y :: Data.Vector.Unboxed.Base.Vector n)
                   (z :: Data.Vector.Unboxed.Base.Vector n) ->
                 case a of a1 { DEFAULT ->
                 case b of b1 { DEFAULT ->
                 case x of x1 { DEFAULT ->
                 case y of y1 { DEFAULT ->
                 case z of z1 { DEFAULT ->
                 let {
                   $dVector2 :: Data.Vector.Generic.Base.Vector
                                  Data.Vector.Unboxed.Base.Vector n
                   = Data.Vector.Unboxed.Base.$p1Unbox @ n $dUnbox
                 } in
                 case Data.Vector.Generic.new
                        @ Data.Vector.Unboxed.Base.Vector
                        @ n
                        $dVector2
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Unboxed.Base.Vector
                           @ n
                           $dVector2
                           (Data.Vector.Fusion.Bundle.Monadic.zipWithM
                              @ Data.Vector.Fusion.Util.Id
                              @ n
                              @ n
                              @ n
                              @ Data.Vector.Unboxed.Base.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              (\ (a2 :: n) (b2 :: n)[OneShot] ->
                               GHC.Num.+ @ n $dNum b2 (GHC.Num.* @ n $dNum a1 a2))
                                `cast`
                              (<n>_R ->_R <n>_R ->_R Sym (Data.Vector.Fusion.Util.N:Id[0] <n>_R))
                              (Data.Vector.Generic.stream
                                 @ Data.Vector.Unboxed.Base.Vector
                                 @ n
                                 (Data.Vector.Unboxed.Base.$p1Unbox @ n $dUnbox)
                                 x1)
                              (Data.Vector.Generic.stream
                                 @ Data.Vector.Unboxed.Base.Vector
                                 @ n
                                 (Data.Vector.Unboxed.Base.$p1Unbox @ n $dUnbox)
                                 y1))) of t { DEFAULT ->
                 let {
                   $dVector1 :: Data.Vector.Generic.Base.Vector
                                  Data.Vector.Unboxed.Base.Vector n
                   = Data.Vector.Unboxed.Base.$p1Unbox @ n $dUnbox
                 } in
                 Data.Vector.Generic.new
                   @ Data.Vector.Unboxed.Base.Vector
                   @ n
                   $dVector1
                   (Data.Vector.Generic.New.unstream
                      @ Data.Vector.Unboxed.Base.Vector
                      @ n
                      $dVector1
                      (Data.Vector.Fusion.Bundle.Monadic.zipWithM
                         @ Data.Vector.Fusion.Util.Id
                         @ n
                         @ n
                         @ n
                         @ Data.Vector.Unboxed.Base.Vector
                         Data.Vector.Fusion.Util.$fMonadId
                         (\ (a2 :: n) (b2 :: n)[OneShot] ->
                          GHC.Num.+ @ n $dNum b2 (GHC.Num.* @ n $dNum b1 a2))
                           `cast`
                         (<n>_R ->_R <n>_R ->_R Sym (Data.Vector.Fusion.Util.N:Id[0] <n>_R))
                         (Data.Vector.Generic.stream
                            @ Data.Vector.Unboxed.Base.Vector
                            @ n
                            (Data.Vector.Unboxed.Base.$p1Unbox @ n $dUnbox)
                            t)
                         (Data.Vector.Generic.stream
                            @ Data.Vector.Unboxed.Base.Vector
                            @ n
                            (Data.Vector.Unboxed.Base.$p1Unbox @ n $dUnbox)
                            z1))) } } } } } }) -}
69553b57e97b7d8fcb44f637046962d1
  copy ::
    (GHC.Classes.Eq n, GHC.Num.Num n,
     Data.Vector.Unboxed.Base.Unbox n) =>
    Data.Vector.Unboxed.Base.Vector n
    -> Data.Vector.Unboxed.Base.Vector n
    -> Data.Vector.Unboxed.Base.Vector n
  {- Arity: 5, HasNoCafRefs, Strictness: <L,A><L,A><L,A><S,1*U><L,A>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (5, False, True)
                (\ @ n
                   ($dEq :: GHC.Classes.Eq n)
                   ($dNum :: GHC.Num.Num n)
                   ($dUnbox :: Data.Vector.Unboxed.Base.Unbox n)
                   (xs :: Data.Vector.Unboxed.Base.Vector n)
                   (ds :: Data.Vector.Unboxed.Base.Vector n) ->
                 xs) -}
9b41a3c8a376aa783e9ab8a2b9c4177d
  dot ::
    (GHC.Num.Num n, Data.Vector.Unboxed.Base.Unbox n) =>
    Data.Vector.Unboxed.Base.Vector n
    -> Data.Vector.Unboxed.Base.Vector n -> n
  {- Arity: 4,
     Strictness: <S(LLLLLLC(S)),U(C(C1(U)),A,C(C1(U)),A,A,A,1*C1(U))><S(S(LLLC(S(S))LLLL)L),1*U(1*U(A,A,A,C(U(U)),A,C(C1(C1(U))),A,A),A)><S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (4, False, False)
                (\ @ n
                   ($dNum :: GHC.Num.Num n)
                   ($dUnbox :: Data.Vector.Unboxed.Base.Unbox n)
                   (a :: Data.Vector.Unboxed.Base.Vector n)
                   (b :: Data.Vector.Unboxed.Base.Vector n) ->
                 case a of a1 { DEFAULT ->
                 case b of b1 { DEFAULT ->
                 let {
                   f :: n -> n -> n = GHC.Num.+ @ n $dNum
                 } in
                 let {
                   f1 :: n -> n -> n = GHC.Num.* @ n $dNum
                 } in
                 (Data.Vector.Fusion.Bundle.Monadic.foldlM'
                    @ Data.Vector.Fusion.Util.Id
                    @ n
                    @ n
                    @ Data.Vector.Unboxed.Base.Vector
                    Data.Vector.Fusion.Util.$fMonadId
                    (\ (a2 :: n) (b2 :: n)[OneShot] -> f a2 b2)
                      `cast`
                    (<n>_R ->_R <n>_R ->_R Sym (Data.Vector.Fusion.Util.N:Id[0] <n>_R))
                    (GHC.Num.fromInteger @ n $dNum 0)
                    (Data.Vector.Fusion.Bundle.Monadic.zipWithM
                       @ Data.Vector.Fusion.Util.Id
                       @ n
                       @ n
                       @ n
                       @ Data.Vector.Unboxed.Base.Vector
                       Data.Vector.Fusion.Util.$fMonadId
                       (\ (a2 :: n) (b2 :: n)[OneShot] -> f1 a2 b2)
                         `cast`
                       (<n>_R ->_R <n>_R ->_R Sym (Data.Vector.Fusion.Util.N:Id[0] <n>_R))
                       (Data.Vector.Generic.stream
                          @ Data.Vector.Unboxed.Base.Vector
                          @ n
                          (Data.Vector.Unboxed.Base.$p1Unbox @ n $dUnbox)
                          a1)
                       (Data.Vector.Generic.stream
                          @ Data.Vector.Unboxed.Base.Vector
                          @ n
                          (Data.Vector.Unboxed.Base.$p1Unbox @ n $dUnbox)
                          b1)))
                   `cast`
                 (Data.Vector.Fusion.Util.N:Id[0] <n>_R) } }) -}
c25910ca61ca73937ef7599cad5c21cc
  idamax ::
    (GHC.Num.Num n, GHC.Classes.Ord n,
     Data.Vector.Unboxed.Base.Unbox n) =>
    Data.Vector.Unboxed.Base.Vector n -> GHC.Base.Maybe GHC.Types.Int
  {- Arity: 4,
     Strictness: <L,U(A,A,A,A,C(U),A,A)><L,U(1*U(1*C1(C(U)),A),A,A,A,A,A,C(C1(U)),A)><S(S(LLLC(S(S))LLLL)L),1*U(1*U(A,A,A,1*C1(U(U)),A,C(C1(C1(U))),A,A),A)><S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (4, False, False)
                (\ @ n
                   ($dNum :: GHC.Num.Num n)
                   ($dOrd :: GHC.Classes.Ord n)
                   ($dUnbox :: Data.Vector.Unboxed.Base.Unbox n) ->
                 let {
                   $dEq :: GHC.Classes.Eq n = GHC.Classes.$p1Ord @ n $dOrd
                 } in
                 \ (a :: Data.Vector.Unboxed.Base.Vector n) ->
                 case a of a1 { DEFAULT ->
                 (Data.Vector.Fusion.Bundle.Monadic.findIndex
                    @ Data.Vector.Fusion.Util.Id
                    @ n
                    @ Data.Vector.Unboxed.Base.Vector
                    Data.Vector.Fusion.Util.$fMonadId
                    (GHC.Classes.==
                       @ n
                       $dEq
                       (let {
                          f :: n -> n -> n = GHC.Classes.max @ n $dOrd
                        } in
                        (Data.Vector.Fusion.Bundle.Monadic.foldl1M'
                           @ Data.Vector.Fusion.Util.Id
                           @ n
                           @ Data.Vector.Unboxed.Base.Vector
                           Data.Vector.Fusion.Util.$fMonadId
                           (\ (a2 :: n) (b :: n)[OneShot] -> f a2 b)
                             `cast`
                           (<n>_R ->_R <n>_R ->_R Sym (Data.Vector.Fusion.Util.N:Id[0] <n>_R))
                           (Data.Vector.Fusion.Bundle.inplace
                              @ n
                              @ n
                              @ Data.Vector.Unboxed.Base.Vector
                              (\ @ m :: * -> * ($dMonad :: GHC.Base.Monad m)[OneShot] ->
                               let {
                                 f1 :: n -> n = GHC.Num.abs @ n $dNum
                               } in
                               Data.Vector.Fusion.Stream.Monadic.mapM
                                 @ m
                                 @ n
                                 @ n
                                 $dMonad
                                 (let {
                                    f2 :: n -> m n = GHC.Base.return @ m $dMonad @ n
                                  } in
                                  \ (x :: n) -> f2 (f1 x)))
                              (GHC.Base.id @ Data.Vector.Fusion.Bundle.Size.Size)
                              (Data.Vector.Generic.stream
                                 @ Data.Vector.Unboxed.Base.Vector
                                 @ n
                                 (Data.Vector.Unboxed.Base.$p1Unbox @ n $dUnbox)
                                 a1)))
                          `cast`
                        (Data.Vector.Fusion.Util.N:Id[0] <n>_R)))
                    (Data.Vector.Fusion.Bundle.inplace
                       @ n
                       @ n
                       @ Data.Vector.Unboxed.Base.Vector
                       (\ @ m :: * -> * ($dMonad :: GHC.Base.Monad m)[OneShot] ->
                        let {
                          f :: n -> n = GHC.Num.abs @ n $dNum
                        } in
                        Data.Vector.Fusion.Stream.Monadic.mapM
                          @ m
                          @ n
                          @ n
                          $dMonad
                          (let {
                             f1 :: n -> m n = GHC.Base.return @ m $dMonad @ n
                           } in
                           \ (x :: n) -> f1 (f x)))
                       (GHC.Base.id @ Data.Vector.Fusion.Bundle.Size.Size)
                       (Data.Vector.Generic.stream
                          @ Data.Vector.Unboxed.Base.Vector
                          @ n
                          (Data.Vector.Unboxed.Base.$p1Unbox @ n $dUnbox)
                          a1)))
                   `cast`
                 (Data.Vector.Fusion.Util.N:Id[0]
                      <GHC.Base.Maybe GHC.Types.Int>_R) }) -}
920fd46cc89e0fac3ced16e523e4c16c
  idamin ::
    (GHC.Num.Num n, GHC.Classes.Ord n,
     Data.Vector.Unboxed.Base.Unbox n) =>
    Data.Vector.Unboxed.Base.Vector n -> GHC.Base.Maybe GHC.Types.Int
  {- Arity: 4,
     Strictness: <L,U(A,A,A,A,C(U),A,A)><L,U(1*U(1*C1(C(U)),A),A,A,A,A,A,A,C(C1(U)))><S(S(LLLC(S(S))LLLL)L),1*U(1*U(A,A,A,1*C1(U(U)),A,C(C1(C1(U))),A,A),A)><S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (4, False, False)
                (\ @ n
                   ($dNum :: GHC.Num.Num n)
                   ($dOrd :: GHC.Classes.Ord n)
                   ($dUnbox :: Data.Vector.Unboxed.Base.Unbox n) ->
                 let {
                   $dEq :: GHC.Classes.Eq n = GHC.Classes.$p1Ord @ n $dOrd
                 } in
                 \ (a :: Data.Vector.Unboxed.Base.Vector n) ->
                 case a of a1 { DEFAULT ->
                 (Data.Vector.Fusion.Bundle.Monadic.findIndex
                    @ Data.Vector.Fusion.Util.Id
                    @ n
                    @ Data.Vector.Unboxed.Base.Vector
                    Data.Vector.Fusion.Util.$fMonadId
                    (GHC.Classes.==
                       @ n
                       $dEq
                       (let {
                          f :: n -> n -> n = GHC.Classes.min @ n $dOrd
                        } in
                        (Data.Vector.Fusion.Bundle.Monadic.foldl1M'
                           @ Data.Vector.Fusion.Util.Id
                           @ n
                           @ Data.Vector.Unboxed.Base.Vector
                           Data.Vector.Fusion.Util.$fMonadId
                           (\ (a2 :: n) (b :: n)[OneShot] -> f a2 b)
                             `cast`
                           (<n>_R ->_R <n>_R ->_R Sym (Data.Vector.Fusion.Util.N:Id[0] <n>_R))
                           (Data.Vector.Fusion.Bundle.inplace
                              @ n
                              @ n
                              @ Data.Vector.Unboxed.Base.Vector
                              (\ @ m :: * -> * ($dMonad :: GHC.Base.Monad m)[OneShot] ->
                               let {
                                 f1 :: n -> n = GHC.Num.abs @ n $dNum
                               } in
                               Data.Vector.Fusion.Stream.Monadic.mapM
                                 @ m
                                 @ n
                                 @ n
                                 $dMonad
                                 (let {
                                    f2 :: n -> m n = GHC.Base.return @ m $dMonad @ n
                                  } in
                                  \ (x :: n) -> f2 (f1 x)))
                              (GHC.Base.id @ Data.Vector.Fusion.Bundle.Size.Size)
                              (Data.Vector.Generic.stream
                                 @ Data.Vector.Unboxed.Base.Vector
                                 @ n
                                 (Data.Vector.Unboxed.Base.$p1Unbox @ n $dUnbox)
                                 a1)))
                          `cast`
                        (Data.Vector.Fusion.Util.N:Id[0] <n>_R)))
                    (Data.Vector.Fusion.Bundle.inplace
                       @ n
                       @ n
                       @ Data.Vector.Unboxed.Base.Vector
                       (\ @ m :: * -> * ($dMonad :: GHC.Base.Monad m)[OneShot] ->
                        let {
                          f :: n -> n = GHC.Num.abs @ n $dNum
                        } in
                        Data.Vector.Fusion.Stream.Monadic.mapM
                          @ m
                          @ n
                          @ n
                          $dMonad
                          (let {
                             f1 :: n -> m n = GHC.Base.return @ m $dMonad @ n
                           } in
                           \ (x :: n) -> f1 (f x)))
                       (GHC.Base.id @ Data.Vector.Fusion.Bundle.Size.Size)
                       (Data.Vector.Generic.stream
                          @ Data.Vector.Unboxed.Base.Vector
                          @ n
                          (Data.Vector.Unboxed.Base.$p1Unbox @ n $dUnbox)
                          a1)))
                   `cast`
                 (Data.Vector.Fusion.Util.N:Id[0]
                      <GHC.Base.Maybe GHC.Types.Int>_R) }) -}
aa68cdfe2dfe7e291a6901d72a8690d7
  nrm2 ::
    (GHC.Num.Num n, GHC.Float.Floating n,
     Data.Vector.Unboxed.Base.Unbox n) =>
    Data.Vector.Unboxed.Base.Vector n -> n
  {- Arity: 3,
     Strictness: <L,A><L,U(1*U(1*U(C(C1(U)),A,C(C1(U)),A,A,A,1*C1(U)),A,A,A),A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*U(A,A,A,C(U(U)),A,C(C1(C1(U))),A,A),A)>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (3, False, False)
                (\ @ n
                   ($dNum :: GHC.Num.Num n)
                   ($dFloating :: GHC.Float.Floating n)
                   ($dUnbox :: Data.Vector.Unboxed.Base.Unbox n) ->
                 let {
                   $dFractional :: GHC.Real.Fractional n
                   = GHC.Float.$p1Floating @ n $dFloating
                 } in
                 let {
                   $dNum1 :: GHC.Num.Num n = GHC.Real.$p1Fractional @ n $dFractional
                 } in
                 let {
                   f :: n -> n = GHC.Float.sqrt @ n $dFloating
                 } in
                 let {
                   f1 :: n -> n -> n = GHC.Num.+ @ n $dNum1
                 } in
                 let {
                   z :: n = GHC.Num.fromInteger @ n $dNum1 0
                 } in
                 let {
                   g :: n -> n -> n {- Arity: 2 -} = \ (a1 :: n) (b1 :: n) -> f1 a1 b1
                 } in
                 let {
                   $dVector :: Data.Vector.Generic.Base.Vector
                                 Data.Vector.Unboxed.Base.Vector n
                   = Data.Vector.Unboxed.Base.$p1Unbox @ n $dUnbox
                 } in
                 let {
                   f2 :: forall (m :: * -> *).
                         GHC.Base.Monad m =>
                         Data.Vector.Fusion.Stream.Monadic.Stream m n
                         -> Data.Vector.Fusion.Stream.Monadic.Stream m n
                     {- Arity: 1 -}
                   = \ @ m :: * -> * ($dMonad :: GHC.Base.Monad m) ->
                     Data.Vector.Fusion.Stream.Monadic.mapM
                       @ m
                       @ n
                       @ n
                       $dMonad
                       (let {
                          f3 :: n -> m n = GHC.Base.return @ m $dMonad @ n
                        } in
                        \ (x :: n) -> f3 (GHC.Num.* @ n $dNum1 x x))
                 } in
                 \ (x :: Data.Vector.Unboxed.Base.Vector n) ->
                 f (Data.Vector.Fusion.Bundle.Monadic.foldlM'
                      @ Data.Vector.Fusion.Util.Id
                      @ n
                      @ n
                      @ Data.Vector.Unboxed.Base.Vector
                      Data.Vector.Fusion.Util.$fMonadId
                      g `cast`
                      (<n>_R ->_R <n>_R ->_R Sym (Data.Vector.Fusion.Util.N:Id[0] <n>_R))
                      z
                      (Data.Vector.Fusion.Bundle.inplace
                         @ n
                         @ n
                         @ Data.Vector.Unboxed.Base.Vector
                         f2
                         (GHC.Base.id @ Data.Vector.Fusion.Bundle.Size.Size)
                         (Data.Vector.Generic.stream
                            @ Data.Vector.Unboxed.Base.Vector
                            @ n
                            $dVector
                            x)))
                     `cast`
                   (Data.Vector.Fusion.Util.N:Id[0] <n>_R)) -}
009a1d1f4b8715da3da1dd79a97ecd0b
  rot ::
    (GHC.Float.Floating n, GHC.Classes.Eq n, GHC.Num.Num n,
     Data.Vector.Unboxed.Base.Unbox n) =>
    Data.Vector.Unboxed.Base.Vector n
    -> Data.Vector.Unboxed.Base.Vector n
    -> n
    -> (Data.Vector.Unboxed.Base.Vector n,
        Data.Vector.Unboxed.Base.Vector n)
  {- Arity: 7,
     Strictness: <L,U(1*U(1*U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,C(U)),A,A,A),A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,A><L,U(U(U(A,C(C1(C1(U))),A,C(C1(U)),A,A,A,C(C1(C1(C1(U)))),A,A,A,A,A),C(C1(U)),A,C(U(U)),A,C(C1(C1(U))),A,A),A)><S,1*U><S,1*U><S,1*U>m,
     Inline: (sat-args=3),
     Unfolding: InlineRule (7, False, False)
                (\ @ n
                   ($dFloating :: GHC.Float.Floating n)
                   ($dEq :: GHC.Classes.Eq n)
                   ($dNum :: GHC.Num.Num n)
                   ($dUnbox :: Data.Vector.Unboxed.Base.Unbox n) ->
                 let {
                   $dFractional :: GHC.Real.Fractional n
                   = GHC.Float.$p1Floating @ n $dFloating
                 } in
                 let {
                   $dNum1 :: GHC.Num.Num n = GHC.Real.$p1Fractional @ n $dFractional
                 } in
                 \ (x :: Data.Vector.Unboxed.Base.Vector n)
                   (y :: Data.Vector.Unboxed.Base.Vector n)
                   (c :: n) ->
                 case x of x1 { DEFAULT ->
                 case y of y1 { DEFAULT ->
                 case c of c1 { DEFAULT ->
                 case GHC.Classes.==
                        @ n
                        $dEq
                        c1
                        (GHC.Num.fromInteger @ n $dNum1 1) of wild {
                   GHC.Types.False
                   -> case GHC.Num.*
                             @ n
                             $dNum1
                             (GHC.Float.sqrt @ n $dFloating (GHC.Num.fromInteger @ n $dNum1 3))
                             c1 of s { DEFAULT ->
                      (let {
                         $dVector2 :: Data.Vector.Generic.Base.Vector
                                        Data.Vector.Unboxed.Base.Vector n
                         = Data.Vector.Unboxed.Base.$p1Unbox @ n $dUnbox
                       } in
                       Data.Vector.Generic.new
                         @ Data.Vector.Unboxed.Base.Vector
                         @ n
                         $dVector2
                         (Data.Vector.Generic.New.unstream
                            @ Data.Vector.Unboxed.Base.Vector
                            @ n
                            $dVector2
                            (Data.Vector.Fusion.Bundle.Monadic.zipWithM
                               @ Data.Vector.Fusion.Util.Id
                               @ n
                               @ n
                               @ n
                               @ Data.Vector.Unboxed.Base.Vector
                               Data.Vector.Fusion.Util.$fMonadId
                               (\ (a1 :: n) (b1 :: n)[OneShot] ->
                                GHC.Num.+
                                  @ n
                                  $dNum1
                                  (GHC.Num.* @ n $dNum1 c1 a1)
                                  (GHC.Num.* @ n $dNum1 s b1))
                                 `cast`
                               (<n>_R ->_R <n>_R ->_R Sym (Data.Vector.Fusion.Util.N:Id[0] <n>_R))
                               (Data.Vector.Generic.stream
                                  @ Data.Vector.Unboxed.Base.Vector
                                  @ n
                                  (Data.Vector.Unboxed.Base.$p1Unbox @ n $dUnbox)
                                  x1)
                               (Data.Vector.Generic.stream
                                  @ Data.Vector.Unboxed.Base.Vector
                                  @ n
                                  (Data.Vector.Unboxed.Base.$p1Unbox @ n $dUnbox)
                                  y1))),
                       let {
                         $dVector2 :: Data.Vector.Generic.Base.Vector
                                        Data.Vector.Unboxed.Base.Vector n
                         = Data.Vector.Unboxed.Base.$p1Unbox @ n $dUnbox
                       } in
                       Data.Vector.Generic.new
                         @ Data.Vector.Unboxed.Base.Vector
                         @ n
                         $dVector2
                         (Data.Vector.Generic.New.unstream
                            @ Data.Vector.Unboxed.Base.Vector
                            @ n
                            $dVector2
                            (Data.Vector.Fusion.Bundle.Monadic.zipWithM
                               @ Data.Vector.Fusion.Util.Id
                               @ n
                               @ n
                               @ n
                               @ Data.Vector.Unboxed.Base.Vector
                               Data.Vector.Fusion.Util.$fMonadId
                               (\ (a1 :: n) (b1 :: n)[OneShot] ->
                                GHC.Num.-
                                  @ n
                                  $dNum1
                                  (GHC.Num.* @ n $dNum1 c1 b1)
                                  (GHC.Num.* @ n $dNum1 s a1))
                                 `cast`
                               (<n>_R ->_R <n>_R ->_R Sym (Data.Vector.Fusion.Util.N:Id[0] <n>_R))
                               (Data.Vector.Generic.stream
                                  @ Data.Vector.Unboxed.Base.Vector
                                  @ n
                                  (Data.Vector.Unboxed.Base.$p1Unbox @ n $dUnbox)
                                  x1)
                               (Data.Vector.Generic.stream
                                  @ Data.Vector.Unboxed.Base.Vector
                                  @ n
                                  (Data.Vector.Unboxed.Base.$p1Unbox @ n $dUnbox)
                                  y1)))) }
                   GHC.Types.True -> (x1, y1) } } } }) -}
42a4cb86f6aee67e32d2cbfaa3db650e
  scal ::
    (GHC.Num.Num n, Data.Vector.Unboxed.Base.Unbox n) =>
    n
    -> Data.Vector.Unboxed.Base.Vector n
    -> Data.Vector.Unboxed.Base.Vector n
  {- Arity: 4,
     Strictness: <L,1*U(A,A,1*C1(C(U)),A,A,A,A)><S(S(S(LLLC(C(S))LLLLLLLLL)LLC(S)LLLL)L),1*U(1*U(1*U(A,C(C1(C1(U))),A,1*C1(C1(U)),A,A,A,C(C1(C1(C1(U)))),A,A,A,A,A),C(C1(U)),A,1*C1(U(U)),A,C(C1(C1(U))),A,A),A)><S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (4, False, False)
                (\ @ n
                   ($dNum :: GHC.Num.Num n)
                   ($dUnbox :: Data.Vector.Unboxed.Base.Unbox n)
                   (alpha :: n)
                   (x :: Data.Vector.Unboxed.Base.Vector n) ->
                 case alpha of alpha1 { DEFAULT ->
                 case x of x1 { DEFAULT ->
                 let {
                   $dVector1 :: Data.Vector.Generic.Base.Vector
                                  Data.Vector.Unboxed.Base.Vector n
                   = Data.Vector.Unboxed.Base.$p1Unbox @ n $dUnbox
                 } in
                 Data.Vector.Generic.new
                   @ Data.Vector.Unboxed.Base.Vector
                   @ n
                   $dVector1
                   (Data.Vector.Generic.New.unstream
                      @ Data.Vector.Unboxed.Base.Vector
                      @ n
                      $dVector1
                      (Data.Vector.Fusion.Bundle.inplace
                         @ n
                         @ n
                         @ Data.Vector.Unboxed.Base.Vector
                         (\ @ m :: * -> * ($dMonad :: GHC.Base.Monad m)[OneShot] ->
                          let {
                            f :: n -> n = GHC.Num.* @ n $dNum alpha1
                          } in
                          Data.Vector.Fusion.Stream.Monadic.mapM
                            @ m
                            @ n
                            @ n
                            $dMonad
                            (let {
                               f1 :: n -> m n = GHC.Base.return @ m $dMonad @ n
                             } in
                             \ (x2 :: n) -> f1 (f x2)))
                         (GHC.Base.id @ Data.Vector.Fusion.Bundle.Size.Size)
                         (Data.Vector.Generic.stream
                            @ Data.Vector.Unboxed.Base.Vector
                            @ n
                            (Data.Vector.Unboxed.Base.$p1Unbox @ n $dUnbox)
                            x1))) } }) -}
4b32c12555640ef064a4a6bac28eaab7
  swap :: (a, b) -> (b, a)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,U)>m,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a @ b (ds :: (a, b)) ->
                 case ds of wild { (,) x y -> (y, x) }) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

