Resolving dependencies...
Build profile: -w ghc-8.6.4 -O1
In order, the following will be built (use -v for more details):
 - hblas-0.0.0.0 (lib) (first run)
 - hblas-0.0.0.0 (test:cg) (first run)
Configuring library for hblas-0.0.0.0..
Preprocessing library for hblas-0.0.0.0..
Building library for hblas-0.0.0.0..
[1 of 5] Compiling HBLAS.Class      ( haskell/HBLAS/Class.hs, /Users/mamtajakter/Documents/drpproject/hblas/dist-newstyle/build/x86_64-osx/ghc-8.6.4/hblas-0.0.0.0/build/HBLAS/Class.o )
[2 of 5] Compiling HBLAS.IO.List    ( haskell/HBLAS/IO/List.hs, /Users/mamtajakter/Documents/drpproject/hblas/dist-newstyle/build/x86_64-osx/ghc-8.6.4/hblas-0.0.0.0/build/HBLAS/IO/List.o )
[3 of 5] Compiling HBLAS.IO.Vector  ( haskell/HBLAS/IO/Vector.hs, /Users/mamtajakter/Documents/drpproject/hblas/dist-newstyle/build/x86_64-osx/ghc-8.6.4/hblas-0.0.0.0/build/HBLAS/IO/Vector.o )
[4 of 5] Compiling HBLAS.Level1     ( haskell/HBLAS/Level1.hs, /Users/mamtajakter/Documents/drpproject/hblas/dist-newstyle/build/x86_64-osx/ghc-8.6.4/hblas-0.0.0.0/build/HBLAS/Level1.o )
[5 of 5] Compiling HBLAS.Level2     ( haskell/HBLAS/Level2.hs, /Users/mamtajakter/Documents/drpproject/hblas/dist-newstyle/build/x86_64-osx/ghc-8.6.4/hblas-0.0.0.0/build/HBLAS/Level2.o )
Configuring test suite 'cg' for hblas-0.0.0.0..
Preprocessing test suite 'cg' for hblas-0.0.0.0..
Building test suite 'cg' for hblas-0.0.0.0..
[1 of 1] Compiling Main             ( examples/cgm.hs, /Users/mamtajakter/Documents/drpproject/hblas/dist-newstyle/build/x86_64-osx/ghc-8.6.4/hblas-0.0.0.0/t/cg/build/cg/cg-tmp/Main.o )

==================== LLVM Code ====================
target datalayout = "e-m:o-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-apple-darwin"



==================== LLVM Code ====================
declare ccc i8* @memcpy$def(i8*, i8*, i64)



==================== LLVM Code ====================
declare ccc i8* @memmove$def(i8*, i8*, i64)



==================== LLVM Code ====================
declare ccc i8* @memset$def(i8*, i64, i64)



==================== LLVM Code ====================
declare ccc i64 @newSpark$def(i8*, i8*)



==================== LLVM Code ====================
!0 = !{!"root"}
!1 = !{!"top", !0}
!2 = !{!"stack", !1}
!3 = !{!"heap", !1}
!4 = !{!"rx", !3}
!5 = !{!"base", !1}



==================== LLVM Code ====================



==================== LLVM Code ====================
%uaNq_srt_struct = type <{i64, i64, i64}>
%Main_zdwzdsround4dp_closure_struct = type <{i64, i64, i64}>
@uaNq_srt$def = internal global %uaNq_srt_struct<{i64 ptrtoint (i8* @stg_SRT_1_info to i64), i64 ptrtoint (i8* @integerzmgmp_GHCziIntegerziType_shiftLInteger_closure to i64), i64 0}>
@uaNq_srt = internal alias i8, bitcast (%uaNq_srt_struct* @uaNq_srt$def to i8*)
@Main_zdwzdsround4dp_closure$def = internal global %Main_zdwzdsround4dp_closure_struct<{i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64, double)* @Main_zdwzdsround4dp_info$def to i64), i64 ptrtoint (i8* @uaNq_srt to i64), i64 0}>
@Main_zdwzdsround4dp_closure = alias i8, bitcast (%Main_zdwzdsround4dp_closure_struct* @Main_zdwzdsround4dp_closure$def to i8*)



==================== LLVM Code ====================
@Main_zdwzdsround4dp_info = alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64, double)* @Main_zdwzdsround4dp_info$def to i8*)
define ghccc void @Main_zdwzdsround4dp_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg, double %D1_Arg) align 8 nounwind prefix <{i64, i64, i32, i32}><{i64 4294967303, i64 1, i32 14, i32 0}>
{
caMI:
  %lcaMN = alloca double, i32 1
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R5_Var = alloca i64, i32 1
  store i64 undef, i64* %R5_Var
  %R6_Var = alloca i64, i32 1
  store i64 undef, i64* %R6_Var
  %F1_Var = alloca float, i32 1
  store float undef, float* %F1_Var
  %D1_Var = alloca double, i32 1
  store double %D1_Arg, double* %D1_Var
  %F2_Var = alloca float, i32 1
  store float undef, float* %F2_Var
  %D2_Var = alloca double, i32 1
  store double undef, double* %D2_Var
  %F3_Var = alloca float, i32 1
  store float undef, float* %F3_Var
  %D3_Var = alloca double, i32 1
  store double undef, double* %D3_Var
  %F4_Var = alloca float, i32 1
  store float undef, float* %F4_Var
  %D4_Var = alloca double, i32 1
  store double undef, double* %D4_Var
  %F5_Var = alloca float, i32 1
  store float undef, float* %F5_Var
  %D5_Var = alloca double, i32 1
  store double undef, double* %D5_Var
  %F6_Var = alloca float, i32 1
  store float undef, float* %F6_Var
  %D6_Var = alloca double, i32 1
  store double undef, double* %D6_Var
  %lsaC9 = alloca double, i32 1
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lnaNr = load i64*, i64** %Sp_Var
  %lnaNs = getelementptr inbounds i64, i64* %lnaNr, i32 -2
  %lnaNt = ptrtoint i64* %lnaNs to i64
  %lnaNu = icmp ult i64 %lnaNt, %SpLim_Arg
  %lnaNw = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnaNu, i1 0 )
  br i1 %lnaNw, label %caMJ, label %caMK
caMK:
  %lnaNx = load double, double* %D1_Var
  %lnaNy = fmul double %lnaNx, 0x40C3880000000000
  store double %lnaNy, double* %lcaMN
  %lnaNz = load double, double* %lcaMN
  %lnaNA = bitcast i8* @rintDouble to double (double)*
  store i64 undef, i64* %R3_Var
  store i64 undef, i64* %R4_Var
  store i64 undef, i64* %R5_Var
  store i64 undef, i64* %R6_Var
  store float undef, float* %F1_Var
  store double undef, double* %D1_Var
  store float undef, float* %F2_Var
  store double undef, double* %D2_Var
  store float undef, float* %F3_Var
  store double undef, double* %D3_Var
  store float undef, float* %F4_Var
  store double undef, double* %D4_Var
  store float undef, float* %F5_Var
  store double undef, double* %D5_Var
  store float undef, float* %F6_Var
  store double undef, double* %D6_Var
  %lnaNB = call ccc double (double) %lnaNA( double %lnaNz ) nounwind
  store double %lnaNB, double* %lsaC9
  %lnaND = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @caMO_info$def to i64
  %lnaNC = load i64*, i64** %Sp_Var
  %lnaNE = getelementptr inbounds i64, i64* %lnaNC, i32 -1
  store i64 %lnaND, i64* %lnaNE, !tbaa !2
  %lnaNF = load double, double* %lsaC9
  store double %lnaNF, double* %D1_Var
  %lnaNG = load i64*, i64** %Sp_Var
  %lnaNH = getelementptr inbounds i64, i64* %lnaNG, i32 -1
  %lnaNI = ptrtoint i64* %lnaNH to i64
  %lnaNJ = inttoptr i64 %lnaNI to i64*
  store i64* %lnaNJ, i64** %Sp_Var
  %lnaNK = bitcast i8* @integerzmgmp_GHCziIntegerziType_decodeDoubleInteger_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64, double)*
  %lnaNL = load i64*, i64** %Sp_Var
  %lnaNM = load i64, i64* %R1_Var
  %lnaNN = load double, double* %D1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64, double) %lnaNK( i64* %Base_Arg, i64* %lnaNL, i64* %Hp_Arg, i64 %lnaNM, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg, double %lnaNN ) nounwind
  ret void
caMJ:
  %lnaNO = load double, double* %D1_Var
  store double %lnaNO, double* %D1_Var
  %lnaNP = ptrtoint %Main_zdwzdsround4dp_closure_struct* @Main_zdwzdsround4dp_closure$def to i64
  store i64 %lnaNP, i64* %R1_Var
  %lnaNQ = getelementptr inbounds i64, i64* %Base_Arg, i32 -1
  %lnaNR = bitcast i64* %lnaNQ to i64*
  %lnaNS = load i64, i64* %lnaNR, !tbaa !5
  %lnaNT = inttoptr i64 %lnaNS to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64, double)*
  %lnaNU = load i64*, i64** %Sp_Var
  %lnaNV = load i64, i64* %R1_Var
  %lnaNW = load double, double* %D1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64, double) %lnaNT( i64* %Base_Arg, i64* %lnaNU, i64* %Hp_Arg, i64 %lnaNV, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg, double %lnaNW ) nounwind
  ret void
}
declare ccc i1 @llvm.expect.i1(i1, i1)



==================== LLVM Code ====================
@caMO_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @caMO_info$def to i8*)
define internal ghccc void @caMO_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 0, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%uaNq_srt_struct* @uaNq_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @caMO_info$def to i64)) to i32),i32 0)}>
{
caMO:
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 %R2_Arg, i64* %R2_Var
  %lsaCc = alloca i64, i32 1
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnaNX = load i64, i64* %R2_Var
  %lnaNY = icmp slt i64 %lnaNX, 0
  %lnaNZ = zext i1 %lnaNY to i64
  switch i64 %lnaNZ, label %caN6 [i64 1, label %caNo]
caN6:
  %lnaO1 = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @caMW_info$def to i64
  %lnaO0 = load i64*, i64** %Sp_Var
  %lnaO2 = getelementptr inbounds i64, i64* %lnaO0, i32 0
  store i64 %lnaO1, i64* %lnaO2, !tbaa !2
  %lnaO3 = load i64, i64* %R2_Var
  store i64 %lnaO3, i64* %R3_Var
  store i64 %R1_Arg, i64* %R2_Var
  %lnaO4 = bitcast i8* @integerzmgmp_GHCziIntegerziType_shiftLInteger_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnaO5 = load i64*, i64** %Sp_Var
  %lnaO6 = load i64, i64* %R2_Var
  %lnaO7 = load i64, i64* %R3_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnaO4( i64* %Base_Arg, i64* %lnaO5, i64* %Hp_Arg, i64 %R1_Arg, i64 %lnaO6, i64 %lnaO7, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
caNo:
  %lnaO9 = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @caNa_info$def to i64
  %lnaO8 = load i64*, i64** %Sp_Var
  %lnaOa = getelementptr inbounds i64, i64* %lnaO8, i32 -1
  store i64 %lnaO9, i64* %lnaOa, !tbaa !2
  %lnaOb = load i64, i64* %R2_Var
  store i64 %lnaOb, i64* %lsaCc
  store i64 %R1_Arg, i64* %R2_Var
  %lnaOd = load i64, i64* %lsaCc
  %lnaOc = load i64*, i64** %Sp_Var
  %lnaOe = getelementptr inbounds i64, i64* %lnaOc, i32 0
  store i64 %lnaOd, i64* %lnaOe, !tbaa !2
  %lnaOf = load i64*, i64** %Sp_Var
  %lnaOg = getelementptr inbounds i64, i64* %lnaOf, i32 -1
  %lnaOh = ptrtoint i64* %lnaOg to i64
  %lnaOi = inttoptr i64 %lnaOh to i64*
  store i64* %lnaOi, i64** %Sp_Var
  %lnaOj = bitcast i8* @integerzmgmp_GHCziIntegerziType_integerToInt_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnaOk = load i64*, i64** %Sp_Var
  %lnaOl = load i64, i64* %R2_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnaOj( i64* %Base_Arg, i64* %lnaOk, i64* %Hp_Arg, i64 %R1_Arg, i64 %lnaOl, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@caNa_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @caNa_info$def to i8*)
define internal ghccc void @caNa_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 65, i32 30, i32 0}>
{
caNa:
  %D1_Var = alloca double, i32 1
  store double undef, double* %D1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnaOm = load i64*, i64** %Sp_Var
  %lnaOn = getelementptr inbounds i64, i64* %lnaOm, i32 1
  %lnaOo = bitcast i64* %lnaOn to i64*
  %lnaOp = load i64, i64* %lnaOo, !tbaa !2
  %lnaOq = sub i64 0, %lnaOp
  %lnaOr = ashr i64 %R1_Arg, %lnaOq
  %lnaOs = sitofp i64 %lnaOr to double
  %lnaOt = fdiv double %lnaOs, 0x40C3880000000000
  store double %lnaOt, double* %D1_Var
  %lnaOu = load i64*, i64** %Sp_Var
  %lnaOv = getelementptr inbounds i64, i64* %lnaOu, i32 2
  %lnaOw = ptrtoint i64* %lnaOv to i64
  %lnaOx = inttoptr i64 %lnaOw to i64*
  store i64* %lnaOx, i64** %Sp_Var
  %lnaOy = load i64*, i64** %Sp_Var
  %lnaOz = getelementptr inbounds i64, i64* %lnaOy, i32 0
  %lnaOA = bitcast i64* %lnaOz to i64*
  %lnaOB = load i64, i64* %lnaOA, !tbaa !2
  %lnaOC = inttoptr i64 %lnaOB to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64, double)*
  %lnaOD = load i64*, i64** %Sp_Var
  %lnaOE = load double, double* %D1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64, double) %lnaOC( i64* %Base_Arg, i64* %lnaOD, i64* %Hp_Arg, i64 %R1_Arg, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg, double %lnaOE ) nounwind
  ret void
}



==================== LLVM Code ====================
@caMW_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @caMW_info$def to i8*)
define internal ghccc void @caMW_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 0, i32 30, i32 0}>
{
caMW:
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %lnaOF = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64, double)* @caN0_info$def to i64
  %lnaOG = getelementptr inbounds i64, i64* %Sp_Arg, i32 0
  store i64 %lnaOF, i64* %lnaOG, !tbaa !2
  store i64 %R1_Arg, i64* %R2_Var
  %lnaOH = bitcast i8* @integerzmgmp_GHCziIntegerziType_doubleFromInteger_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnaOI = load i64, i64* %R2_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnaOH( i64* %Base_Arg, i64* %Sp_Arg, i64* %Hp_Arg, i64 %R1_Arg, i64 %lnaOI, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@caN0_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64, double)* @caN0_info$def to i8*)
define internal ghccc void @caN0_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg, double %D1_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 0, i32 30, i32 0}>
{
caN0:
  %D1_Var = alloca double, i32 1
  store double %D1_Arg, double* %D1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnaOJ = load double, double* %D1_Var
  %lnaOK = fdiv double %lnaOJ, 0x40C3880000000000
  store double %lnaOK, double* %D1_Var
  %lnaOL = load i64*, i64** %Sp_Var
  %lnaOM = getelementptr inbounds i64, i64* %lnaOL, i32 1
  %lnaON = ptrtoint i64* %lnaOM to i64
  %lnaOO = inttoptr i64 %lnaON to i64*
  store i64* %lnaOO, i64** %Sp_Var
  %lnaOP = load i64*, i64** %Sp_Var
  %lnaOQ = getelementptr inbounds i64, i64* %lnaOP, i32 0
  %lnaOR = bitcast i64* %lnaOQ to i64*
  %lnaOS = load i64, i64* %lnaOR, !tbaa !2
  %lnaOT = inttoptr i64 %lnaOS to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64, double)*
  %lnaOU = load i64*, i64** %Sp_Var
  %lnaOV = load double, double* %D1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64, double) %lnaOT( i64* %Base_Arg, i64* %lnaOU, i64* %Hp_Arg, i64 %R1_Arg, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg, double %lnaOV ) nounwind
  ret void
}



==================== LLVM Code ====================
%Main_round4dp2_closure_struct = type <{i64, i64}>
@Main_round4dp2_closure$def = internal global %Main_round4dp2_closure_struct<{i64 ptrtoint (i8* @integerzmgmp_GHCziIntegerziType_Szh_con_info to i64), i64 10000}>
@Main_round4dp2_closure = alias i8, bitcast (%Main_round4dp2_closure_struct* @Main_round4dp2_closure$def to i8*)



==================== LLVM Code ====================
%Main_repeatNTimes2_closure_struct = type <{i64, i64}>
@Main_repeatNTimes2_closure$def = internal global %Main_repeatNTimes2_closure_struct<{i64 ptrtoint (i8* @integerzmgmp_GHCziIntegerziType_Szh_con_info to i64), i64 1}>
@Main_repeatNTimes2_closure = alias i8, bitcast (%Main_repeatNTimes2_closure_struct* @Main_repeatNTimes2_closure$def to i8*)



==================== LLVM Code ====================
%Main_round4dp1_closure_struct = type <{i64, i64, i64, i64}>
@Main_round4dp1_closure$def = internal global %Main_round4dp1_closure_struct<{i64 ptrtoint (i8* @base_GHCziReal_ZCzv_con_info to i64), i64 add (i64 ptrtoint (%Main_round4dp2_closure_struct* @Main_round4dp2_closure$def to i64),i64 1), i64 add (i64 ptrtoint (%Main_repeatNTimes2_closure_struct* @Main_repeatNTimes2_closure$def to i64),i64 1), i64 3}>
@Main_round4dp1_closure = alias i8, bitcast (%Main_round4dp1_closure_struct* @Main_round4dp1_closure$def to i8*)



==================== LLVM Code ====================
%uaPP_srt_struct = type <{i64, i64, i64}>
%uaPQ_srt_struct = type <{i64, i64, i64}>
%uaPR_srt_struct = type <{i64, i64, i64}>
%Main_zdwround4dp_closure_struct = type <{i64, i64, i64}>
@uaPP_srt$def = internal global %uaPP_srt_struct<{i64 ptrtoint (i8* @stg_SRT_1_info to i64), i64 ptrtoint (i8* @base_GHCziReal_zdfIntegralInteger_closure to i64), i64 0}>
@uaPP_srt = internal alias i8, bitcast (%uaPP_srt_struct* @uaPP_srt$def to i8*)
@uaPQ_srt$def = internal global %uaPQ_srt_struct<{i64 ptrtoint (i8* @stg_SRT_1_info to i64), i64 ptrtoint (i8* @uaPP_srt to i64), i64 0}>
@uaPQ_srt = internal alias i8, bitcast (%uaPQ_srt_struct* @uaPQ_srt$def to i8*)
@uaPR_srt$def = internal global %uaPR_srt_struct<{i64 ptrtoint (i8* @stg_SRT_1_info to i64), i64 ptrtoint (i8* @uaPQ_srt to i64), i64 0}>
@uaPR_srt = internal alias i8, bitcast (%uaPR_srt_struct* @uaPR_srt$def to i8*)
@Main_zdwround4dp_closure$def = internal global %Main_zdwround4dp_closure_struct<{i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_zdwround4dp_info$def to i64), i64 ptrtoint (i8* @uaPR_srt to i64), i64 0}>
@Main_zdwround4dp_closure = alias i8, bitcast (%Main_zdwround4dp_closure_struct* @Main_zdwround4dp_closure$def to i8*)



==================== LLVM Code ====================
@saCB_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saCB_info$def to i8*)
define internal ghccc void @saCB_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 1, i32 16, i32 0}>
{
caP4:
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnaPS = load i64*, i64** %Sp_Var
  %lnaPT = getelementptr inbounds i64, i64* %lnaPS, i32 -2
  %lnaPU = ptrtoint i64* %lnaPT to i64
  %lnaPV = icmp ult i64 %lnaPU, %SpLim_Arg
  %lnaPW = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnaPV, i1 0 )
  br i1 %lnaPW, label %caP5, label %caP6
caP6:
  %lnaPY = ptrtoint i8* @stg_upd_frame_info to i64
  %lnaPX = load i64*, i64** %Sp_Var
  %lnaPZ = getelementptr inbounds i64, i64* %lnaPX, i32 -2
  store i64 %lnaPY, i64* %lnaPZ, !tbaa !2
  %lnaQ1 = load i64, i64* %R1_Var
  %lnaQ0 = load i64*, i64** %Sp_Var
  %lnaQ2 = getelementptr inbounds i64, i64* %lnaQ0, i32 -1
  store i64 %lnaQ1, i64* %lnaQ2, !tbaa !2
  %lnaQ3 = ptrtoint %Main_round4dp1_closure_struct* @Main_round4dp1_closure$def to i64
  %lnaQ4 = add i64 %lnaQ3, 1
  store i64 %lnaQ4, i64* %R2_Var
  %lnaQ7 = load i64, i64* %R1_Var
  %lnaQ8 = add i64 %lnaQ7, 16
  %lnaQ9 = inttoptr i64 %lnaQ8 to i64*
  %lnaQa = load i64, i64* %lnaQ9, !tbaa !4
  store i64 %lnaQa, i64* %R1_Var
  %lnaQb = load i64*, i64** %Sp_Var
  %lnaQc = getelementptr inbounds i64, i64* %lnaQb, i32 -2
  %lnaQd = ptrtoint i64* %lnaQc to i64
  %lnaQe = inttoptr i64 %lnaQd to i64*
  store i64* %lnaQe, i64** %Sp_Var
  %lnaQf = bitcast i8* @stg_ap_p_fast to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnaQg = load i64*, i64** %Sp_Var
  %lnaQh = load i64, i64* %R1_Var
  %lnaQi = load i64, i64* %R2_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnaQf( i64* %Base_Arg, i64* %lnaQg, i64* %Hp_Arg, i64 %lnaQh, i64 %lnaQi, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
caP5:
  %lnaQj = load i64, i64* %R1_Var
  store i64 %lnaQj, i64* %R1_Var
  %lnaQk = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lnaQl = bitcast i64* %lnaQk to i64*
  %lnaQm = load i64, i64* %lnaQl, !tbaa !5
  %lnaQn = inttoptr i64 %lnaQm to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnaQo = load i64*, i64** %Sp_Var
  %lnaQp = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnaQn( i64* %Base_Arg, i64* %lnaQo, i64* %Hp_Arg, i64 %lnaQp, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saCx_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saCx_info$def to i8*)
define internal ghccc void @saCx_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 1, i32 16, i32 0}>
{
caPr:
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnaQq = load i64*, i64** %Sp_Var
  %lnaQr = getelementptr inbounds i64, i64* %lnaQq, i32 -2
  %lnaQs = ptrtoint i64* %lnaQr to i64
  %lnaQt = icmp ult i64 %lnaQs, %SpLim_Arg
  %lnaQu = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnaQt, i1 0 )
  br i1 %lnaQu, label %caPs, label %caPt
caPt:
  %lnaQw = ptrtoint i8* @stg_upd_frame_info to i64
  %lnaQv = load i64*, i64** %Sp_Var
  %lnaQx = getelementptr inbounds i64, i64* %lnaQv, i32 -2
  store i64 %lnaQw, i64* %lnaQx, !tbaa !2
  %lnaQz = load i64, i64* %R1_Var
  %lnaQy = load i64*, i64** %Sp_Var
  %lnaQA = getelementptr inbounds i64, i64* %lnaQy, i32 -1
  store i64 %lnaQz, i64* %lnaQA, !tbaa !2
  %lnaQB = ptrtoint %Main_round4dp1_closure_struct* @Main_round4dp1_closure$def to i64
  %lnaQC = add i64 %lnaQB, 1
  store i64 %lnaQC, i64* %R2_Var
  %lnaQF = load i64, i64* %R1_Var
  %lnaQG = add i64 %lnaQF, 16
  %lnaQH = inttoptr i64 %lnaQG to i64*
  %lnaQI = load i64, i64* %lnaQH, !tbaa !4
  store i64 %lnaQI, i64* %R1_Var
  %lnaQJ = load i64*, i64** %Sp_Var
  %lnaQK = getelementptr inbounds i64, i64* %lnaQJ, i32 -2
  %lnaQL = ptrtoint i64* %lnaQK to i64
  %lnaQM = inttoptr i64 %lnaQL to i64*
  store i64* %lnaQM, i64** %Sp_Var
  %lnaQN = bitcast i8* @stg_ap_p_fast to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnaQO = load i64*, i64** %Sp_Var
  %lnaQP = load i64, i64* %R1_Var
  %lnaQQ = load i64, i64* %R2_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnaQN( i64* %Base_Arg, i64* %lnaQO, i64* %Hp_Arg, i64 %lnaQP, i64 %lnaQQ, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
caPs:
  %lnaQR = load i64, i64* %R1_Var
  store i64 %lnaQR, i64* %R1_Var
  %lnaQS = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lnaQT = bitcast i64* %lnaQS to i64*
  %lnaQU = load i64, i64* %lnaQT, !tbaa !5
  %lnaQV = inttoptr i64 %lnaQU to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnaQW = load i64*, i64** %Sp_Var
  %lnaQX = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnaQV( i64* %Base_Arg, i64* %lnaQW, i64* %Hp_Arg, i64 %lnaQX, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saCy_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saCy_info$def to i8*)
define internal ghccc void @saCy_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 3, i32 15, i32 0}>
{
caPu:
  %lsaCy = alloca i64, i32 1
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %lsaCm = alloca i64, i32 1
  %lsaCo = alloca i64, i32 1
  %lsaCs = alloca i64, i32 1
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnaQY = load i64, i64* %R1_Var
  store i64 %lnaQY, i64* %lsaCy
  %lnaQZ = load i64*, i64** %Sp_Var
  %lnaR0 = getelementptr inbounds i64, i64* %lnaQZ, i32 -2
  %lnaR1 = ptrtoint i64* %lnaR0 to i64
  %lnaR2 = icmp ult i64 %lnaR1, %SpLim_Arg
  %lnaR3 = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnaR2, i1 0 )
  br i1 %lnaR3, label %caPv, label %caPw
caPw:
  %lnaR4 = load i64*, i64** %Hp_Var
  %lnaR5 = getelementptr inbounds i64, i64* %lnaR4, i32 3
  %lnaR6 = ptrtoint i64* %lnaR5 to i64
  %lnaR7 = inttoptr i64 %lnaR6 to i64*
  store i64* %lnaR7, i64** %Hp_Var
  %lnaR8 = load i64*, i64** %Hp_Var
  %lnaR9 = ptrtoint i64* %lnaR8 to i64
  %lnaRa = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lnaRb = bitcast i64* %lnaRa to i64*
  %lnaRc = load i64, i64* %lnaRb, !tbaa !5
  %lnaRd = icmp ugt i64 %lnaR9, %lnaRc
  %lnaRe = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnaRd, i1 0 )
  br i1 %lnaRe, label %caPy, label %caPx
caPx:
  %lnaRg = ptrtoint i8* @stg_upd_frame_info to i64
  %lnaRf = load i64*, i64** %Sp_Var
  %lnaRh = getelementptr inbounds i64, i64* %lnaRf, i32 -2
  store i64 %lnaRg, i64* %lnaRh, !tbaa !2
  %lnaRj = load i64, i64* %lsaCy
  %lnaRi = load i64*, i64** %Sp_Var
  %lnaRk = getelementptr inbounds i64, i64* %lnaRi, i32 -1
  store i64 %lnaRj, i64* %lnaRk, !tbaa !2
  %lnaRl = load i64, i64* %lsaCy
  %lnaRm = add i64 %lnaRl, 16
  %lnaRn = inttoptr i64 %lnaRm to i64*
  %lnaRo = load i64, i64* %lnaRn, !tbaa !1
  store i64 %lnaRo, i64* %lsaCm
  %lnaRp = load i64, i64* %lsaCy
  %lnaRq = add i64 %lnaRp, 24
  %lnaRr = inttoptr i64 %lnaRq to i64*
  %lnaRs = load i64, i64* %lnaRr, !tbaa !1
  store i64 %lnaRs, i64* %lsaCo
  %lnaRt = load i64, i64* %lsaCy
  %lnaRu = add i64 %lnaRt, 32
  %lnaRv = inttoptr i64 %lnaRu to i64*
  %lnaRw = load i64, i64* %lnaRv, !tbaa !1
  store i64 %lnaRw, i64* %lsaCs
  %lnaRy = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saCx_info$def to i64
  %lnaRx = load i64*, i64** %Hp_Var
  %lnaRz = getelementptr inbounds i64, i64* %lnaRx, i32 -2
  store i64 %lnaRy, i64* %lnaRz, !tbaa !3
  %lnaRB = load i64, i64* %lsaCm
  %lnaRA = load i64*, i64** %Hp_Var
  %lnaRC = getelementptr inbounds i64, i64* %lnaRA, i32 0
  store i64 %lnaRB, i64* %lnaRC, !tbaa !3
  %lnaRD = load i64*, i64** %Hp_Var
  %lnaRE = getelementptr inbounds i64, i64* %lnaRD, i32 -2
  %lnaRF = ptrtoint i64* %lnaRE to i64
  store i64 %lnaRF, i64* %R3_Var
  %lnaRG = load i64, i64* %lsaCo
  store i64 %lnaRG, i64* %R2_Var
  %lnaRH = load i64, i64* %lsaCs
  store i64 %lnaRH, i64* %R1_Var
  %lnaRI = load i64*, i64** %Sp_Var
  %lnaRJ = getelementptr inbounds i64, i64* %lnaRI, i32 -2
  %lnaRK = ptrtoint i64* %lnaRJ to i64
  %lnaRL = inttoptr i64 %lnaRK to i64*
  store i64* %lnaRL, i64** %Sp_Var
  %lnaRM = bitcast i8* @stg_ap_pp_fast to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnaRN = load i64*, i64** %Sp_Var
  %lnaRO = load i64*, i64** %Hp_Var
  %lnaRP = load i64, i64* %R1_Var
  %lnaRQ = load i64, i64* %R2_Var
  %lnaRR = load i64, i64* %R3_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnaRM( i64* %Base_Arg, i64* %lnaRN, i64* %lnaRO, i64 %lnaRP, i64 %lnaRQ, i64 %lnaRR, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
caPy:
  %lnaRS = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 24, i64* %lnaRS, !tbaa !5
  br label %caPv
caPv:
  %lnaRT = load i64, i64* %lsaCy
  store i64 %lnaRT, i64* %R1_Var
  %lnaRU = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lnaRV = bitcast i64* %lnaRU to i64*
  %lnaRW = load i64, i64* %lnaRV, !tbaa !5
  %lnaRX = inttoptr i64 %lnaRW to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnaRY = load i64*, i64** %Sp_Var
  %lnaRZ = load i64*, i64** %Hp_Var
  %lnaS0 = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnaRX( i64* %Base_Arg, i64* %lnaRY, i64* %lnaRZ, i64 %lnaS0, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saCz_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saCz_info$def to i8*)
define internal ghccc void @saCz_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 4, i32 15, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%uaPP_srt_struct* @uaPP_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saCz_info$def to i64)) to i32),i32 0)}>
{
caPz:
  %lsaCz = alloca i64, i32 1
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %lsaCm = alloca i64, i32 1
  %lsaCn = alloca i64, i32 1
  %lsaCo = alloca i64, i32 1
  %lsaCs = alloca i64, i32 1
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnaS1 = load i64, i64* %R1_Var
  store i64 %lnaS1, i64* %lsaCz
  %lnaS2 = load i64*, i64** %Sp_Var
  %lnaS3 = getelementptr inbounds i64, i64* %lnaS2, i32 -2
  %lnaS4 = ptrtoint i64* %lnaS3 to i64
  %lnaS5 = icmp ult i64 %lnaS4, %SpLim_Arg
  %lnaS6 = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnaS5, i1 0 )
  br i1 %lnaS6, label %caPA, label %caPB
caPB:
  %lnaS7 = load i64*, i64** %Hp_Var
  %lnaS8 = getelementptr inbounds i64, i64* %lnaS7, i32 5
  %lnaS9 = ptrtoint i64* %lnaS8 to i64
  %lnaSa = inttoptr i64 %lnaS9 to i64*
  store i64* %lnaSa, i64** %Hp_Var
  %lnaSb = load i64*, i64** %Hp_Var
  %lnaSc = ptrtoint i64* %lnaSb to i64
  %lnaSd = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lnaSe = bitcast i64* %lnaSd to i64*
  %lnaSf = load i64, i64* %lnaSe, !tbaa !5
  %lnaSg = icmp ugt i64 %lnaSc, %lnaSf
  %lnaSh = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnaSg, i1 0 )
  br i1 %lnaSh, label %caPD, label %caPC
caPC:
  %lnaSj = ptrtoint i8* @stg_upd_frame_info to i64
  %lnaSi = load i64*, i64** %Sp_Var
  %lnaSk = getelementptr inbounds i64, i64* %lnaSi, i32 -2
  store i64 %lnaSj, i64* %lnaSk, !tbaa !2
  %lnaSm = load i64, i64* %lsaCz
  %lnaSl = load i64*, i64** %Sp_Var
  %lnaSn = getelementptr inbounds i64, i64* %lnaSl, i32 -1
  store i64 %lnaSm, i64* %lnaSn, !tbaa !2
  %lnaSo = load i64, i64* %lsaCz
  %lnaSp = add i64 %lnaSo, 16
  %lnaSq = inttoptr i64 %lnaSp to i64*
  %lnaSr = load i64, i64* %lnaSq, !tbaa !1
  store i64 %lnaSr, i64* %lsaCm
  %lnaSs = load i64, i64* %lsaCz
  %lnaSt = add i64 %lnaSs, 24
  %lnaSu = inttoptr i64 %lnaSt to i64*
  %lnaSv = load i64, i64* %lnaSu, !tbaa !1
  store i64 %lnaSv, i64* %lsaCn
  %lnaSw = load i64, i64* %lsaCz
  %lnaSx = add i64 %lnaSw, 32
  %lnaSy = inttoptr i64 %lnaSx to i64*
  %lnaSz = load i64, i64* %lnaSy, !tbaa !1
  store i64 %lnaSz, i64* %lsaCo
  %lnaSA = load i64, i64* %lsaCz
  %lnaSB = add i64 %lnaSA, 40
  %lnaSC = inttoptr i64 %lnaSB to i64*
  %lnaSD = load i64, i64* %lnaSC, !tbaa !1
  store i64 %lnaSD, i64* %lsaCs
  %lnaSF = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saCy_info$def to i64
  %lnaSE = load i64*, i64** %Hp_Var
  %lnaSG = getelementptr inbounds i64, i64* %lnaSE, i32 -4
  store i64 %lnaSF, i64* %lnaSG, !tbaa !3
  %lnaSI = load i64, i64* %lsaCm
  %lnaSH = load i64*, i64** %Hp_Var
  %lnaSJ = getelementptr inbounds i64, i64* %lnaSH, i32 -2
  store i64 %lnaSI, i64* %lnaSJ, !tbaa !3
  %lnaSL = load i64, i64* %lsaCo
  %lnaSK = load i64*, i64** %Hp_Var
  %lnaSM = getelementptr inbounds i64, i64* %lnaSK, i32 -1
  store i64 %lnaSL, i64* %lnaSM, !tbaa !3
  %lnaSO = load i64, i64* %lsaCs
  %lnaSN = load i64*, i64** %Hp_Var
  %lnaSP = getelementptr inbounds i64, i64* %lnaSN, i32 0
  store i64 %lnaSO, i64* %lnaSP, !tbaa !3
  %lnaSQ = load i64*, i64** %Hp_Var
  %lnaSR = getelementptr inbounds i64, i64* %lnaSQ, i32 -4
  %lnaSS = ptrtoint i64* %lnaSR to i64
  store i64 %lnaSS, i64* %R3_Var
  %lnaST = ptrtoint i8* @base_GHCziReal_zdfIntegralInteger_closure to i64
  store i64 %lnaST, i64* %R2_Var
  %lnaSU = load i64, i64* %lsaCn
  store i64 %lnaSU, i64* %R1_Var
  %lnaSV = load i64*, i64** %Sp_Var
  %lnaSW = getelementptr inbounds i64, i64* %lnaSV, i32 -2
  %lnaSX = ptrtoint i64* %lnaSW to i64
  %lnaSY = inttoptr i64 %lnaSX to i64*
  store i64* %lnaSY, i64** %Sp_Var
  %lnaSZ = bitcast i8* @stg_ap_pp_fast to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnaT0 = load i64*, i64** %Sp_Var
  %lnaT1 = load i64*, i64** %Hp_Var
  %lnaT2 = load i64, i64* %R1_Var
  %lnaT3 = load i64, i64* %R2_Var
  %lnaT4 = load i64, i64* %R3_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnaSZ( i64* %Base_Arg, i64* %lnaT0, i64* %lnaT1, i64 %lnaT2, i64 %lnaT3, i64 %lnaT4, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
caPD:
  %lnaT5 = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 40, i64* %lnaT5, !tbaa !5
  br label %caPA
caPA:
  %lnaT6 = load i64, i64* %lsaCz
  store i64 %lnaT6, i64* %R1_Var
  %lnaT7 = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lnaT8 = bitcast i64* %lnaT7 to i64*
  %lnaT9 = load i64, i64* %lnaT8, !tbaa !5
  %lnaTa = inttoptr i64 %lnaT9 to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnaTb = load i64*, i64** %Sp_Var
  %lnaTc = load i64*, i64** %Hp_Var
  %lnaTd = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnaTa( i64* %Base_Arg, i64* %lnaTb, i64* %lnaTc, i64 %lnaTd, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saCA_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saCA_info$def to i8*)
define internal ghccc void @saCA_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 4, i32 15, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%uaPR_srt_struct* @uaPR_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saCA_info$def to i64)) to i32),i32 0)}>
{
caPE:
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lnaTe = load i64*, i64** %Sp_Var
  %lnaTf = getelementptr inbounds i64, i64* %lnaTe, i32 -6
  %lnaTg = ptrtoint i64* %lnaTf to i64
  %lnaTh = icmp ult i64 %lnaTg, %SpLim_Arg
  %lnaTi = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnaTh, i1 0 )
  br i1 %lnaTi, label %caPF, label %caPG
caPG:
  %lnaTk = ptrtoint i8* @stg_upd_frame_info to i64
  %lnaTj = load i64*, i64** %Sp_Var
  %lnaTl = getelementptr inbounds i64, i64* %lnaTj, i32 -2
  store i64 %lnaTk, i64* %lnaTl, !tbaa !2
  %lnaTn = load i64, i64* %R1_Var
  %lnaTm = load i64*, i64** %Sp_Var
  %lnaTo = getelementptr inbounds i64, i64* %lnaTm, i32 -1
  store i64 %lnaTn, i64* %lnaTo, !tbaa !2
  %lnaTq = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @caPb_info$def to i64
  %lnaTp = load i64*, i64** %Sp_Var
  %lnaTr = getelementptr inbounds i64, i64* %lnaTp, i32 -6
  store i64 %lnaTq, i64* %lnaTr, !tbaa !2
  %lnaTu = load i64, i64* %R1_Var
  %lnaTv = add i64 %lnaTu, 16
  %lnaTw = inttoptr i64 %lnaTv to i64*
  %lnaTx = load i64, i64* %lnaTw, !tbaa !4
  store i64 %lnaTx, i64* %R2_Var
  %lnaTB = load i64, i64* %R1_Var
  %lnaTC = add i64 %lnaTB, 24
  %lnaTD = inttoptr i64 %lnaTC to i64*
  %lnaTE = load i64, i64* %lnaTD, !tbaa !4
  %lnaTy = load i64*, i64** %Sp_Var
  %lnaTF = getelementptr inbounds i64, i64* %lnaTy, i32 -5
  store i64 %lnaTE, i64* %lnaTF, !tbaa !2
  %lnaTJ = load i64, i64* %R1_Var
  %lnaTK = add i64 %lnaTJ, 32
  %lnaTL = inttoptr i64 %lnaTK to i64*
  %lnaTM = load i64, i64* %lnaTL, !tbaa !4
  %lnaTG = load i64*, i64** %Sp_Var
  %lnaTN = getelementptr inbounds i64, i64* %lnaTG, i32 -4
  store i64 %lnaTM, i64* %lnaTN, !tbaa !2
  %lnaTR = load i64, i64* %R1_Var
  %lnaTS = add i64 %lnaTR, 40
  %lnaTT = inttoptr i64 %lnaTS to i64*
  %lnaTU = load i64, i64* %lnaTT, !tbaa !4
  %lnaTO = load i64*, i64** %Sp_Var
  %lnaTV = getelementptr inbounds i64, i64* %lnaTO, i32 -3
  store i64 %lnaTU, i64* %lnaTV, !tbaa !2
  %lnaTW = load i64*, i64** %Sp_Var
  %lnaTX = getelementptr inbounds i64, i64* %lnaTW, i32 -6
  %lnaTY = ptrtoint i64* %lnaTX to i64
  %lnaTZ = inttoptr i64 %lnaTY to i64*
  store i64* %lnaTZ, i64** %Sp_Var
  %lnaU0 = bitcast i8* @base_GHCziReal_zdp1Real_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnaU1 = load i64*, i64** %Sp_Var
  %lnaU2 = load i64, i64* %R1_Var
  %lnaU3 = load i64, i64* %R2_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnaU0( i64* %Base_Arg, i64* %lnaU1, i64* %Hp_Arg, i64 %lnaU2, i64 %lnaU3, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
caPF:
  %lnaU4 = load i64, i64* %R1_Var
  store i64 %lnaU4, i64* %R1_Var
  %lnaU5 = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lnaU6 = bitcast i64* %lnaU5 to i64*
  %lnaU7 = load i64, i64* %lnaU6, !tbaa !5
  %lnaU8 = inttoptr i64 %lnaU7 to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnaU9 = load i64*, i64** %Sp_Var
  %lnaUa = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnaU8( i64* %Base_Arg, i64* %lnaU9, i64* %Hp_Arg, i64 %lnaUa, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@caPb_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @caPb_info$def to i8*)
define internal ghccc void @caPb_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 3, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%uaPQ_srt_struct* @uaPQ_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @caPb_info$def to i64)) to i32),i32 0)}>
{
caPb:
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %lsaCs = alloca i64, i32 1
  %lsaCw = alloca i64, i32 1
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnaUb = load i64*, i64** %Hp_Var
  %lnaUc = getelementptr inbounds i64, i64* %lnaUb, i32 6
  %lnaUd = ptrtoint i64* %lnaUc to i64
  %lnaUe = inttoptr i64 %lnaUd to i64*
  store i64* %lnaUe, i64** %Hp_Var
  %lnaUf = load i64*, i64** %Hp_Var
  %lnaUg = ptrtoint i64* %lnaUf to i64
  %lnaUh = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lnaUi = bitcast i64* %lnaUh to i64*
  %lnaUj = load i64, i64* %lnaUi, !tbaa !5
  %lnaUk = icmp ugt i64 %lnaUg, %lnaUj
  %lnaUl = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnaUk, i1 0 )
  br i1 %lnaUl, label %caPJ, label %caPI
caPI:
  %lnaUo = load i64, i64* %R1_Var
  %lnaUp = add i64 %lnaUo, 23
  %lnaUq = inttoptr i64 %lnaUp to i64*
  %lnaUr = load i64, i64* %lnaUq, !tbaa !4
  store i64 %lnaUr, i64* %lsaCs
  %lnaUu = load i64, i64* %R1_Var
  %lnaUv = add i64 %lnaUu, 55
  %lnaUw = inttoptr i64 %lnaUv to i64*
  %lnaUx = load i64, i64* %lnaUw, !tbaa !4
  store i64 %lnaUx, i64* %lsaCw
  %lnaUz = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saCz_info$def to i64
  %lnaUy = load i64*, i64** %Hp_Var
  %lnaUA = getelementptr inbounds i64, i64* %lnaUy, i32 -5
  store i64 %lnaUz, i64* %lnaUA, !tbaa !3
  %lnaUC = load i64*, i64** %Sp_Var
  %lnaUD = getelementptr inbounds i64, i64* %lnaUC, i32 1
  %lnaUE = bitcast i64* %lnaUD to i64*
  %lnaUF = load i64, i64* %lnaUE, !tbaa !2
  %lnaUB = load i64*, i64** %Hp_Var
  %lnaUG = getelementptr inbounds i64, i64* %lnaUB, i32 -3
  store i64 %lnaUF, i64* %lnaUG, !tbaa !3
  %lnaUI = load i64*, i64** %Sp_Var
  %lnaUJ = getelementptr inbounds i64, i64* %lnaUI, i32 2
  %lnaUK = bitcast i64* %lnaUJ to i64*
  %lnaUL = load i64, i64* %lnaUK, !tbaa !2
  %lnaUH = load i64*, i64** %Hp_Var
  %lnaUM = getelementptr inbounds i64, i64* %lnaUH, i32 -2
  store i64 %lnaUL, i64* %lnaUM, !tbaa !3
  %lnaUO = load i64*, i64** %Sp_Var
  %lnaUP = getelementptr inbounds i64, i64* %lnaUO, i32 3
  %lnaUQ = bitcast i64* %lnaUP to i64*
  %lnaUR = load i64, i64* %lnaUQ, !tbaa !2
  %lnaUN = load i64*, i64** %Hp_Var
  %lnaUS = getelementptr inbounds i64, i64* %lnaUN, i32 -1
  store i64 %lnaUR, i64* %lnaUS, !tbaa !3
  %lnaUU = load i64, i64* %lsaCs
  %lnaUT = load i64*, i64** %Hp_Var
  %lnaUV = getelementptr inbounds i64, i64* %lnaUT, i32 0
  store i64 %lnaUU, i64* %lnaUV, !tbaa !3
  %lnaUW = load i64*, i64** %Hp_Var
  %lnaUX = getelementptr inbounds i64, i64* %lnaUW, i32 -5
  %lnaUY = ptrtoint i64* %lnaUX to i64
  store i64 %lnaUY, i64* %R2_Var
  %lnaUZ = load i64, i64* %lsaCw
  store i64 %lnaUZ, i64* %R1_Var
  %lnaV0 = load i64*, i64** %Sp_Var
  %lnaV1 = getelementptr inbounds i64, i64* %lnaV0, i32 4
  %lnaV2 = ptrtoint i64* %lnaV1 to i64
  %lnaV3 = inttoptr i64 %lnaV2 to i64*
  store i64* %lnaV3, i64** %Sp_Var
  %lnaV4 = bitcast i8* @stg_ap_p_fast to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnaV5 = load i64*, i64** %Sp_Var
  %lnaV6 = load i64*, i64** %Hp_Var
  %lnaV7 = load i64, i64* %R1_Var
  %lnaV8 = load i64, i64* %R2_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnaV4( i64* %Base_Arg, i64* %lnaV5, i64* %lnaV6, i64 %lnaV7, i64 %lnaV8, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
caPJ:
  %lnaV9 = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 48, i64* %lnaV9, !tbaa !5
  %lnaVa = load i64, i64* %R1_Var
  store i64 %lnaVa, i64* %R1_Var
  %lnaVb = bitcast i8* @stg_gc_unpt_r1 to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnaVc = load i64*, i64** %Sp_Var
  %lnaVd = load i64*, i64** %Hp_Var
  %lnaVe = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnaVb( i64* %Base_Arg, i64* %lnaVc, i64* %lnaVd, i64 %lnaVe, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@Main_zdwround4dp_info = alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_zdwround4dp_info$def to i8*)
define ghccc void @Main_zdwround4dp_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i64, i32, i32}><{i64 21474836505, i64 1, i32 14, i32 0}>
{
caPK:
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %lsaCl = alloca i64, i32 1
  %R3_Var = alloca i64, i32 1
  store i64 %R3_Arg, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 %R2_Arg, i64* %R2_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %R6_Var = alloca i64, i32 1
  store i64 %R6_Arg, i64* %R6_Var
  %R5_Var = alloca i64, i32 1
  store i64 %R5_Arg, i64* %R5_Var
  %R4_Var = alloca i64, i32 1
  store i64 %R4_Arg, i64* %R4_Var
  %lnaVf = load i64*, i64** %Hp_Var
  %lnaVg = getelementptr inbounds i64, i64* %lnaVf, i32 9
  %lnaVh = ptrtoint i64* %lnaVg to i64
  %lnaVi = inttoptr i64 %lnaVh to i64*
  store i64* %lnaVi, i64** %Hp_Var
  %lnaVj = load i64*, i64** %Hp_Var
  %lnaVk = ptrtoint i64* %lnaVj to i64
  %lnaVl = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lnaVm = bitcast i64* %lnaVl to i64*
  %lnaVn = load i64, i64* %lnaVm, !tbaa !5
  %lnaVo = icmp ugt i64 %lnaVk, %lnaVn
  %lnaVp = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnaVo, i1 0 )
  br i1 %lnaVp, label %caPO, label %caPN
caPN:
  %lnaVr = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saCB_info$def to i64
  %lnaVq = load i64*, i64** %Hp_Var
  %lnaVs = getelementptr inbounds i64, i64* %lnaVq, i32 -8
  store i64 %lnaVr, i64* %lnaVs, !tbaa !3
  %lnaVu = load i64, i64* %R4_Var
  %lnaVt = load i64*, i64** %Hp_Var
  %lnaVv = getelementptr inbounds i64, i64* %lnaVt, i32 -6
  store i64 %lnaVu, i64* %lnaVv, !tbaa !3
  %lnaVx = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saCA_info$def to i64
  %lnaVw = load i64*, i64** %Hp_Var
  %lnaVy = getelementptr inbounds i64, i64* %lnaVw, i32 -5
  store i64 %lnaVx, i64* %lnaVy, !tbaa !3
  %lnaVA = load i64, i64* %R2_Var
  %lnaVz = load i64*, i64** %Hp_Var
  %lnaVB = getelementptr inbounds i64, i64* %lnaVz, i32 -3
  store i64 %lnaVA, i64* %lnaVB, !tbaa !3
  %lnaVD = load i64, i64* %R4_Var
  %lnaVC = load i64*, i64** %Hp_Var
  %lnaVE = getelementptr inbounds i64, i64* %lnaVC, i32 -2
  store i64 %lnaVD, i64* %lnaVE, !tbaa !3
  %lnaVG = load i64, i64* %R5_Var
  %lnaVF = load i64*, i64** %Hp_Var
  %lnaVH = getelementptr inbounds i64, i64* %lnaVF, i32 -1
  store i64 %lnaVG, i64* %lnaVH, !tbaa !3
  %lnaVJ = load i64, i64* %R6_Var
  %lnaVI = load i64*, i64** %Hp_Var
  %lnaVK = getelementptr inbounds i64, i64* %lnaVI, i32 0
  store i64 %lnaVJ, i64* %lnaVK, !tbaa !3
  %lnaVL = load i64, i64* %R3_Var
  store i64 %lnaVL, i64* %lsaCl
  %lnaVM = load i64*, i64** %Hp_Var
  %lnaVN = getelementptr inbounds i64, i64* %lnaVM, i32 -8
  %lnaVO = ptrtoint i64* %lnaVN to i64
  store i64 %lnaVO, i64* %R3_Var
  %lnaVP = load i64*, i64** %Hp_Var
  %lnaVQ = getelementptr inbounds i64, i64* %lnaVP, i32 -5
  %lnaVR = ptrtoint i64* %lnaVQ to i64
  store i64 %lnaVR, i64* %R2_Var
  %lnaVS = load i64, i64* %lsaCl
  store i64 %lnaVS, i64* %R1_Var
  %lnaVT = bitcast i8* @stg_ap_pp_fast to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnaVU = load i64*, i64** %Hp_Var
  %lnaVV = load i64, i64* %R1_Var
  %lnaVW = load i64, i64* %R2_Var
  %lnaVX = load i64, i64* %R3_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnaVT( i64* %Base_Arg, i64* %Sp_Arg, i64* %lnaVU, i64 %lnaVV, i64 %lnaVW, i64 %lnaVX, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
caPO:
  %lnaVY = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 72, i64* %lnaVY, !tbaa !5
  %lnaVZ = load i64, i64* %R6_Var
  store i64 %lnaVZ, i64* %R6_Var
  %lnaW0 = load i64, i64* %R5_Var
  store i64 %lnaW0, i64* %R5_Var
  %lnaW1 = load i64, i64* %R4_Var
  store i64 %lnaW1, i64* %R4_Var
  %lnaW2 = load i64, i64* %R3_Var
  store i64 %lnaW2, i64* %R3_Var
  %lnaW3 = load i64, i64* %R2_Var
  store i64 %lnaW3, i64* %R2_Var
  %lnaW4 = ptrtoint %Main_zdwround4dp_closure_struct* @Main_zdwround4dp_closure$def to i64
  store i64 %lnaW4, i64* %R1_Var
  %lnaW5 = getelementptr inbounds i64, i64* %Base_Arg, i32 -1
  %lnaW6 = bitcast i64* %lnaW5 to i64*
  %lnaW7 = load i64, i64* %lnaW6, !tbaa !5
  %lnaW8 = inttoptr i64 %lnaW7 to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnaW9 = load i64*, i64** %Hp_Var
  %lnaWa = load i64, i64* %R1_Var
  %lnaWb = load i64, i64* %R2_Var
  %lnaWc = load i64, i64* %R3_Var
  %lnaWd = load i64, i64* %R4_Var
  %lnaWe = load i64, i64* %R5_Var
  %lnaWf = load i64, i64* %R6_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnaW8( i64* %Base_Arg, i64* %Sp_Arg, i64* %lnaW9, i64 %lnaWa, i64 %lnaWb, i64 %lnaWc, i64 %lnaWd, i64 %lnaWe, i64 %lnaWf, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
%Main_round4dp_closure_struct = type <{i64, i64}>
@Main_round4dp_closure$def = internal global %Main_round4dp_closure_struct<{i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_round4dp_info$def to i64), i64 0}>
@Main_round4dp_closure = alias i8, bitcast (%Main_round4dp_closure_struct* @Main_round4dp_closure$def to i8*)



==================== LLVM Code ====================
@Main_round4dp_info = alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_round4dp_info$def to i8*)
define ghccc void @Main_round4dp_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i64, i32, i32}><{i64 25769803802, i64 0, i32 14, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%Main_zdwround4dp_closure_struct* @Main_zdwround4dp_closure$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_round4dp_info$def to i64)) to i32),i32 0)}>
{
caWn:
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %R6_Var = alloca i64, i32 1
  store i64 %R6_Arg, i64* %R6_Var
  %R5_Var = alloca i64, i32 1
  store i64 %R5_Arg, i64* %R5_Var
  %R4_Var = alloca i64, i32 1
  store i64 %R4_Arg, i64* %R4_Var
  %R3_Var = alloca i64, i32 1
  store i64 %R3_Arg, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 %R2_Arg, i64* %R2_Var
  %lnaWB = load i64*, i64** %Sp_Var
  %lnaWC = getelementptr inbounds i64, i64* %lnaWB, i32 -3
  %lnaWD = ptrtoint i64* %lnaWC to i64
  %lnaWE = icmp ult i64 %lnaWD, %SpLim_Arg
  %lnaWF = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnaWE, i1 0 )
  br i1 %lnaWF, label %caWr, label %caWs
caWs:
  %lnaWH = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @caWk_info$def to i64
  %lnaWG = load i64*, i64** %Sp_Var
  %lnaWI = getelementptr inbounds i64, i64* %lnaWG, i32 -1
  store i64 %lnaWH, i64* %lnaWI, !tbaa !2
  %lnaWJ = load i64, i64* %R3_Var
  store i64 %lnaWJ, i64* %R1_Var
  %lnaWK = load i64*, i64** %Sp_Var
  %lnaWL = getelementptr inbounds i64, i64* %lnaWK, i32 -1
  %lnaWM = ptrtoint i64* %lnaWL to i64
  %lnaWN = inttoptr i64 %lnaWM to i64*
  store i64* %lnaWN, i64** %Sp_Var
  %lnaWO = load i64, i64* %R1_Var
  %lnaWP = and i64 %lnaWO, 7
  %lnaWQ = icmp ne i64 %lnaWP, 0
  br i1 %lnaWQ, label %uaWA, label %caWl
caWl:
  %lnaWS = load i64, i64* %R1_Var
  %lnaWT = inttoptr i64 %lnaWS to i64*
  %lnaWU = load i64, i64* %lnaWT, !tbaa !4
  %lnaWV = inttoptr i64 %lnaWU to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnaWW = load i64*, i64** %Sp_Var
  %lnaWX = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnaWV( i64* %Base_Arg, i64* %lnaWW, i64* %Hp_Arg, i64 %lnaWX, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
uaWA:
  %lnaWY = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @caWk_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnaWZ = load i64*, i64** %Sp_Var
  %lnaX0 = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnaWY( i64* %Base_Arg, i64* %lnaWZ, i64* %Hp_Arg, i64 %lnaX0, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
caWr:
  %lnaX1 = load i64, i64* %R6_Var
  store i64 %lnaX1, i64* %R6_Var
  %lnaX2 = load i64, i64* %R5_Var
  store i64 %lnaX2, i64* %R5_Var
  %lnaX3 = load i64, i64* %R4_Var
  store i64 %lnaX3, i64* %R4_Var
  %lnaX4 = load i64, i64* %R3_Var
  store i64 %lnaX4, i64* %R3_Var
  %lnaX5 = load i64, i64* %R2_Var
  store i64 %lnaX5, i64* %R2_Var
  %lnaX6 = ptrtoint %Main_round4dp_closure_struct* @Main_round4dp_closure$def to i64
  store i64 %lnaX6, i64* %R1_Var
  %lnaX7 = getelementptr inbounds i64, i64* %Base_Arg, i32 -1
  %lnaX8 = bitcast i64* %lnaX7 to i64*
  %lnaX9 = load i64, i64* %lnaX8, !tbaa !5
  %lnaXa = inttoptr i64 %lnaX9 to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnaXb = load i64*, i64** %Sp_Var
  %lnaXc = load i64, i64* %R1_Var
  %lnaXd = load i64, i64* %R2_Var
  %lnaXe = load i64, i64* %R3_Var
  %lnaXf = load i64, i64* %R4_Var
  %lnaXg = load i64, i64* %R5_Var
  %lnaXh = load i64, i64* %R6_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnaXa( i64* %Base_Arg, i64* %lnaXb, i64* %Hp_Arg, i64 %lnaXc, i64 %lnaXd, i64 %lnaXe, i64 %lnaXf, i64 %lnaXg, i64 %lnaXh, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@caWk_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @caWk_info$def to i8*)
define internal ghccc void @caWk_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 1, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%Main_zdwround4dp_closure_struct* @Main_zdwround4dp_closure$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @caWk_info$def to i64)) to i32),i32 0)}>
{
caWk:
  %lsaCJ = alloca i64, i32 1
  %lsaCN = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnaXj = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @caWq_info$def to i64
  %lnaXi = load i64*, i64** %Sp_Var
  %lnaXk = getelementptr inbounds i64, i64* %lnaXi, i32 -2
  store i64 %lnaXj, i64* %lnaXk, !tbaa !2
  %lnaXn = load i64, i64* %R1_Var
  %lnaXo = add i64 %lnaXn, 7
  %lnaXp = inttoptr i64 %lnaXo to i64*
  %lnaXq = load i64, i64* %lnaXp, !tbaa !4
  store i64 %lnaXq, i64* %lsaCJ
  %lnaXt = load i64, i64* %R1_Var
  %lnaXu = add i64 %lnaXt, 39
  %lnaXv = inttoptr i64 %lnaXu to i64*
  %lnaXw = load i64, i64* %lnaXv, !tbaa !4
  store i64 %lnaXw, i64* %lsaCN
  %lnaXz = load i64, i64* %R1_Var
  %lnaXA = add i64 %lnaXz, 15
  %lnaXB = inttoptr i64 %lnaXA to i64*
  %lnaXC = load i64, i64* %lnaXB, !tbaa !4
  store i64 %lnaXC, i64* %R1_Var
  %lnaXE = load i64, i64* %lsaCN
  %lnaXD = load i64*, i64** %Sp_Var
  %lnaXF = getelementptr inbounds i64, i64* %lnaXD, i32 -1
  store i64 %lnaXE, i64* %lnaXF, !tbaa !2
  %lnaXH = load i64, i64* %lsaCJ
  %lnaXG = load i64*, i64** %Sp_Var
  %lnaXI = getelementptr inbounds i64, i64* %lnaXG, i32 0
  store i64 %lnaXH, i64* %lnaXI, !tbaa !2
  %lnaXJ = load i64*, i64** %Sp_Var
  %lnaXK = getelementptr inbounds i64, i64* %lnaXJ, i32 -2
  %lnaXL = ptrtoint i64* %lnaXK to i64
  %lnaXM = inttoptr i64 %lnaXL to i64*
  store i64* %lnaXM, i64** %Sp_Var
  %lnaXN = load i64, i64* %R1_Var
  %lnaXO = and i64 %lnaXN, 7
  %lnaXP = icmp ne i64 %lnaXO, 0
  br i1 %lnaXP, label %uaWz, label %caWu
caWu:
  %lnaXR = load i64, i64* %R1_Var
  %lnaXS = inttoptr i64 %lnaXR to i64*
  %lnaXT = load i64, i64* %lnaXS, !tbaa !4
  %lnaXU = inttoptr i64 %lnaXT to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnaXV = load i64*, i64** %Sp_Var
  %lnaXW = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnaXU( i64* %Base_Arg, i64* %lnaXV, i64* %Hp_Arg, i64 %lnaXW, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
uaWz:
  %lnaXX = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @caWq_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnaXY = load i64*, i64** %Sp_Var
  %lnaXZ = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnaXX( i64* %Base_Arg, i64* %lnaXY, i64* %Hp_Arg, i64 %lnaXZ, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@caWq_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @caWq_info$def to i8*)
define internal ghccc void @caWq_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 3, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%Main_zdwround4dp_closure_struct* @Main_zdwround4dp_closure$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @caWq_info$def to i64)) to i32),i32 0)}>
{
caWq:
  %R6_Var = alloca i64, i32 1
  store i64 undef, i64* %R6_Var
  %R5_Var = alloca i64, i32 1
  store i64 undef, i64* %R5_Var
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnaY0 = load i64*, i64** %Sp_Var
  %lnaY1 = getelementptr inbounds i64, i64* %lnaY0, i32 3
  %lnaY2 = bitcast i64* %lnaY1 to i64*
  %lnaY3 = load i64, i64* %lnaY2, !tbaa !2
  store i64 %lnaY3, i64* %R6_Var
  %lnaY4 = load i64*, i64** %Sp_Var
  %lnaY5 = getelementptr inbounds i64, i64* %lnaY4, i32 1
  %lnaY6 = bitcast i64* %lnaY5 to i64*
  %lnaY7 = load i64, i64* %lnaY6, !tbaa !2
  store i64 %lnaY7, i64* %R5_Var
  %lnaY8 = add i64 %R1_Arg, 31
  %lnaY9 = inttoptr i64 %lnaY8 to i64*
  %lnaYa = load i64, i64* %lnaY9, !tbaa !4
  store i64 %lnaYa, i64* %R4_Var
  %lnaYb = add i64 %R1_Arg, 15
  %lnaYc = inttoptr i64 %lnaYb to i64*
  %lnaYd = load i64, i64* %lnaYc, !tbaa !4
  store i64 %lnaYd, i64* %R3_Var
  %lnaYe = load i64*, i64** %Sp_Var
  %lnaYf = getelementptr inbounds i64, i64* %lnaYe, i32 2
  %lnaYg = bitcast i64* %lnaYf to i64*
  %lnaYh = load i64, i64* %lnaYg, !tbaa !2
  store i64 %lnaYh, i64* %R2_Var
  %lnaYi = load i64*, i64** %Sp_Var
  %lnaYj = getelementptr inbounds i64, i64* %lnaYi, i32 4
  %lnaYk = ptrtoint i64* %lnaYj to i64
  %lnaYl = inttoptr i64 %lnaYk to i64*
  store i64* %lnaYl, i64** %Sp_Var
  %lnaYm = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_zdwround4dp_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnaYn = load i64*, i64** %Sp_Var
  %lnaYo = load i64, i64* %R2_Var
  %lnaYp = load i64, i64* %R3_Var
  %lnaYq = load i64, i64* %R4_Var
  %lnaYr = load i64, i64* %R5_Var
  %lnaYs = load i64, i64* %R6_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnaYm( i64* %Base_Arg, i64* %lnaYn, i64* %Hp_Arg, i64 %R1_Arg, i64 %lnaYo, i64 %lnaYp, i64 %lnaYq, i64 %lnaYr, i64 %lnaYs, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
%Main_repeatNTimes1_closure_struct = type <{i64, i64}>
@Main_repeatNTimes1_closure$def = internal global %Main_repeatNTimes1_closure_struct<{i64 ptrtoint (i8* @integerzmgmp_GHCziIntegerziType_Szh_con_info to i64), i64 0}>
@Main_repeatNTimes1_closure = alias i8, bitcast (%Main_repeatNTimes1_closure_struct* @Main_repeatNTimes1_closure$def to i8*)



==================== LLVM Code ====================
%Main_zdwrepeatNTimes_closure_struct = type <{i64}>
@Main_zdwrepeatNTimes_closure$def = internal global %Main_zdwrepeatNTimes_closure_struct<{i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_zdwrepeatNTimes_info$def to i64)}>
@Main_zdwrepeatNTimes_closure = alias i8, bitcast (%Main_zdwrepeatNTimes_closure_struct* @Main_zdwrepeatNTimes_closure$def to i8*)



==================== LLVM Code ====================
@saD0_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saD0_info$def to i8*)
define internal ghccc void @saD0_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 1, i32 16, i32 0}>
{
caYB:
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lnaZz = load i64*, i64** %Sp_Var
  %lnaZA = getelementptr inbounds i64, i64* %lnaZz, i32 -4
  %lnaZB = ptrtoint i64* %lnaZA to i64
  %lnaZC = icmp ult i64 %lnaZB, %SpLim_Arg
  %lnaZD = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnaZC, i1 0 )
  br i1 %lnaZD, label %caYC, label %caYD
caYD:
  %lnaZF = ptrtoint i8* @stg_upd_frame_info to i64
  %lnaZE = load i64*, i64** %Sp_Var
  %lnaZG = getelementptr inbounds i64, i64* %lnaZE, i32 -2
  store i64 %lnaZF, i64* %lnaZG, !tbaa !2
  %lnaZI = load i64, i64* %R1_Var
  %lnaZH = load i64*, i64** %Sp_Var
  %lnaZJ = getelementptr inbounds i64, i64* %lnaZH, i32 -1
  store i64 %lnaZI, i64* %lnaZJ, !tbaa !2
  %lnaZM = load i64, i64* %R1_Var
  %lnaZN = add i64 %lnaZM, 16
  %lnaZO = inttoptr i64 %lnaZN to i64*
  %lnaZP = load i64, i64* %lnaZO, !tbaa !4
  store i64 %lnaZP, i64* %R2_Var
  %lnaZR = ptrtoint i8* @stg_ap_p_info to i64
  %lnaZQ = load i64*, i64** %Sp_Var
  %lnaZS = getelementptr inbounds i64, i64* %lnaZQ, i32 -4
  store i64 %lnaZR, i64* %lnaZS, !tbaa !2
  %lnaZU = ptrtoint %Main_repeatNTimes2_closure_struct* @Main_repeatNTimes2_closure$def to i64
  %lnaZV = add i64 %lnaZU, 1
  %lnaZT = load i64*, i64** %Sp_Var
  %lnaZW = getelementptr inbounds i64, i64* %lnaZT, i32 -3
  store i64 %lnaZV, i64* %lnaZW, !tbaa !2
  %lnaZX = load i64*, i64** %Sp_Var
  %lnaZY = getelementptr inbounds i64, i64* %lnaZX, i32 -4
  %lnaZZ = ptrtoint i64* %lnaZY to i64
  %lnb00 = inttoptr i64 %lnaZZ to i64*
  store i64* %lnb00, i64** %Sp_Var
  %lnb01 = bitcast i8* @base_GHCziNum_fromInteger_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnb02 = load i64*, i64** %Sp_Var
  %lnb03 = load i64, i64* %R1_Var
  %lnb04 = load i64, i64* %R2_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnb01( i64* %Base_Arg, i64* %lnb02, i64* %Hp_Arg, i64 %lnb03, i64 %lnb04, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
caYC:
  %lnb05 = load i64, i64* %R1_Var
  store i64 %lnb05, i64* %R1_Var
  %lnb06 = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lnb07 = bitcast i64* %lnb06 to i64*
  %lnb08 = load i64, i64* %lnb07, !tbaa !5
  %lnb09 = inttoptr i64 %lnb08 to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnb0a = load i64*, i64** %Sp_Var
  %lnb0b = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnb09( i64* %Base_Arg, i64* %lnb0a, i64* %Hp_Arg, i64 %lnb0b, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saD1_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saD1_info$def to i8*)
define internal ghccc void @saD1_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 1, i32 16, i32 0}>
{
caYI:
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lnb0c = load i64*, i64** %Sp_Var
  %lnb0d = getelementptr inbounds i64, i64* %lnb0c, i32 -4
  %lnb0e = ptrtoint i64* %lnb0d to i64
  %lnb0f = icmp ult i64 %lnb0e, %SpLim_Arg
  %lnb0g = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnb0f, i1 0 )
  br i1 %lnb0g, label %caYJ, label %caYK
caYK:
  %lnb0i = ptrtoint i8* @stg_upd_frame_info to i64
  %lnb0h = load i64*, i64** %Sp_Var
  %lnb0j = getelementptr inbounds i64, i64* %lnb0h, i32 -2
  store i64 %lnb0i, i64* %lnb0j, !tbaa !2
  %lnb0l = load i64, i64* %R1_Var
  %lnb0k = load i64*, i64** %Sp_Var
  %lnb0m = getelementptr inbounds i64, i64* %lnb0k, i32 -1
  store i64 %lnb0l, i64* %lnb0m, !tbaa !2
  %lnb0p = load i64, i64* %R1_Var
  %lnb0q = add i64 %lnb0p, 16
  %lnb0r = inttoptr i64 %lnb0q to i64*
  %lnb0s = load i64, i64* %lnb0r, !tbaa !4
  store i64 %lnb0s, i64* %R2_Var
  %lnb0u = ptrtoint i8* @stg_ap_p_info to i64
  %lnb0t = load i64*, i64** %Sp_Var
  %lnb0v = getelementptr inbounds i64, i64* %lnb0t, i32 -4
  store i64 %lnb0u, i64* %lnb0v, !tbaa !2
  %lnb0x = ptrtoint i8* @ghczmprim_GHCziTuple_Z0T_closure to i64
  %lnb0y = add i64 %lnb0x, 1
  %lnb0w = load i64*, i64** %Sp_Var
  %lnb0z = getelementptr inbounds i64, i64* %lnb0w, i32 -3
  store i64 %lnb0y, i64* %lnb0z, !tbaa !2
  %lnb0A = load i64*, i64** %Sp_Var
  %lnb0B = getelementptr inbounds i64, i64* %lnb0A, i32 -4
  %lnb0C = ptrtoint i64* %lnb0B to i64
  %lnb0D = inttoptr i64 %lnb0C to i64*
  store i64* %lnb0D, i64** %Sp_Var
  %lnb0E = bitcast i8* @base_GHCziBase_return_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnb0F = load i64*, i64** %Sp_Var
  %lnb0G = load i64, i64* %R1_Var
  %lnb0H = load i64, i64* %R2_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnb0E( i64* %Base_Arg, i64* %lnb0F, i64* %Hp_Arg, i64 %lnb0G, i64 %lnb0H, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
caYJ:
  %lnb0I = load i64, i64* %R1_Var
  store i64 %lnb0I, i64* %R1_Var
  %lnb0J = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lnb0K = bitcast i64* %lnb0J to i64*
  %lnb0L = load i64, i64* %lnb0K, !tbaa !5
  %lnb0M = inttoptr i64 %lnb0L to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnb0N = load i64*, i64** %Sp_Var
  %lnb0O = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnb0M( i64* %Base_Arg, i64* %lnb0N, i64* %Hp_Arg, i64 %lnb0O, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saD2_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saD2_info$def to i8*)
define internal ghccc void @saD2_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 1, i32 16, i32 0}>
{
caYP:
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lnb0P = load i64*, i64** %Sp_Var
  %lnb0Q = getelementptr inbounds i64, i64* %lnb0P, i32 -4
  %lnb0R = ptrtoint i64* %lnb0Q to i64
  %lnb0S = icmp ult i64 %lnb0R, %SpLim_Arg
  %lnb0T = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnb0S, i1 0 )
  br i1 %lnb0T, label %caYQ, label %caYR
caYR:
  %lnb0V = ptrtoint i8* @stg_upd_frame_info to i64
  %lnb0U = load i64*, i64** %Sp_Var
  %lnb0W = getelementptr inbounds i64, i64* %lnb0U, i32 -2
  store i64 %lnb0V, i64* %lnb0W, !tbaa !2
  %lnb0Y = load i64, i64* %R1_Var
  %lnb0X = load i64*, i64** %Sp_Var
  %lnb0Z = getelementptr inbounds i64, i64* %lnb0X, i32 -1
  store i64 %lnb0Y, i64* %lnb0Z, !tbaa !2
  %lnb12 = load i64, i64* %R1_Var
  %lnb13 = add i64 %lnb12, 16
  %lnb14 = inttoptr i64 %lnb13 to i64*
  %lnb15 = load i64, i64* %lnb14, !tbaa !4
  store i64 %lnb15, i64* %R2_Var
  %lnb17 = ptrtoint i8* @stg_ap_p_info to i64
  %lnb16 = load i64*, i64** %Sp_Var
  %lnb18 = getelementptr inbounds i64, i64* %lnb16, i32 -4
  store i64 %lnb17, i64* %lnb18, !tbaa !2
  %lnb1a = ptrtoint %Main_repeatNTimes1_closure_struct* @Main_repeatNTimes1_closure$def to i64
  %lnb1b = add i64 %lnb1a, 1
  %lnb19 = load i64*, i64** %Sp_Var
  %lnb1c = getelementptr inbounds i64, i64* %lnb19, i32 -3
  store i64 %lnb1b, i64* %lnb1c, !tbaa !2
  %lnb1d = load i64*, i64** %Sp_Var
  %lnb1e = getelementptr inbounds i64, i64* %lnb1d, i32 -4
  %lnb1f = ptrtoint i64* %lnb1e to i64
  %lnb1g = inttoptr i64 %lnb1f to i64*
  store i64* %lnb1g, i64** %Sp_Var
  %lnb1h = bitcast i8* @base_GHCziNum_fromInteger_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnb1i = load i64*, i64** %Sp_Var
  %lnb1j = load i64, i64* %R1_Var
  %lnb1k = load i64, i64* %R2_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnb1h( i64* %Base_Arg, i64* %lnb1i, i64* %Hp_Arg, i64 %lnb1j, i64 %lnb1k, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
caYQ:
  %lnb1l = load i64, i64* %R1_Var
  store i64 %lnb1l, i64* %R1_Var
  %lnb1m = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lnb1n = bitcast i64* %lnb1m to i64*
  %lnb1o = load i64, i64* %lnb1n, !tbaa !5
  %lnb1p = inttoptr i64 %lnb1o to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnb1q = load i64*, i64** %Sp_Var
  %lnb1r = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnb1p( i64* %Base_Arg, i64* %lnb1q, i64* %Hp_Arg, i64 %lnb1r, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saD7_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saD7_info$def to i8*)
define internal ghccc void @saD7_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 3, i32 15, i32 0}>
{
caZ9:
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lnb1s = load i64*, i64** %Sp_Var
  %lnb1t = getelementptr inbounds i64, i64* %lnb1s, i32 -5
  %lnb1u = ptrtoint i64* %lnb1t to i64
  %lnb1v = icmp ult i64 %lnb1u, %SpLim_Arg
  %lnb1w = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnb1v, i1 0 )
  br i1 %lnb1w, label %caZa, label %caZb
caZb:
  %lnb1y = ptrtoint i8* @stg_upd_frame_info to i64
  %lnb1x = load i64*, i64** %Sp_Var
  %lnb1z = getelementptr inbounds i64, i64* %lnb1x, i32 -2
  store i64 %lnb1y, i64* %lnb1z, !tbaa !2
  %lnb1B = load i64, i64* %R1_Var
  %lnb1A = load i64*, i64** %Sp_Var
  %lnb1C = getelementptr inbounds i64, i64* %lnb1A, i32 -1
  store i64 %lnb1B, i64* %lnb1C, !tbaa !2
  %lnb1F = load i64, i64* %R1_Var
  %lnb1G = add i64 %lnb1F, 16
  %lnb1H = inttoptr i64 %lnb1G to i64*
  %lnb1I = load i64, i64* %lnb1H, !tbaa !4
  store i64 %lnb1I, i64* %R2_Var
  %lnb1K = ptrtoint i8* @stg_ap_pp_info to i64
  %lnb1J = load i64*, i64** %Sp_Var
  %lnb1L = getelementptr inbounds i64, i64* %lnb1J, i32 -5
  store i64 %lnb1K, i64* %lnb1L, !tbaa !2
  %lnb1P = load i64, i64* %R1_Var
  %lnb1Q = add i64 %lnb1P, 32
  %lnb1R = inttoptr i64 %lnb1Q to i64*
  %lnb1S = load i64, i64* %lnb1R, !tbaa !4
  %lnb1M = load i64*, i64** %Sp_Var
  %lnb1T = getelementptr inbounds i64, i64* %lnb1M, i32 -4
  store i64 %lnb1S, i64* %lnb1T, !tbaa !2
  %lnb1X = load i64, i64* %R1_Var
  %lnb1Y = add i64 %lnb1X, 24
  %lnb1Z = inttoptr i64 %lnb1Y to i64*
  %lnb20 = load i64, i64* %lnb1Z, !tbaa !4
  %lnb1U = load i64*, i64** %Sp_Var
  %lnb21 = getelementptr inbounds i64, i64* %lnb1U, i32 -3
  store i64 %lnb20, i64* %lnb21, !tbaa !2
  %lnb22 = load i64*, i64** %Sp_Var
  %lnb23 = getelementptr inbounds i64, i64* %lnb22, i32 -5
  %lnb24 = ptrtoint i64* %lnb23 to i64
  %lnb25 = inttoptr i64 %lnb24 to i64*
  store i64* %lnb25, i64** %Sp_Var
  %lnb26 = bitcast i8* @base_GHCziNum_zm_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnb27 = load i64*, i64** %Sp_Var
  %lnb28 = load i64, i64* %R1_Var
  %lnb29 = load i64, i64* %R2_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnb26( i64* %Base_Arg, i64* %lnb27, i64* %Hp_Arg, i64 %lnb28, i64 %lnb29, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
caZa:
  %lnb2a = load i64, i64* %R1_Var
  store i64 %lnb2a, i64* %R1_Var
  %lnb2b = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lnb2c = bitcast i64* %lnb2b to i64*
  %lnb2d = load i64, i64* %lnb2c, !tbaa !5
  %lnb2e = inttoptr i64 %lnb2d to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnb2f = load i64*, i64** %Sp_Var
  %lnb2g = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnb2e( i64* %Base_Arg, i64* %lnb2f, i64* %Hp_Arg, i64 %lnb2g, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saD8_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saD8_info$def to i8*)
define internal ghccc void @saD8_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 5, i32 15, i32 0}>
{
caZc:
  %lsaD8 = alloca i64, i32 1
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %lsaCW = alloca i64, i32 1
  %lsaD0 = alloca i64, i32 1
  %lsaD3 = alloca i64, i32 1
  %lsaD4 = alloca i64, i32 1
  %lsaD5 = alloca i64, i32 1
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnb2h = load i64, i64* %R1_Var
  store i64 %lnb2h, i64* %lsaD8
  %lnb2i = load i64*, i64** %Sp_Var
  %lnb2j = getelementptr inbounds i64, i64* %lnb2i, i32 -2
  %lnb2k = ptrtoint i64* %lnb2j to i64
  %lnb2l = icmp ult i64 %lnb2k, %SpLim_Arg
  %lnb2m = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnb2l, i1 0 )
  br i1 %lnb2m, label %caZd, label %caZe
caZe:
  %lnb2n = load i64*, i64** %Hp_Var
  %lnb2o = getelementptr inbounds i64, i64* %lnb2n, i32 5
  %lnb2p = ptrtoint i64* %lnb2o to i64
  %lnb2q = inttoptr i64 %lnb2p to i64*
  store i64* %lnb2q, i64** %Hp_Var
  %lnb2r = load i64*, i64** %Hp_Var
  %lnb2s = ptrtoint i64* %lnb2r to i64
  %lnb2t = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lnb2u = bitcast i64* %lnb2t to i64*
  %lnb2v = load i64, i64* %lnb2u, !tbaa !5
  %lnb2w = icmp ugt i64 %lnb2s, %lnb2v
  %lnb2x = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnb2w, i1 0 )
  br i1 %lnb2x, label %caZg, label %caZf
caZf:
  %lnb2z = ptrtoint i8* @stg_upd_frame_info to i64
  %lnb2y = load i64*, i64** %Sp_Var
  %lnb2A = getelementptr inbounds i64, i64* %lnb2y, i32 -2
  store i64 %lnb2z, i64* %lnb2A, !tbaa !2
  %lnb2C = load i64, i64* %lsaD8
  %lnb2B = load i64*, i64** %Sp_Var
  %lnb2D = getelementptr inbounds i64, i64* %lnb2B, i32 -1
  store i64 %lnb2C, i64* %lnb2D, !tbaa !2
  %lnb2E = load i64, i64* %lsaD8
  %lnb2F = add i64 %lnb2E, 16
  %lnb2G = inttoptr i64 %lnb2F to i64*
  %lnb2H = load i64, i64* %lnb2G, !tbaa !1
  store i64 %lnb2H, i64* %lsaCW
  %lnb2I = load i64, i64* %lsaD8
  %lnb2J = add i64 %lnb2I, 24
  %lnb2K = inttoptr i64 %lnb2J to i64*
  %lnb2L = load i64, i64* %lnb2K, !tbaa !1
  store i64 %lnb2L, i64* %lsaD0
  %lnb2M = load i64, i64* %lsaD8
  %lnb2N = add i64 %lnb2M, 32
  %lnb2O = inttoptr i64 %lnb2N to i64*
  %lnb2P = load i64, i64* %lnb2O, !tbaa !1
  store i64 %lnb2P, i64* %lsaD3
  %lnb2Q = load i64, i64* %lsaD8
  %lnb2R = add i64 %lnb2Q, 40
  %lnb2S = inttoptr i64 %lnb2R to i64*
  %lnb2T = load i64, i64* %lnb2S, !tbaa !1
  store i64 %lnb2T, i64* %lsaD4
  %lnb2U = load i64, i64* %lsaD8
  %lnb2V = add i64 %lnb2U, 48
  %lnb2W = inttoptr i64 %lnb2V to i64*
  %lnb2X = load i64, i64* %lnb2W, !tbaa !1
  store i64 %lnb2X, i64* %lsaD5
  %lnb2Z = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saD7_info$def to i64
  %lnb2Y = load i64*, i64** %Hp_Var
  %lnb30 = getelementptr inbounds i64, i64* %lnb2Y, i32 -4
  store i64 %lnb2Z, i64* %lnb30, !tbaa !3
  %lnb32 = load i64, i64* %lsaCW
  %lnb31 = load i64*, i64** %Hp_Var
  %lnb33 = getelementptr inbounds i64, i64* %lnb31, i32 -2
  store i64 %lnb32, i64* %lnb33, !tbaa !3
  %lnb35 = load i64, i64* %lsaD0
  %lnb34 = load i64*, i64** %Hp_Var
  %lnb36 = getelementptr inbounds i64, i64* %lnb34, i32 -1
  store i64 %lnb35, i64* %lnb36, !tbaa !3
  %lnb38 = load i64, i64* %lsaD4
  %lnb37 = load i64*, i64** %Hp_Var
  %lnb39 = getelementptr inbounds i64, i64* %lnb37, i32 0
  store i64 %lnb38, i64* %lnb39, !tbaa !3
  %lnb3a = load i64, i64* %lsaD5
  store i64 %lnb3a, i64* %R3_Var
  %lnb3b = load i64*, i64** %Hp_Var
  %lnb3c = getelementptr inbounds i64, i64* %lnb3b, i32 -4
  %lnb3d = ptrtoint i64* %lnb3c to i64
  store i64 %lnb3d, i64* %R2_Var
  %lnb3e = load i64, i64* %lsaD3
  store i64 %lnb3e, i64* %R1_Var
  %lnb3f = load i64*, i64** %Sp_Var
  %lnb3g = getelementptr inbounds i64, i64* %lnb3f, i32 -2
  %lnb3h = ptrtoint i64* %lnb3g to i64
  %lnb3i = inttoptr i64 %lnb3h to i64*
  store i64* %lnb3i, i64** %Sp_Var
  %lnb3j = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saD3_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnb3k = load i64*, i64** %Sp_Var
  %lnb3l = load i64*, i64** %Hp_Var
  %lnb3m = load i64, i64* %R1_Var
  %lnb3n = load i64, i64* %R2_Var
  %lnb3o = load i64, i64* %R3_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnb3j( i64* %Base_Arg, i64* %lnb3k, i64* %lnb3l, i64 %lnb3m, i64 %lnb3n, i64 %lnb3o, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
caZg:
  %lnb3p = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 40, i64* %lnb3p, !tbaa !5
  br label %caZd
caZd:
  %lnb3q = load i64, i64* %lsaD8
  store i64 %lnb3q, i64* %R1_Var
  %lnb3r = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lnb3s = bitcast i64* %lnb3r to i64*
  %lnb3t = load i64, i64* %lnb3s, !tbaa !5
  %lnb3u = inttoptr i64 %lnb3t to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnb3v = load i64*, i64** %Sp_Var
  %lnb3w = load i64*, i64** %Hp_Var
  %lnb3x = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnb3u( i64* %Base_Arg, i64* %lnb3v, i64* %lnb3w, i64 %lnb3x, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saD3_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saD3_info$def to i8*)
define internal ghccc void @saD3_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i64, i32, i32}><{i64 8589934607, i64 6, i32 8, i32 0}>
{
caZl:
  %lsaD5 = alloca i64, i32 1
  %R3_Var = alloca i64, i32 1
  store i64 %R3_Arg, i64* %R3_Var
  %lsaD4 = alloca i64, i32 1
  %R2_Var = alloca i64, i32 1
  store i64 %R2_Arg, i64* %R2_Var
  %lsaD3 = alloca i64, i32 1
  %lsaCW = alloca i64, i32 1
  %lsaCX = alloca i64, i32 1
  %lsaD0 = alloca i64, i32 1
  %lsaD1 = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnb3y = load i64*, i64** %Sp_Var
  %lnb3z = getelementptr inbounds i64, i64* %lnb3y, i32 -8
  %lnb3A = ptrtoint i64* %lnb3z to i64
  %lnb3B = icmp ult i64 %lnb3A, %SpLim_Arg
  %lnb3C = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnb3B, i1 0 )
  br i1 %lnb3C, label %caZm, label %caZn
caZn:
  %lnb3E = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @caYX_info$def to i64
  %lnb3D = load i64*, i64** %Sp_Var
  %lnb3F = getelementptr inbounds i64, i64* %lnb3D, i32 -8
  store i64 %lnb3E, i64* %lnb3F, !tbaa !2
  %lnb3G = load i64, i64* %R3_Var
  store i64 %lnb3G, i64* %lsaD5
  %lnb3J = load i64, i64* %R1_Var
  %lnb3K = add i64 %lnb3J, 46
  %lnb3L = inttoptr i64 %lnb3K to i64*
  %lnb3M = load i64, i64* %lnb3L, !tbaa !4
  store i64 %lnb3M, i64* %R3_Var
  %lnb3N = load i64, i64* %R2_Var
  store i64 %lnb3N, i64* %lsaD4
  %lnb3O = load i64, i64* %R2_Var
  store i64 %lnb3O, i64* %R2_Var
  %lnb3P = load i64, i64* %R1_Var
  store i64 %lnb3P, i64* %lsaD3
  %lnb3S = load i64, i64* %R1_Var
  %lnb3T = add i64 %lnb3S, 14
  %lnb3U = inttoptr i64 %lnb3T to i64*
  %lnb3V = load i64, i64* %lnb3U, !tbaa !4
  store i64 %lnb3V, i64* %lsaCW
  %lnb3Y = load i64, i64* %R1_Var
  %lnb3Z = add i64 %lnb3Y, 22
  %lnb40 = inttoptr i64 %lnb3Z to i64*
  %lnb41 = load i64, i64* %lnb40, !tbaa !4
  store i64 %lnb41, i64* %lsaCX
  %lnb44 = load i64, i64* %R1_Var
  %lnb45 = add i64 %lnb44, 30
  %lnb46 = inttoptr i64 %lnb45 to i64*
  %lnb47 = load i64, i64* %lnb46, !tbaa !4
  store i64 %lnb47, i64* %lsaD0
  %lnb4a = load i64, i64* %R1_Var
  %lnb4b = add i64 %lnb4a, 38
  %lnb4c = inttoptr i64 %lnb4b to i64*
  %lnb4d = load i64, i64* %lnb4c, !tbaa !4
  store i64 %lnb4d, i64* %lsaD1
  %lnb4g = load i64, i64* %R1_Var
  %lnb4h = add i64 %lnb4g, 6
  %lnb4i = inttoptr i64 %lnb4h to i64*
  %lnb4j = load i64, i64* %lnb4i, !tbaa !4
  store i64 %lnb4j, i64* %R1_Var
  %lnb4l = load i64, i64* %lsaCW
  %lnb4k = load i64*, i64** %Sp_Var
  %lnb4m = getelementptr inbounds i64, i64* %lnb4k, i32 -7
  store i64 %lnb4l, i64* %lnb4m, !tbaa !2
  %lnb4o = load i64, i64* %lsaCX
  %lnb4n = load i64*, i64** %Sp_Var
  %lnb4p = getelementptr inbounds i64, i64* %lnb4n, i32 -6
  store i64 %lnb4o, i64* %lnb4p, !tbaa !2
  %lnb4r = load i64, i64* %lsaD0
  %lnb4q = load i64*, i64** %Sp_Var
  %lnb4s = getelementptr inbounds i64, i64* %lnb4q, i32 -5
  store i64 %lnb4r, i64* %lnb4s, !tbaa !2
  %lnb4u = load i64, i64* %lsaD1
  %lnb4t = load i64*, i64** %Sp_Var
  %lnb4v = getelementptr inbounds i64, i64* %lnb4t, i32 -4
  store i64 %lnb4u, i64* %lnb4v, !tbaa !2
  %lnb4x = load i64, i64* %lsaD3
  %lnb4w = load i64*, i64** %Sp_Var
  %lnb4y = getelementptr inbounds i64, i64* %lnb4w, i32 -3
  store i64 %lnb4x, i64* %lnb4y, !tbaa !2
  %lnb4A = load i64, i64* %lsaD4
  %lnb4z = load i64*, i64** %Sp_Var
  %lnb4B = getelementptr inbounds i64, i64* %lnb4z, i32 -2
  store i64 %lnb4A, i64* %lnb4B, !tbaa !2
  %lnb4D = load i64, i64* %lsaD5
  %lnb4C = load i64*, i64** %Sp_Var
  %lnb4E = getelementptr inbounds i64, i64* %lnb4C, i32 -1
  store i64 %lnb4D, i64* %lnb4E, !tbaa !2
  %lnb4F = load i64*, i64** %Sp_Var
  %lnb4G = getelementptr inbounds i64, i64* %lnb4F, i32 -8
  %lnb4H = ptrtoint i64* %lnb4G to i64
  %lnb4I = inttoptr i64 %lnb4H to i64*
  store i64* %lnb4I, i64** %Sp_Var
  %lnb4J = bitcast i8* @stg_ap_pp_fast to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnb4K = load i64*, i64** %Sp_Var
  %lnb4L = load i64, i64* %R1_Var
  %lnb4M = load i64, i64* %R2_Var
  %lnb4N = load i64, i64* %R3_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnb4J( i64* %Base_Arg, i64* %lnb4K, i64* %Hp_Arg, i64 %lnb4L, i64 %lnb4M, i64 %lnb4N, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
caZm:
  %lnb4O = load i64, i64* %R3_Var
  store i64 %lnb4O, i64* %R3_Var
  %lnb4P = load i64, i64* %R2_Var
  store i64 %lnb4P, i64* %R2_Var
  %lnb4Q = load i64, i64* %R1_Var
  store i64 %lnb4Q, i64* %R1_Var
  %lnb4R = getelementptr inbounds i64, i64* %Base_Arg, i32 -1
  %lnb4S = bitcast i64* %lnb4R to i64*
  %lnb4T = load i64, i64* %lnb4S, !tbaa !5
  %lnb4U = inttoptr i64 %lnb4T to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnb4V = load i64*, i64** %Sp_Var
  %lnb4W = load i64, i64* %R1_Var
  %lnb4X = load i64, i64* %R2_Var
  %lnb4Y = load i64, i64* %R3_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnb4U( i64* %Base_Arg, i64* %lnb4V, i64* %Hp_Arg, i64 %lnb4W, i64 %lnb4X, i64 %lnb4Y, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@caYX_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @caYX_info$def to i8*)
define internal ghccc void @caYX_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 7, i32 30, i32 0}>
{
caYX:
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %lsaD5 = alloca i64, i32 1
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lnb4Z = load i64, i64* %R1_Var
  %lnb50 = and i64 %lnb4Z, 7
  switch i64 %lnb50, label %caZi [i64 1, label %caZi
                                  i64 2, label %caZj]
caZi:
  %lnb51 = load i64*, i64** %Hp_Var
  %lnb52 = getelementptr inbounds i64, i64* %lnb51, i32 7
  %lnb53 = ptrtoint i64* %lnb52 to i64
  %lnb54 = inttoptr i64 %lnb53 to i64*
  store i64* %lnb54, i64** %Hp_Var
  %lnb55 = load i64*, i64** %Hp_Var
  %lnb56 = ptrtoint i64* %lnb55 to i64
  %lnb57 = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lnb58 = bitcast i64* %lnb57 to i64*
  %lnb59 = load i64, i64* %lnb58, !tbaa !5
  %lnb5a = icmp ugt i64 %lnb56, %lnb59
  %lnb5b = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnb5a, i1 0 )
  br i1 %lnb5b, label %caZq, label %caZp
caZp:
  %lnb5d = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saD8_info$def to i64
  %lnb5c = load i64*, i64** %Hp_Var
  %lnb5e = getelementptr inbounds i64, i64* %lnb5c, i32 -6
  store i64 %lnb5d, i64* %lnb5e, !tbaa !3
  %lnb5g = load i64*, i64** %Sp_Var
  %lnb5h = getelementptr inbounds i64, i64* %lnb5g, i32 1
  %lnb5i = bitcast i64* %lnb5h to i64*
  %lnb5j = load i64, i64* %lnb5i, !tbaa !2
  %lnb5f = load i64*, i64** %Hp_Var
  %lnb5k = getelementptr inbounds i64, i64* %lnb5f, i32 -4
  store i64 %lnb5j, i64* %lnb5k, !tbaa !3
  %lnb5m = load i64*, i64** %Sp_Var
  %lnb5n = getelementptr inbounds i64, i64* %lnb5m, i32 3
  %lnb5o = bitcast i64* %lnb5n to i64*
  %lnb5p = load i64, i64* %lnb5o, !tbaa !2
  %lnb5l = load i64*, i64** %Hp_Var
  %lnb5q = getelementptr inbounds i64, i64* %lnb5l, i32 -3
  store i64 %lnb5p, i64* %lnb5q, !tbaa !3
  %lnb5s = load i64*, i64** %Sp_Var
  %lnb5t = getelementptr inbounds i64, i64* %lnb5s, i32 5
  %lnb5u = bitcast i64* %lnb5t to i64*
  %lnb5v = load i64, i64* %lnb5u, !tbaa !2
  %lnb5r = load i64*, i64** %Hp_Var
  %lnb5w = getelementptr inbounds i64, i64* %lnb5r, i32 -2
  store i64 %lnb5v, i64* %lnb5w, !tbaa !3
  %lnb5y = load i64*, i64** %Sp_Var
  %lnb5z = getelementptr inbounds i64, i64* %lnb5y, i32 6
  %lnb5A = bitcast i64* %lnb5z to i64*
  %lnb5B = load i64, i64* %lnb5A, !tbaa !2
  %lnb5x = load i64*, i64** %Hp_Var
  %lnb5C = getelementptr inbounds i64, i64* %lnb5x, i32 -1
  store i64 %lnb5B, i64* %lnb5C, !tbaa !3
  %lnb5D = load i64*, i64** %Sp_Var
  %lnb5E = getelementptr inbounds i64, i64* %lnb5D, i32 7
  %lnb5F = bitcast i64* %lnb5E to i64*
  %lnb5G = load i64, i64* %lnb5F, !tbaa !2
  store i64 %lnb5G, i64* %lsaD5
  %lnb5I = load i64, i64* %lsaD5
  %lnb5H = load i64*, i64** %Hp_Var
  %lnb5J = getelementptr inbounds i64, i64* %lnb5H, i32 0
  store i64 %lnb5I, i64* %lnb5J, !tbaa !3
  %lnb5K = load i64*, i64** %Sp_Var
  %lnb5L = getelementptr inbounds i64, i64* %lnb5K, i32 2
  %lnb5M = bitcast i64* %lnb5L to i64*
  %lnb5N = load i64, i64* %lnb5M, !tbaa !2
  store i64 %lnb5N, i64* %R2_Var
  %lnb5P = ptrtoint i8* @stg_ap_pp_info to i64
  %lnb5O = load i64*, i64** %Sp_Var
  %lnb5Q = getelementptr inbounds i64, i64* %lnb5O, i32 5
  store i64 %lnb5P, i64* %lnb5Q, !tbaa !2
  %lnb5S = load i64, i64* %lsaD5
  %lnb5R = load i64*, i64** %Sp_Var
  %lnb5T = getelementptr inbounds i64, i64* %lnb5R, i32 6
  store i64 %lnb5S, i64* %lnb5T, !tbaa !2
  %lnb5V = load i64*, i64** %Hp_Var
  %lnb5W = getelementptr inbounds i64, i64* %lnb5V, i32 -6
  %lnb5X = ptrtoint i64* %lnb5W to i64
  %lnb5U = load i64*, i64** %Sp_Var
  %lnb5Y = getelementptr inbounds i64, i64* %lnb5U, i32 7
  store i64 %lnb5X, i64* %lnb5Y, !tbaa !2
  %lnb5Z = load i64*, i64** %Sp_Var
  %lnb60 = getelementptr inbounds i64, i64* %lnb5Z, i32 5
  %lnb61 = ptrtoint i64* %lnb60 to i64
  %lnb62 = inttoptr i64 %lnb61 to i64*
  store i64* %lnb62, i64** %Sp_Var
  %lnb63 = bitcast i8* @base_GHCziBase_zgzg_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnb64 = load i64*, i64** %Sp_Var
  %lnb65 = load i64*, i64** %Hp_Var
  %lnb66 = load i64, i64* %R1_Var
  %lnb67 = load i64, i64* %R2_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnb63( i64* %Base_Arg, i64* %lnb64, i64* %lnb65, i64 %lnb66, i64 %lnb67, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
caZq:
  %lnb68 = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 56, i64* %lnb68, !tbaa !5
  %lnb69 = load i64, i64* %R1_Var
  store i64 %lnb69, i64* %R1_Var
  %lnb6a = bitcast i8* @stg_gc_unpt_r1 to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnb6b = load i64*, i64** %Sp_Var
  %lnb6c = load i64*, i64** %Hp_Var
  %lnb6d = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnb6a( i64* %Base_Arg, i64* %lnb6b, i64* %lnb6c, i64 %lnb6d, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
caZj:
  %lnb6e = load i64*, i64** %Sp_Var
  %lnb6f = getelementptr inbounds i64, i64* %lnb6e, i32 4
  %lnb6g = bitcast i64* %lnb6f to i64*
  %lnb6h = load i64, i64* %lnb6g, !tbaa !2
  store i64 %lnb6h, i64* %R1_Var
  %lnb6i = load i64*, i64** %Sp_Var
  %lnb6j = getelementptr inbounds i64, i64* %lnb6i, i32 8
  %lnb6k = ptrtoint i64* %lnb6j to i64
  %lnb6l = inttoptr i64 %lnb6k to i64*
  store i64* %lnb6l, i64** %Sp_Var
  %lnb6m = bitcast i8* @stg_ap_0_fast to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnb6n = load i64*, i64** %Sp_Var
  %lnb6o = load i64*, i64** %Hp_Var
  %lnb6p = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnb6m( i64* %Base_Arg, i64* %lnb6n, i64* %lnb6o, i64 %lnb6p, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@Main_zdwrepeatNTimes_info = alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_zdwrepeatNTimes_info$def to i8*)
define ghccc void @Main_zdwrepeatNTimes_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i64, i32, i32}><{i64 21474836505, i64 0, i32 14, i32 0}>
{
caZu:
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %R3_Var = alloca i64, i32 1
  store i64 %R3_Arg, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 %R2_Arg, i64* %R2_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %R6_Var = alloca i64, i32 1
  store i64 %R6_Arg, i64* %R6_Var
  %R5_Var = alloca i64, i32 1
  store i64 %R5_Arg, i64* %R5_Var
  %R4_Var = alloca i64, i32 1
  store i64 %R4_Arg, i64* %R4_Var
  %lnb6q = load i64*, i64** %Hp_Var
  %lnb6r = getelementptr inbounds i64, i64* %lnb6q, i32 16
  %lnb6s = ptrtoint i64* %lnb6r to i64
  %lnb6t = inttoptr i64 %lnb6s to i64*
  store i64* %lnb6t, i64** %Hp_Var
  %lnb6u = load i64*, i64** %Hp_Var
  %lnb6v = ptrtoint i64* %lnb6u to i64
  %lnb6w = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lnb6x = bitcast i64* %lnb6w to i64*
  %lnb6y = load i64, i64* %lnb6x, !tbaa !5
  %lnb6z = icmp ugt i64 %lnb6v, %lnb6y
  %lnb6A = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnb6z, i1 0 )
  br i1 %lnb6A, label %caZy, label %caZx
caZx:
  %lnb6C = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saD0_info$def to i64
  %lnb6B = load i64*, i64** %Hp_Var
  %lnb6D = getelementptr inbounds i64, i64* %lnb6B, i32 -15
  store i64 %lnb6C, i64* %lnb6D, !tbaa !3
  %lnb6F = load i64, i64* %R3_Var
  %lnb6E = load i64*, i64** %Hp_Var
  %lnb6G = getelementptr inbounds i64, i64* %lnb6E, i32 -13
  store i64 %lnb6F, i64* %lnb6G, !tbaa !3
  %lnb6I = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saD1_info$def to i64
  %lnb6H = load i64*, i64** %Hp_Var
  %lnb6J = getelementptr inbounds i64, i64* %lnb6H, i32 -12
  store i64 %lnb6I, i64* %lnb6J, !tbaa !3
  %lnb6L = load i64, i64* %R4_Var
  %lnb6K = load i64*, i64** %Hp_Var
  %lnb6M = getelementptr inbounds i64, i64* %lnb6K, i32 -10
  store i64 %lnb6L, i64* %lnb6M, !tbaa !3
  %lnb6O = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saD2_info$def to i64
  %lnb6N = load i64*, i64** %Hp_Var
  %lnb6P = getelementptr inbounds i64, i64* %lnb6N, i32 -9
  store i64 %lnb6O, i64* %lnb6P, !tbaa !3
  %lnb6R = load i64, i64* %R3_Var
  %lnb6Q = load i64*, i64** %Hp_Var
  %lnb6S = getelementptr inbounds i64, i64* %lnb6Q, i32 -7
  store i64 %lnb6R, i64* %lnb6S, !tbaa !3
  %lnb6U = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saD3_info$def to i64
  %lnb6T = load i64*, i64** %Hp_Var
  %lnb6V = getelementptr inbounds i64, i64* %lnb6T, i32 -6
  store i64 %lnb6U, i64* %lnb6V, !tbaa !3
  %lnb6X = load i64, i64* %R2_Var
  %lnb6W = load i64*, i64** %Hp_Var
  %lnb6Y = getelementptr inbounds i64, i64* %lnb6W, i32 -5
  store i64 %lnb6X, i64* %lnb6Y, !tbaa !3
  %lnb70 = load i64, i64* %R3_Var
  %lnb6Z = load i64*, i64** %Hp_Var
  %lnb71 = getelementptr inbounds i64, i64* %lnb6Z, i32 -4
  store i64 %lnb70, i64* %lnb71, !tbaa !3
  %lnb73 = load i64, i64* %R4_Var
  %lnb72 = load i64*, i64** %Hp_Var
  %lnb74 = getelementptr inbounds i64, i64* %lnb72, i32 -3
  store i64 %lnb73, i64* %lnb74, !tbaa !3
  %lnb76 = load i64*, i64** %Hp_Var
  %lnb77 = getelementptr inbounds i64, i64* %lnb76, i32 -15
  %lnb78 = ptrtoint i64* %lnb77 to i64
  %lnb75 = load i64*, i64** %Hp_Var
  %lnb79 = getelementptr inbounds i64, i64* %lnb75, i32 -2
  store i64 %lnb78, i64* %lnb79, !tbaa !3
  %lnb7b = load i64*, i64** %Hp_Var
  %lnb7c = getelementptr inbounds i64, i64* %lnb7b, i32 -12
  %lnb7d = ptrtoint i64* %lnb7c to i64
  %lnb7a = load i64*, i64** %Hp_Var
  %lnb7e = getelementptr inbounds i64, i64* %lnb7a, i32 -1
  store i64 %lnb7d, i64* %lnb7e, !tbaa !3
  %lnb7g = load i64*, i64** %Hp_Var
  %lnb7h = getelementptr inbounds i64, i64* %lnb7g, i32 -9
  %lnb7i = ptrtoint i64* %lnb7h to i64
  %lnb7f = load i64*, i64** %Hp_Var
  %lnb7j = getelementptr inbounds i64, i64* %lnb7f, i32 0
  store i64 %lnb7i, i64* %lnb7j, !tbaa !3
  %lnb7k = load i64, i64* %R6_Var
  store i64 %lnb7k, i64* %R3_Var
  %lnb7l = load i64, i64* %R5_Var
  store i64 %lnb7l, i64* %R2_Var
  %lnb7n = load i64*, i64** %Hp_Var
  %lnb7o = ptrtoint i64* %lnb7n to i64
  %lnb7p = add i64 %lnb7o, -46
  store i64 %lnb7p, i64* %R1_Var
  %lnb7q = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saD3_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnb7r = load i64*, i64** %Hp_Var
  %lnb7s = load i64, i64* %R1_Var
  %lnb7t = load i64, i64* %R2_Var
  %lnb7u = load i64, i64* %R3_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnb7q( i64* %Base_Arg, i64* %Sp_Arg, i64* %lnb7r, i64 %lnb7s, i64 %lnb7t, i64 %lnb7u, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
caZy:
  %lnb7v = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 128, i64* %lnb7v, !tbaa !5
  %lnb7w = load i64, i64* %R6_Var
  store i64 %lnb7w, i64* %R6_Var
  %lnb7x = load i64, i64* %R5_Var
  store i64 %lnb7x, i64* %R5_Var
  %lnb7y = load i64, i64* %R4_Var
  store i64 %lnb7y, i64* %R4_Var
  %lnb7z = load i64, i64* %R3_Var
  store i64 %lnb7z, i64* %R3_Var
  %lnb7A = load i64, i64* %R2_Var
  store i64 %lnb7A, i64* %R2_Var
  %lnb7B = ptrtoint %Main_zdwrepeatNTimes_closure_struct* @Main_zdwrepeatNTimes_closure$def to i64
  store i64 %lnb7B, i64* %R1_Var
  %lnb7C = getelementptr inbounds i64, i64* %Base_Arg, i32 -1
  %lnb7D = bitcast i64* %lnb7C to i64*
  %lnb7E = load i64, i64* %lnb7D, !tbaa !5
  %lnb7F = inttoptr i64 %lnb7E to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnb7G = load i64*, i64** %Hp_Var
  %lnb7H = load i64, i64* %R1_Var
  %lnb7I = load i64, i64* %R2_Var
  %lnb7J = load i64, i64* %R3_Var
  %lnb7K = load i64, i64* %R4_Var
  %lnb7L = load i64, i64* %R5_Var
  %lnb7M = load i64, i64* %R6_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnb7F( i64* %Base_Arg, i64* %Sp_Arg, i64* %lnb7G, i64 %lnb7H, i64 %lnb7I, i64 %lnb7J, i64 %lnb7K, i64 %lnb7L, i64 %lnb7M, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
%Main_repeatNTimes_closure_struct = type <{i64}>
@Main_repeatNTimes_closure$def = internal global %Main_repeatNTimes_closure_struct<{i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_repeatNTimes_info$def to i64)}>
@Main_repeatNTimes_closure = alias i8, bitcast (%Main_repeatNTimes_closure_struct* @Main_repeatNTimes_closure$def to i8*)



==================== LLVM Code ====================
@Main_repeatNTimes_info = alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_repeatNTimes_info$def to i8*)
define ghccc void @Main_repeatNTimes_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i64, i32, i32}><{i64 21474836505, i64 0, i32 14, i32 0}>
{
cb7U:
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %R6_Var = alloca i64, i32 1
  store i64 %R6_Arg, i64* %R6_Var
  %R5_Var = alloca i64, i32 1
  store i64 %R5_Arg, i64* %R5_Var
  %R4_Var = alloca i64, i32 1
  store i64 %R4_Arg, i64* %R4_Var
  %R3_Var = alloca i64, i32 1
  store i64 %R3_Arg, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 %R2_Arg, i64* %R2_Var
  %lnb81 = load i64*, i64** %Sp_Var
  %lnb82 = getelementptr inbounds i64, i64* %lnb81, i32 -5
  %lnb83 = ptrtoint i64* %lnb82 to i64
  %lnb84 = icmp ult i64 %lnb83, %SpLim_Arg
  %lnb85 = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnb84, i1 0 )
  br i1 %lnb85, label %cb7V, label %cb7W
cb7W:
  %lnb87 = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cb7R_info$def to i64
  %lnb86 = load i64*, i64** %Sp_Var
  %lnb88 = getelementptr inbounds i64, i64* %lnb86, i32 -5
  store i64 %lnb87, i64* %lnb88, !tbaa !2
  %lnb89 = load i64, i64* %R2_Var
  store i64 %lnb89, i64* %R1_Var
  %lnb8b = load i64, i64* %R3_Var
  %lnb8a = load i64*, i64** %Sp_Var
  %lnb8c = getelementptr inbounds i64, i64* %lnb8a, i32 -4
  store i64 %lnb8b, i64* %lnb8c, !tbaa !2
  %lnb8e = load i64, i64* %R4_Var
  %lnb8d = load i64*, i64** %Sp_Var
  %lnb8f = getelementptr inbounds i64, i64* %lnb8d, i32 -3
  store i64 %lnb8e, i64* %lnb8f, !tbaa !2
  %lnb8h = load i64, i64* %R5_Var
  %lnb8g = load i64*, i64** %Sp_Var
  %lnb8i = getelementptr inbounds i64, i64* %lnb8g, i32 -2
  store i64 %lnb8h, i64* %lnb8i, !tbaa !2
  %lnb8k = load i64, i64* %R6_Var
  %lnb8j = load i64*, i64** %Sp_Var
  %lnb8l = getelementptr inbounds i64, i64* %lnb8j, i32 -1
  store i64 %lnb8k, i64* %lnb8l, !tbaa !2
  %lnb8m = load i64*, i64** %Sp_Var
  %lnb8n = getelementptr inbounds i64, i64* %lnb8m, i32 -5
  %lnb8o = ptrtoint i64* %lnb8n to i64
  %lnb8p = inttoptr i64 %lnb8o to i64*
  store i64* %lnb8p, i64** %Sp_Var
  %lnb8q = load i64, i64* %R1_Var
  %lnb8r = and i64 %lnb8q, 7
  %lnb8s = icmp ne i64 %lnb8r, 0
  br i1 %lnb8s, label %ub80, label %cb7S
cb7S:
  %lnb8u = load i64, i64* %R1_Var
  %lnb8v = inttoptr i64 %lnb8u to i64*
  %lnb8w = load i64, i64* %lnb8v, !tbaa !4
  %lnb8x = inttoptr i64 %lnb8w to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnb8y = load i64*, i64** %Sp_Var
  %lnb8z = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnb8x( i64* %Base_Arg, i64* %lnb8y, i64* %Hp_Arg, i64 %lnb8z, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ub80:
  %lnb8A = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cb7R_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnb8B = load i64*, i64** %Sp_Var
  %lnb8C = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnb8A( i64* %Base_Arg, i64* %lnb8B, i64* %Hp_Arg, i64 %lnb8C, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cb7V:
  %lnb8D = load i64, i64* %R6_Var
  store i64 %lnb8D, i64* %R6_Var
  %lnb8E = load i64, i64* %R5_Var
  store i64 %lnb8E, i64* %R5_Var
  %lnb8F = load i64, i64* %R4_Var
  store i64 %lnb8F, i64* %R4_Var
  %lnb8G = load i64, i64* %R3_Var
  store i64 %lnb8G, i64* %R3_Var
  %lnb8H = load i64, i64* %R2_Var
  store i64 %lnb8H, i64* %R2_Var
  %lnb8I = ptrtoint %Main_repeatNTimes_closure_struct* @Main_repeatNTimes_closure$def to i64
  store i64 %lnb8I, i64* %R1_Var
  %lnb8J = getelementptr inbounds i64, i64* %Base_Arg, i32 -1
  %lnb8K = bitcast i64* %lnb8J to i64*
  %lnb8L = load i64, i64* %lnb8K, !tbaa !5
  %lnb8M = inttoptr i64 %lnb8L to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnb8N = load i64*, i64** %Sp_Var
  %lnb8O = load i64, i64* %R1_Var
  %lnb8P = load i64, i64* %R2_Var
  %lnb8Q = load i64, i64* %R3_Var
  %lnb8R = load i64, i64* %R4_Var
  %lnb8S = load i64, i64* %R5_Var
  %lnb8T = load i64, i64* %R6_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnb8M( i64* %Base_Arg, i64* %lnb8N, i64* %Hp_Arg, i64 %lnb8O, i64 %lnb8P, i64 %lnb8Q, i64 %lnb8R, i64 %lnb8S, i64 %lnb8T, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cb7R_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cb7R_info$def to i8*)
define internal ghccc void @cb7R_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 4, i32 30, i32 0}>
{
cb7R:
  %R6_Var = alloca i64, i32 1
  store i64 undef, i64* %R6_Var
  %R5_Var = alloca i64, i32 1
  store i64 undef, i64* %R5_Var
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnb8U = load i64*, i64** %Sp_Var
  %lnb8V = getelementptr inbounds i64, i64* %lnb8U, i32 4
  %lnb8W = bitcast i64* %lnb8V to i64*
  %lnb8X = load i64, i64* %lnb8W, !tbaa !2
  store i64 %lnb8X, i64* %R6_Var
  %lnb8Y = load i64*, i64** %Sp_Var
  %lnb8Z = getelementptr inbounds i64, i64* %lnb8Y, i32 3
  %lnb90 = bitcast i64* %lnb8Z to i64*
  %lnb91 = load i64, i64* %lnb90, !tbaa !2
  store i64 %lnb91, i64* %R5_Var
  %lnb92 = load i64*, i64** %Sp_Var
  %lnb93 = getelementptr inbounds i64, i64* %lnb92, i32 2
  %lnb94 = bitcast i64* %lnb93 to i64*
  %lnb95 = load i64, i64* %lnb94, !tbaa !2
  store i64 %lnb95, i64* %R4_Var
  %lnb96 = load i64*, i64** %Sp_Var
  %lnb97 = getelementptr inbounds i64, i64* %lnb96, i32 1
  %lnb98 = bitcast i64* %lnb97 to i64*
  %lnb99 = load i64, i64* %lnb98, !tbaa !2
  store i64 %lnb99, i64* %R3_Var
  %lnb9a = add i64 %R1_Arg, 7
  %lnb9b = inttoptr i64 %lnb9a to i64*
  %lnb9c = load i64, i64* %lnb9b, !tbaa !4
  store i64 %lnb9c, i64* %R2_Var
  %lnb9d = load i64*, i64** %Sp_Var
  %lnb9e = getelementptr inbounds i64, i64* %lnb9d, i32 5
  %lnb9f = ptrtoint i64* %lnb9e to i64
  %lnb9g = inttoptr i64 %lnb9f to i64*
  store i64* %lnb9g, i64** %Sp_Var
  %lnb9h = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_zdwrepeatNTimes_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnb9i = load i64*, i64** %Sp_Var
  %lnb9j = load i64, i64* %R2_Var
  %lnb9k = load i64, i64* %R3_Var
  %lnb9l = load i64, i64* %R4_Var
  %lnb9m = load i64, i64* %R5_Var
  %lnb9n = load i64, i64* %R6_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnb9h( i64* %Base_Arg, i64* %lnb9i, i64* %Hp_Arg, i64 %R1_Arg, i64 %lnb9j, i64 %lnb9k, i64 %lnb9l, i64 %lnb9m, i64 %lnb9n, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
%raBO_closure_struct = type <{i64, double}>
@raBO_closure$def = internal global %raBO_closure_struct<{i64 ptrtoint (i8* @ghczmprim_GHCziTypes_Dzh_con_info to i64), double 0xBFF0000000000000}>
@raBO_closure = internal alias i8, bitcast (%raBO_closure_struct* @raBO_closure$def to i8*)



==================== LLVM Code ====================
%ubmj_srt_struct = type <{i64, i64, i64}>
%ubmk_srt_struct = type <{i64, i64, i64}>
%ubml_srt_struct = type <{i64, i64, i64}>
%ubmm_srt_struct = type <{i64, i64, i64}>
%ubmn_srt_struct = type <{i64, i64, i64}>
%ubmo_srt_struct = type <{i64, i64, i64, i64}>
%ubmp_srt_struct = type <{i64, i64, i64}>
%ubmq_srt_struct = type <{i64, i64, i64, i64, i64}>
%ubmr_srt_struct = type <{i64, i64, i64}>
%ubms_srt_struct = type <{i64, i64, i64}>
%ubmt_srt_struct = type <{i64, i64, i64, i64}>
%ubmu_srt_struct = type <{i64, i64, i64}>
%Main_zdwzdsconjugateGradient_closure_struct = type <{i64, i64, i64, i64, i64}>
@ubmj_srt$def = internal global %ubmj_srt_struct<{i64 ptrtoint (i8* @stg_SRT_1_info to i64), i64 ptrtoint (i8* @hblaszm0zi0zi0zi0zminplace_HBLASziLevel1_axpyzq_closure to i64), i64 0}>
@ubmj_srt = internal alias i8, bitcast (%ubmj_srt_struct* @ubmj_srt$def to i8*)
@ubmk_srt$def = internal global %ubmk_srt_struct<{i64 ptrtoint (i8* @stg_SRT_1_info to i64), i64 ptrtoint (i8* @hblaszm0zi0zi0zi0zminplace_HBLASziLevel2_zdwgemvzq_closure to i64), i64 0}>
@ubmk_srt = internal alias i8, bitcast (%ubmk_srt_struct* @ubmk_srt$def to i8*)
@ubml_srt$def = internal global %ubml_srt_struct<{i64 ptrtoint (i8* @stg_SRT_1_info to i64), i64 ptrtoint (i8* @ubmk_srt to i64), i64 0}>
@ubml_srt = internal alias i8, bitcast (%ubml_srt_struct* @ubml_srt$def to i8*)
@ubmm_srt$def = internal global %ubmm_srt_struct<{i64 ptrtoint (i8* @stg_SRT_1_info to i64), i64 ptrtoint (i8* @ubmj_srt to i64), i64 0}>
@ubmm_srt = internal alias i8, bitcast (%ubmm_srt_struct* @ubmm_srt$def to i8*)
@ubmn_srt$def = internal global %ubmn_srt_struct<{i64 ptrtoint (i8* @stg_SRT_1_info to i64), i64 ptrtoint (i8* @ubmm_srt to i64), i64 0}>
@ubmn_srt = internal alias i8, bitcast (%ubmn_srt_struct* @ubmn_srt$def to i8*)
@ubmo_srt$def = internal global %ubmo_srt_struct<{i64 ptrtoint (i8* @stg_SRT_2_info to i64), i64 ptrtoint (i8* @vctrzm0zi12zi0zi2zm9a8f7398_DataziVectorziMutable_uninitialised_closure to i64), i64 ptrtoint (i8* @ubmn_srt to i64), i64 0}>
@ubmo_srt = internal alias i8, bitcast (%ubmo_srt_struct* @ubmo_srt$def to i8*)
@ubmp_srt$def = internal global %ubmp_srt_struct<{i64 ptrtoint (i8* @stg_SRT_1_info to i64), i64 ptrtoint (i8* @ubmo_srt to i64), i64 0}>
@ubmp_srt = internal alias i8, bitcast (%ubmp_srt_struct* @ubmp_srt$def to i8*)
@ubmq_srt$def = internal global %ubmq_srt_struct<{i64 ptrtoint (i8* @stg_SRT_3_info to i64), i64 ptrtoint (i8* @base_GHCziFloat_zdfFloatingDouble_closure to i64), i64 ptrtoint (i8* @ubml_srt to i64), i64 ptrtoint (i8* @ubmp_srt to i64), i64 0}>
@ubmq_srt = internal alias i8, bitcast (%ubmq_srt_struct* @ubmq_srt$def to i8*)
@ubmr_srt$def = internal global %ubmr_srt_struct<{i64 ptrtoint (i8* @stg_SRT_1_info to i64), i64 ptrtoint (i8* @vctrzm0zi12zi0zi2zm9a8f7398_DataziVectorziMutable_uninitialised_closure to i64), i64 0}>
@ubmr_srt = internal alias i8, bitcast (%ubmr_srt_struct* @ubmr_srt$def to i8*)
@ubms_srt$def = internal global %ubms_srt_struct<{i64 ptrtoint (i8* @stg_SRT_1_info to i64), i64 ptrtoint (i8* @ubmr_srt to i64), i64 0}>
@ubms_srt = internal alias i8, bitcast (%ubms_srt_struct* @ubms_srt$def to i8*)
@ubmt_srt$def = internal global %ubmt_srt_struct<{i64 ptrtoint (i8* @stg_SRT_2_info to i64), i64 ptrtoint (i8* @hblaszm0zi0zi0zi0zminplace_HBLASziLevel2_zdwgemvzq_closure to i64), i64 ptrtoint (i8* @ubmj_srt to i64), i64 0}>
@ubmt_srt = internal alias i8, bitcast (%ubmt_srt_struct* @ubmt_srt$def to i8*)
@ubmu_srt$def = internal global %ubmu_srt_struct<{i64 ptrtoint (i8* @stg_SRT_1_info to i64), i64 ptrtoint (i8* @ubmt_srt to i64), i64 0}>
@ubmu_srt = internal alias i8, bitcast (%ubmu_srt_struct* @ubmu_srt$def to i8*)
@Main_zdwzdsconjugateGradient_closure$def = internal global %Main_zdwzdsconjugateGradient_closure_struct<{i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_zdwzdsconjugateGradient_info$def to i64), i64 ptrtoint (i8* @ubmq_srt to i64), i64 ptrtoint (i8* @ubms_srt to i64), i64 ptrtoint (i8* @ubmu_srt to i64), i64 0}>
@Main_zdwzdsconjugateGradient_closure = alias i8, bitcast (%Main_zdwzdsconjugateGradient_closure_struct* @Main_zdwzdsconjugateGradient_closure$def to i8*)



==================== LLVM Code ====================
@Main_zdwzdsconjugateGradient_slow = alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_zdwzdsconjugateGradient_slow$def to i8*)
define ghccc void @Main_zdwzdsconjugateGradient_slow$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind
{
cb9p:
  %R6_Var = alloca i64, i32 1
  store i64 undef, i64* %R6_Var
  %R5_Var = alloca i64, i32 1
  store i64 undef, i64* %R5_Var
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnbmv = load i64*, i64** %Sp_Var
  %lnbmw = getelementptr inbounds i64, i64* %lnbmv, i32 4
  %lnbmx = bitcast i64* %lnbmw to i64*
  %lnbmy = load i64, i64* %lnbmx, !tbaa !2
  store i64 %lnbmy, i64* %R6_Var
  %lnbmz = load i64*, i64** %Sp_Var
  %lnbmA = getelementptr inbounds i64, i64* %lnbmz, i32 3
  %lnbmB = bitcast i64* %lnbmA to i64*
  %lnbmC = load i64, i64* %lnbmB, !tbaa !2
  store i64 %lnbmC, i64* %R5_Var
  %lnbmD = load i64*, i64** %Sp_Var
  %lnbmE = getelementptr inbounds i64, i64* %lnbmD, i32 2
  %lnbmF = bitcast i64* %lnbmE to i64*
  %lnbmG = load i64, i64* %lnbmF, !tbaa !2
  store i64 %lnbmG, i64* %R4_Var
  %lnbmH = load i64*, i64** %Sp_Var
  %lnbmI = getelementptr inbounds i64, i64* %lnbmH, i32 1
  %lnbmJ = bitcast i64* %lnbmI to i64*
  %lnbmK = load i64, i64* %lnbmJ, !tbaa !2
  store i64 %lnbmK, i64* %R3_Var
  %lnbmL = load i64*, i64** %Sp_Var
  %lnbmM = getelementptr inbounds i64, i64* %lnbmL, i32 0
  %lnbmN = bitcast i64* %lnbmM to i64*
  %lnbmO = load i64, i64* %lnbmN, !tbaa !2
  store i64 %lnbmO, i64* %R2_Var
  %lnbmP = load i64, i64* %R1_Var
  store i64 %lnbmP, i64* %R1_Var
  %lnbmQ = load i64*, i64** %Sp_Var
  %lnbmR = getelementptr inbounds i64, i64* %lnbmQ, i32 5
  %lnbmS = ptrtoint i64* %lnbmR to i64
  %lnbmT = inttoptr i64 %lnbmS to i64*
  store i64* %lnbmT, i64** %Sp_Var
  %lnbmU = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_zdwzdsconjugateGradient_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbmV = load i64*, i64** %Sp_Var
  %lnbmW = load i64, i64* %R1_Var
  %lnbmX = load i64, i64* %R2_Var
  %lnbmY = load i64, i64* %R3_Var
  %lnbmZ = load i64, i64* %R4_Var
  %lnbn0 = load i64, i64* %R5_Var
  %lnbn1 = load i64, i64* %R6_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbmU( i64* %Base_Arg, i64* %lnbmV, i64* %Hp_Arg, i64 %lnbmW, i64 %lnbmX, i64 %lnbmY, i64 %lnbmZ, i64 %lnbn0, i64 %lnbn1, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saDn_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saDn_info$def to i8*)
define internal ghccc void @saDn_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 3, i32 15, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%ubmu_srt_struct* @ubmu_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saDn_info$def to i64)) to i32),i32 0)}>
{
cbah:
  %lsaDl = alloca i64, i32 1
  %lsaDm = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnbn2 = load i64*, i64** %Sp_Var
  %lnbn3 = getelementptr inbounds i64, i64* %lnbn2, i32 -5
  %lnbn4 = ptrtoint i64* %lnbn3 to i64
  %lnbn5 = icmp ult i64 %lnbn4, %SpLim_Arg
  %lnbn6 = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnbn5, i1 0 )
  br i1 %lnbn6, label %cbal, label %cbam
cbam:
  %lnbn8 = ptrtoint i8* @stg_upd_frame_info to i64
  %lnbn7 = load i64*, i64** %Sp_Var
  %lnbn9 = getelementptr inbounds i64, i64* %lnbn7, i32 -2
  store i64 %lnbn8, i64* %lnbn9, !tbaa !2
  %lnbnb = load i64, i64* %R1_Var
  %lnbna = load i64*, i64** %Sp_Var
  %lnbnc = getelementptr inbounds i64, i64* %lnbna, i32 -1
  store i64 %lnbnb, i64* %lnbnc, !tbaa !2
  %lnbne = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbae_info$def to i64
  %lnbnd = load i64*, i64** %Sp_Var
  %lnbnf = getelementptr inbounds i64, i64* %lnbnd, i32 -5
  store i64 %lnbne, i64* %lnbnf, !tbaa !2
  %lnbni = load i64, i64* %R1_Var
  %lnbnj = add i64 %lnbni, 24
  %lnbnk = inttoptr i64 %lnbnj to i64*
  %lnbnl = load i64, i64* %lnbnk, !tbaa !4
  store i64 %lnbnl, i64* %lsaDl
  %lnbno = load i64, i64* %R1_Var
  %lnbnp = add i64 %lnbno, 32
  %lnbnq = inttoptr i64 %lnbnp to i64*
  %lnbnr = load i64, i64* %lnbnq, !tbaa !4
  store i64 %lnbnr, i64* %lsaDm
  %lnbnu = load i64, i64* %R1_Var
  %lnbnv = add i64 %lnbnu, 16
  %lnbnw = inttoptr i64 %lnbnv to i64*
  %lnbnx = load i64, i64* %lnbnw, !tbaa !4
  store i64 %lnbnx, i64* %R1_Var
  %lnbnz = load i64, i64* %lsaDl
  %lnbny = load i64*, i64** %Sp_Var
  %lnbnA = getelementptr inbounds i64, i64* %lnbny, i32 -4
  store i64 %lnbnz, i64* %lnbnA, !tbaa !2
  %lnbnC = load i64, i64* %lsaDm
  %lnbnB = load i64*, i64** %Sp_Var
  %lnbnD = getelementptr inbounds i64, i64* %lnbnB, i32 -3
  store i64 %lnbnC, i64* %lnbnD, !tbaa !2
  %lnbnE = load i64*, i64** %Sp_Var
  %lnbnF = getelementptr inbounds i64, i64* %lnbnE, i32 -5
  %lnbnG = ptrtoint i64* %lnbnF to i64
  %lnbnH = inttoptr i64 %lnbnG to i64*
  store i64* %lnbnH, i64** %Sp_Var
  %lnbnI = load i64, i64* %R1_Var
  %lnbnJ = and i64 %lnbnI, 7
  %lnbnK = icmp ne i64 %lnbnJ, 0
  br i1 %lnbnK, label %ubas, label %cbaf
cbaf:
  %lnbnM = load i64, i64* %R1_Var
  %lnbnN = inttoptr i64 %lnbnM to i64*
  %lnbnO = load i64, i64* %lnbnN, !tbaa !4
  %lnbnP = inttoptr i64 %lnbnO to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbnQ = load i64*, i64** %Sp_Var
  %lnbnR = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbnP( i64* %Base_Arg, i64* %lnbnQ, i64* %Hp_Arg, i64 %lnbnR, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ubas:
  %lnbnS = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbae_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbnT = load i64*, i64** %Sp_Var
  %lnbnU = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbnS( i64* %Base_Arg, i64* %lnbnT, i64* %Hp_Arg, i64 %lnbnU, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cbal:
  %lnbnV = load i64, i64* %R1_Var
  store i64 %lnbnV, i64* %R1_Var
  %lnbnW = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lnbnX = bitcast i64* %lnbnW to i64*
  %lnbnY = load i64, i64* %lnbnX, !tbaa !5
  %lnbnZ = inttoptr i64 %lnbnY to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbo0 = load i64*, i64** %Sp_Var
  %lnbo1 = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbnZ( i64* %Base_Arg, i64* %lnbo0, i64* %Hp_Arg, i64 %lnbo1, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cbae_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbae_info$def to i8*)
define internal ghccc void @cbae_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 2, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%ubmt_srt_struct* @ubmt_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbae_info$def to i64)) to i32),i32 0)}>
{
cbae:
  %R6_Var = alloca i64, i32 1
  store i64 undef, i64* %R6_Var
  %R5_Var = alloca i64, i32 1
  store i64 undef, i64* %R5_Var
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %lnbo2 = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbak_info$def to i64
  %lnbo3 = getelementptr inbounds i64, i64* %Sp_Arg, i32 0
  store i64 %lnbo2, i64* %lnbo3, !tbaa !2
  %lnbo4 = getelementptr inbounds i64, i64* %Sp_Arg, i32 2
  %lnbo5 = bitcast i64* %lnbo4 to i64*
  %lnbo6 = load i64, i64* %lnbo5, !tbaa !2
  store i64 %lnbo6, i64* %R6_Var
  %lnbo7 = add i64 %R1_Arg, 7
  %lnbo8 = inttoptr i64 %lnbo7 to i64*
  %lnbo9 = load i64, i64* %lnbo8, !tbaa !4
  store i64 %lnbo9, i64* %R5_Var
  %lnboa = add i64 %R1_Arg, 23
  %lnbob = inttoptr i64 %lnboa to i64*
  %lnboc = load i64, i64* %lnbob, !tbaa !4
  store i64 %lnboc, i64* %R4_Var
  %lnbod = add i64 %R1_Arg, 15
  %lnboe = inttoptr i64 %lnbod to i64*
  %lnbof = load i64, i64* %lnboe, !tbaa !4
  store i64 %lnbof, i64* %R3_Var
  %lnbog = ptrtoint i8* @base_GHCziFloat_zdfNumDouble_closure to i64
  store i64 %lnbog, i64* %R2_Var
  %lnboh = bitcast i8* @hblaszm0zi0zi0zi0zminplace_HBLASziLevel2_zdwgemvzq_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnboi = load i64, i64* %R2_Var
  %lnboj = load i64, i64* %R3_Var
  %lnbok = load i64, i64* %R4_Var
  %lnbol = load i64, i64* %R5_Var
  %lnbom = load i64, i64* %R6_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnboh( i64* %Base_Arg, i64* %Sp_Arg, i64* %Hp_Arg, i64 %R1_Arg, i64 %lnboi, i64 %lnboj, i64 %lnbok, i64 %lnbol, i64 %lnbom, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cbak_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbak_info$def to i8*)
define internal ghccc void @cbak_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 2, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%ubmj_srt_struct* @ubmj_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbak_info$def to i64)) to i32),i32 0)}>
{
cbak:
  %R6_Var = alloca i64, i32 1
  store i64 undef, i64* %R6_Var
  %R5_Var = alloca i64, i32 1
  store i64 undef, i64* %R5_Var
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnbon = load i64*, i64** %Sp_Var
  %lnboo = getelementptr inbounds i64, i64* %lnbon, i32 1
  %lnbop = bitcast i64* %lnboo to i64*
  %lnboq = load i64, i64* %lnbop, !tbaa !2
  store i64 %lnboq, i64* %R6_Var
  %lnbor = load i64*, i64** %Sp_Var
  %lnbos = getelementptr inbounds i64, i64* %lnbor, i32 2
  %lnbot = bitcast i64* %lnbos to i64*
  %lnbou = load i64, i64* %lnbot, !tbaa !2
  store i64 %lnbou, i64* %R5_Var
  store i64 %R1_Arg, i64* %R4_Var
  %lnbov = ptrtoint %raBO_closure_struct* @raBO_closure$def to i64
  %lnbow = add i64 %lnbov, 1
  store i64 %lnbow, i64* %R3_Var
  %lnbox = ptrtoint i8* @base_GHCziFloat_zdfNumDouble_closure to i64
  store i64 %lnbox, i64* %R2_Var
  %lnboy = load i64*, i64** %Sp_Var
  %lnboz = getelementptr inbounds i64, i64* %lnboy, i32 3
  %lnboA = ptrtoint i64* %lnboz to i64
  %lnboB = inttoptr i64 %lnboA to i64*
  store i64* %lnboB, i64** %Sp_Var
  %lnboC = bitcast i8* @hblaszm0zi0zi0zi0zminplace_HBLASziLevel1_axpyzq_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnboD = load i64*, i64** %Sp_Var
  %lnboE = load i64, i64* %R2_Var
  %lnboF = load i64, i64* %R3_Var
  %lnboG = load i64, i64* %R4_Var
  %lnboH = load i64, i64* %R5_Var
  %lnboI = load i64, i64* %R6_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnboC( i64* %Base_Arg, i64* %lnboD, i64* %Hp_Arg, i64 %R1_Arg, i64 %lnboE, i64 %lnboF, i64 %lnboG, i64 %lnboH, i64 %lnboI, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saDT_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saDT_info$def to i8*)
define internal ghccc void @saDT_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 1, i32 16, i32 0}>
{
cbaW:
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnboJ = load i64*, i64** %Sp_Var
  %lnboK = getelementptr inbounds i64, i64* %lnboJ, i32 -3
  %lnboL = ptrtoint i64* %lnboK to i64
  %lnboM = icmp ult i64 %lnboL, %SpLim_Arg
  %lnboN = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnboM, i1 0 )
  br i1 %lnboN, label %cbb3, label %cbb4
cbb4:
  %lnboP = ptrtoint i8* @stg_upd_frame_info to i64
  %lnboO = load i64*, i64** %Sp_Var
  %lnboQ = getelementptr inbounds i64, i64* %lnboO, i32 -2
  store i64 %lnboP, i64* %lnboQ, !tbaa !2
  %lnboS = load i64, i64* %R1_Var
  %lnboR = load i64*, i64** %Sp_Var
  %lnboT = getelementptr inbounds i64, i64* %lnboR, i32 -1
  store i64 %lnboS, i64* %lnboT, !tbaa !2
  %lnboV = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbaT_info$def to i64
  %lnboU = load i64*, i64** %Sp_Var
  %lnboW = getelementptr inbounds i64, i64* %lnboU, i32 -3
  store i64 %lnboV, i64* %lnboW, !tbaa !2
  %lnboZ = load i64, i64* %R1_Var
  %lnbp0 = add i64 %lnboZ, 16
  %lnbp1 = inttoptr i64 %lnbp0 to i64*
  %lnbp2 = load i64, i64* %lnbp1, !tbaa !4
  store i64 %lnbp2, i64* %R1_Var
  %lnbp3 = load i64*, i64** %Sp_Var
  %lnbp4 = getelementptr inbounds i64, i64* %lnbp3, i32 -3
  %lnbp5 = ptrtoint i64* %lnbp4 to i64
  %lnbp6 = inttoptr i64 %lnbp5 to i64*
  store i64* %lnbp6, i64** %Sp_Var
  %lnbp7 = load i64, i64* %R1_Var
  %lnbp8 = and i64 %lnbp7, 7
  %lnbp9 = icmp ne i64 %lnbp8, 0
  br i1 %lnbp9, label %ubb8, label %cbaU
cbaU:
  %lnbpb = load i64, i64* %R1_Var
  %lnbpc = inttoptr i64 %lnbpb to i64*
  %lnbpd = load i64, i64* %lnbpc, !tbaa !4
  %lnbpe = inttoptr i64 %lnbpd to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbpf = load i64*, i64** %Sp_Var
  %lnbpg = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbpe( i64* %Base_Arg, i64* %lnbpf, i64* %Hp_Arg, i64 %lnbpg, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ubb8:
  %lnbph = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbaT_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbpi = load i64*, i64** %Sp_Var
  %lnbpj = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbph( i64* %Base_Arg, i64* %lnbpi, i64* %Hp_Arg, i64 %lnbpj, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cbb3:
  %lnbpk = load i64, i64* %R1_Var
  store i64 %lnbpk, i64* %R1_Var
  %lnbpl = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lnbpm = bitcast i64* %lnbpl to i64*
  %lnbpn = load i64, i64* %lnbpm, !tbaa !5
  %lnbpo = inttoptr i64 %lnbpn to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbpp = load i64*, i64** %Sp_Var
  %lnbpq = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbpo( i64* %Base_Arg, i64* %lnbpp, i64* %Hp_Arg, i64 %lnbpq, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cbaT_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbaT_info$def to i8*)
define internal ghccc void @cbaT_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 0, i32 30, i32 0}>
{
cbaT:
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %lsaDS = alloca double, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnbpr = load i64*, i64** %Hp_Var
  %lnbps = getelementptr inbounds i64, i64* %lnbpr, i32 2
  %lnbpt = ptrtoint i64* %lnbps to i64
  %lnbpu = inttoptr i64 %lnbpt to i64*
  store i64* %lnbpu, i64** %Hp_Var
  %lnbpv = load i64*, i64** %Hp_Var
  %lnbpw = ptrtoint i64* %lnbpv to i64
  %lnbpx = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lnbpy = bitcast i64* %lnbpx to i64*
  %lnbpz = load i64, i64* %lnbpy, !tbaa !5
  %lnbpA = icmp ugt i64 %lnbpw, %lnbpz
  %lnbpB = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnbpA, i1 0 )
  br i1 %lnbpB, label %cbb7, label %cbb6
cbb6:
  %lnbpE = load i64, i64* %R1_Var
  %lnbpF = add i64 %lnbpE, 7
  %lnbpG = inttoptr i64 %lnbpF to double*
  %lnbpH = load double, double* %lnbpG, !tbaa !4
  %lnbpI = fmul double %lnbpH, 0xBFF0000000000000
  store double %lnbpI, double* %lsaDS
  %lnbpK = ptrtoint i8* @ghczmprim_GHCziTypes_Dzh_con_info to i64
  %lnbpJ = load i64*, i64** %Hp_Var
  %lnbpL = getelementptr inbounds i64, i64* %lnbpJ, i32 -1
  store i64 %lnbpK, i64* %lnbpL, !tbaa !3
  %lnbpN = load double, double* %lsaDS
  %lnbpM = load i64*, i64** %Hp_Var
  %lnbpO = getelementptr inbounds i64, i64* %lnbpM, i32 0
  %lnbpP = bitcast i64* %lnbpO to double*
  store double %lnbpN, double* %lnbpP, !tbaa !3
  %lnbpR = load i64*, i64** %Hp_Var
  %lnbpS = ptrtoint i64* %lnbpR to i64
  %lnbpT = add i64 %lnbpS, -7
  store i64 %lnbpT, i64* %R1_Var
  %lnbpU = load i64*, i64** %Sp_Var
  %lnbpV = getelementptr inbounds i64, i64* %lnbpU, i32 1
  %lnbpW = ptrtoint i64* %lnbpV to i64
  %lnbpX = inttoptr i64 %lnbpW to i64*
  store i64* %lnbpX, i64** %Sp_Var
  %lnbpY = load i64*, i64** %Sp_Var
  %lnbpZ = getelementptr inbounds i64, i64* %lnbpY, i32 0
  %lnbq0 = bitcast i64* %lnbpZ to i64*
  %lnbq1 = load i64, i64* %lnbq0, !tbaa !2
  %lnbq2 = inttoptr i64 %lnbq1 to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbq3 = load i64*, i64** %Sp_Var
  %lnbq4 = load i64*, i64** %Hp_Var
  %lnbq5 = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbq2( i64* %Base_Arg, i64* %lnbq3, i64* %lnbq4, i64 %lnbq5, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cbb7:
  %lnbq6 = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 16, i64* %lnbq6, !tbaa !5
  %lnbq7 = load i64, i64* %R1_Var
  store i64 %lnbq7, i64* %R1_Var
  %lnbq8 = bitcast i8* @stg_gc_unpt_r1 to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbq9 = load i64*, i64** %Sp_Var
  %lnbqa = load i64*, i64** %Hp_Var
  %lnbqb = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbq8( i64* %Base_Arg, i64* %lnbq9, i64* %lnbqa, i64 %lnbqb, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saDt_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saDt_info$def to i8*)
define internal ghccc void @saDt_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 1, i32 16, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%ubms_srt_struct* @ubms_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saDt_info$def to i64)) to i32),i32 0)}>
{
cbb9:
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnbqc = load i64*, i64** %Sp_Var
  %lnbqd = getelementptr inbounds i64, i64* %lnbqc, i32 -9
  %lnbqe = ptrtoint i64* %lnbqd to i64
  %lnbqf = icmp ult i64 %lnbqe, %SpLim_Arg
  %lnbqg = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnbqf, i1 0 )
  br i1 %lnbqg, label %cbba, label %cbbb
cbbb:
  %lnbqi = ptrtoint i8* @stg_upd_frame_info to i64
  %lnbqh = load i64*, i64** %Sp_Var
  %lnbqj = getelementptr inbounds i64, i64* %lnbqh, i32 -2
  store i64 %lnbqi, i64* %lnbqj, !tbaa !2
  %lnbql = load i64, i64* %R1_Var
  %lnbqk = load i64*, i64** %Sp_Var
  %lnbqm = getelementptr inbounds i64, i64* %lnbqk, i32 -1
  store i64 %lnbql, i64* %lnbqm, !tbaa !2
  %lnbqo = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbav_info$def to i64
  %lnbqn = load i64*, i64** %Sp_Var
  %lnbqp = getelementptr inbounds i64, i64* %lnbqn, i32 -3
  store i64 %lnbqo, i64* %lnbqp, !tbaa !2
  %lnbqs = load i64, i64* %R1_Var
  %lnbqt = add i64 %lnbqs, 16
  %lnbqu = inttoptr i64 %lnbqt to i64*
  %lnbqv = load i64, i64* %lnbqu, !tbaa !4
  store i64 %lnbqv, i64* %R1_Var
  %lnbqw = load i64*, i64** %Sp_Var
  %lnbqx = getelementptr inbounds i64, i64* %lnbqw, i32 -3
  %lnbqy = ptrtoint i64* %lnbqx to i64
  %lnbqz = inttoptr i64 %lnbqy to i64*
  store i64* %lnbqz, i64** %Sp_Var
  %lnbqA = load i64, i64* %R1_Var
  %lnbqB = and i64 %lnbqA, 7
  %lnbqC = icmp ne i64 %lnbqB, 0
  br i1 %lnbqC, label %ubbG, label %cbaw
cbaw:
  %lnbqE = load i64, i64* %R1_Var
  %lnbqF = inttoptr i64 %lnbqE to i64*
  %lnbqG = load i64, i64* %lnbqF, !tbaa !4
  %lnbqH = inttoptr i64 %lnbqG to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbqI = load i64*, i64** %Sp_Var
  %lnbqJ = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbqH( i64* %Base_Arg, i64* %lnbqI, i64* %Hp_Arg, i64 %lnbqJ, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ubbG:
  %lnbqK = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbav_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbqL = load i64*, i64** %Sp_Var
  %lnbqM = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbqK( i64* %Base_Arg, i64* %lnbqL, i64* %Hp_Arg, i64 %lnbqM, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cbba:
  %lnbqN = load i64, i64* %R1_Var
  store i64 %lnbqN, i64* %R1_Var
  %lnbqO = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lnbqP = bitcast i64* %lnbqO to i64*
  %lnbqQ = load i64, i64* %lnbqP, !tbaa !5
  %lnbqR = inttoptr i64 %lnbqQ to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbqS = load i64*, i64** %Sp_Var
  %lnbqT = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbqR( i64* %Base_Arg, i64* %lnbqS, i64* %Hp_Arg, i64 %lnbqT, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cbav_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbav_info$def to i8*)
define internal ghccc void @cbav_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 0, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%ubmr_srt_struct* @ubmr_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbav_info$def to i64)) to i32),i32 0)}>
{
cbav:
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %lsaDx = alloca i64, i32 1
  %lsaDv = alloca i64, i32 1
  %lsaDw = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnbqV = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbaA_info$def to i64
  %lnbqU = load i64*, i64** %Sp_Var
  %lnbqW = getelementptr inbounds i64, i64* %lnbqU, i32 -3
  store i64 %lnbqV, i64* %lnbqW, !tbaa !2
  %lnbqX = ptrtoint i8* @vctrzm0zi12zi0zi2zm9a8f7398_DataziVectorziMutable_uninitialised_closure to i64
  store i64 %lnbqX, i64* %R2_Var
  %lnbr0 = load i64, i64* %R1_Var
  %lnbr1 = add i64 %lnbr0, 7
  %lnbr2 = inttoptr i64 %lnbr1 to i64*
  %lnbr3 = load i64, i64* %lnbr2, !tbaa !4
  store i64 %lnbr3, i64* %lsaDx
  %lnbr6 = load i64, i64* %R1_Var
  %lnbr7 = add i64 %lnbr6, 15
  %lnbr8 = inttoptr i64 %lnbr7 to i64*
  %lnbr9 = load i64, i64* %lnbr8, !tbaa !4
  store i64 %lnbr9, i64* %lsaDv
  %lnbrc = load i64, i64* %R1_Var
  %lnbrd = add i64 %lnbrc, 23
  %lnbre = inttoptr i64 %lnbrd to i64*
  %lnbrf = load i64, i64* %lnbre, !tbaa !4
  store i64 %lnbrf, i64* %lsaDw
  %lnbrg = load i64, i64* %lsaDw
  store i64 %lnbrg, i64* %R1_Var
  %lnbri = load i64, i64* %lsaDw
  %lnbrh = load i64*, i64** %Sp_Var
  %lnbrj = getelementptr inbounds i64, i64* %lnbrh, i32 -2
  store i64 %lnbri, i64* %lnbrj, !tbaa !2
  %lnbrl = load i64, i64* %lsaDx
  %lnbrk = load i64*, i64** %Sp_Var
  %lnbrm = getelementptr inbounds i64, i64* %lnbrk, i32 -1
  store i64 %lnbrl, i64* %lnbrm, !tbaa !2
  %lnbro = load i64, i64* %lsaDv
  %lnbrn = load i64*, i64** %Sp_Var
  %lnbrp = getelementptr inbounds i64, i64* %lnbrn, i32 0
  store i64 %lnbro, i64* %lnbrp, !tbaa !2
  %lnbrq = load i64*, i64** %Sp_Var
  %lnbrr = getelementptr inbounds i64, i64* %lnbrq, i32 -3
  %lnbrs = ptrtoint i64* %lnbrr to i64
  %lnbrt = inttoptr i64 %lnbrs to i64*
  store i64* %lnbrt, i64** %Sp_Var
  %lnbru = bitcast i8* @stg_newArrayzh to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbrv = load i64*, i64** %Sp_Var
  %lnbrw = load i64, i64* %R1_Var
  %lnbrx = load i64, i64* %R2_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbru( i64* %Base_Arg, i64* %lnbrv, i64* %Hp_Arg, i64 %lnbrw, i64 %lnbrx, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cbaA_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbaA_info$def to i8*)
define internal ghccc void @cbaA_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 323, i32 30, i32 0}>
{
cbaA:
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnbry = load i64*, i64** %Sp_Var
  %lnbrz = getelementptr inbounds i64, i64* %lnbry, i32 -2
  store i64 0, i64* %lnbrz, !tbaa !2
  %lnbrA = load i64*, i64** %Sp_Var
  %lnbrB = getelementptr inbounds i64, i64* %lnbrA, i32 -1
  store i64 0, i64* %lnbrB, !tbaa !2
  %lnbrC = load i64*, i64** %Sp_Var
  %lnbrD = getelementptr inbounds i64, i64* %lnbrC, i32 0
  store i64 %R1_Arg, i64* %lnbrD, !tbaa !2
  %lnbrE = load i64*, i64** %Sp_Var
  %lnbrF = getelementptr inbounds i64, i64* %lnbrE, i32 -3
  %lnbrG = ptrtoint i64* %lnbrF to i64
  %lnbrH = inttoptr i64 %lnbrG to i64*
  store i64* %lnbrH, i64** %Sp_Var
  %lnbrI = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbaG_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbrJ = load i64*, i64** %Sp_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbrI( i64* %Base_Arg, i64* %lnbrJ, i64* %Hp_Arg, i64 %R1_Arg, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cbaG_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbaG_info$def to i8*)
define internal ghccc void @cbaG_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 2758, i32 30, i32 0}>
{
cbaG:
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %lsaDK = alloca i64, i32 1
  %lsaDL = alloca i64, i32 1
  %lsaDA = alloca i64, i32 1
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R5_Var = alloca i64, i32 1
  store i64 undef, i64* %R5_Var
  %R6_Var = alloca i64, i32 1
  store i64 undef, i64* %R6_Var
  %F1_Var = alloca float, i32 1
  store float undef, float* %F1_Var
  %D1_Var = alloca double, i32 1
  store double undef, double* %D1_Var
  %F2_Var = alloca float, i32 1
  store float undef, float* %F2_Var
  %D2_Var = alloca double, i32 1
  store double undef, double* %D2_Var
  %F3_Var = alloca float, i32 1
  store float undef, float* %F3_Var
  %D3_Var = alloca double, i32 1
  store double undef, double* %D3_Var
  %F4_Var = alloca float, i32 1
  store float undef, float* %F4_Var
  %D4_Var = alloca double, i32 1
  store double undef, double* %D4_Var
  %F5_Var = alloca float, i32 1
  store float undef, float* %F5_Var
  %D5_Var = alloca double, i32 1
  store double undef, double* %D5_Var
  %F6_Var = alloca float, i32 1
  store float undef, float* %F6_Var
  %D6_Var = alloca double, i32 1
  store double undef, double* %D6_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnbrK = load i64*, i64** %Hp_Var
  %lnbrL = getelementptr inbounds i64, i64* %lnbrK, i32 3
  %lnbrM = ptrtoint i64* %lnbrL to i64
  %lnbrN = inttoptr i64 %lnbrM to i64*
  store i64* %lnbrN, i64** %Hp_Var
  %lnbrO = load i64*, i64** %Hp_Var
  %lnbrP = ptrtoint i64* %lnbrO to i64
  %lnbrQ = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lnbrR = bitcast i64* %lnbrQ to i64*
  %lnbrS = load i64, i64* %lnbrR, !tbaa !5
  %lnbrT = icmp ugt i64 %lnbrP, %lnbrS
  %lnbrU = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnbrT, i1 0 )
  br i1 %lnbrU, label %cbbm, label %cbbl
cbbl:
  %lnbrV = load i64*, i64** %Sp_Var
  %lnbrW = getelementptr inbounds i64, i64* %lnbrV, i32 1
  %lnbrX = bitcast i64* %lnbrW to i64*
  %lnbrY = load i64, i64* %lnbrX, !tbaa !2
  store i64 %lnbrY, i64* %lsaDK
  %lnbrZ = load i64*, i64** %Sp_Var
  %lnbs0 = getelementptr inbounds i64, i64* %lnbrZ, i32 2
  %lnbs1 = bitcast i64* %lnbs0 to i64*
  %lnbs2 = load i64, i64* %lnbs1, !tbaa !2
  store i64 %lnbs2, i64* %lsaDL
  %lnbs3 = load i64, i64* %lsaDK
  %lnbs4 = load i64*, i64** %Sp_Var
  %lnbs5 = getelementptr inbounds i64, i64* %lnbs4, i32 4
  %lnbs6 = bitcast i64* %lnbs5 to i64*
  %lnbs7 = load i64, i64* %lnbs6, !tbaa !2
  %lnbs8 = icmp sge i64 %lnbs3, %lnbs7
  %lnbs9 = zext i1 %lnbs8 to i64
  switch i64 %lnbs9, label %cbbo [i64 1, label %cbbp]
cbbo:
  %lnbsb = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saDT_info$def to i64
  %lnbsa = load i64*, i64** %Hp_Var
  %lnbsc = getelementptr inbounds i64, i64* %lnbsa, i32 -2
  store i64 %lnbsb, i64* %lnbsc, !tbaa !3
  %lnbse = load i64*, i64** %Sp_Var
  %lnbsf = getelementptr inbounds i64, i64* %lnbse, i32 5
  %lnbsg = bitcast i64* %lnbsf to i64*
  %lnbsh = load i64, i64* %lnbsg, !tbaa !2
  %lnbsi = load i64*, i64** %Sp_Var
  %lnbsj = getelementptr inbounds i64, i64* %lnbsi, i32 6
  %lnbsk = bitcast i64* %lnbsj to i64*
  %lnbsl = load i64, i64* %lnbsk, !tbaa !2
  %lnbsm = load i64, i64* %lsaDK
  %lnbsn = add i64 %lnbsl, %lnbsm
  %lnbso = shl i64 %lnbsn, 3
  %lnbsp = add i64 %lnbso, 24
  %lnbsq = add i64 %lnbsh, %lnbsp
  %lnbsr = inttoptr i64 %lnbsq to i64*
  %lnbss = load i64, i64* %lnbsr, !tbaa !1
  %lnbsd = load i64*, i64** %Hp_Var
  %lnbst = getelementptr inbounds i64, i64* %lnbsd, i32 0
  store i64 %lnbss, i64* %lnbst, !tbaa !3
  %lnbsu = load i64*, i64** %Sp_Var
  %lnbsv = getelementptr inbounds i64, i64* %lnbsu, i32 3
  %lnbsw = bitcast i64* %lnbsv to i64*
  %lnbsx = load i64, i64* %lnbsw, !tbaa !2
  store i64 %lnbsx, i64* %lsaDA
  %lnbsy = load i64, i64* %lsaDA
  %lnbsz = add i64 %lnbsy, 24
  %lnbsA = load i64, i64* %lsaDL
  %lnbsB = shl i64 %lnbsA, 3
  %lnbsC = add i64 %lnbsz, %lnbsB
  %lnbsD = load i64*, i64** %Hp_Var
  %lnbsE = getelementptr inbounds i64, i64* %lnbsD, i32 -2
  %lnbsF = ptrtoint i64* %lnbsE to i64
  %lnbsG = inttoptr i64 %lnbsC to i64*
  store i64 %lnbsF, i64* %lnbsG, !tbaa !1
  %lnbsH = load i64, i64* %lsaDA
  %lnbsI = ptrtoint i8* @stg_MUT_ARR_PTRS_DIRTY_info to i64
  %lnbsJ = inttoptr i64 %lnbsH to i64*
  store i64 %lnbsI, i64* %lnbsJ, !tbaa !1
  %lnbsK = load i64, i64* %lsaDA
  %lnbsL = add i64 %lnbsK, 24
  %lnbsM = load i64, i64* %lsaDA
  %lnbsN = add i64 %lnbsM, 8
  %lnbsO = inttoptr i64 %lnbsN to i64*
  %lnbsP = load i64, i64* %lnbsO, !tbaa !1
  %lnbsQ = shl i64 %lnbsP, 3
  %lnbsR = load i64, i64* %lsaDL
  %lnbsS = lshr i64 %lnbsR, 7
  %lnbsT = add i64 %lnbsQ, %lnbsS
  %lnbsU = add i64 %lnbsL, %lnbsT
  %lnbsV = inttoptr i64 %lnbsU to i8*
  store i8 1, i8* %lnbsV, !tbaa !1
  %lnbsX = load i64, i64* %lsaDK
  %lnbsY = add i64 %lnbsX, 1
  %lnbsW = load i64*, i64** %Sp_Var
  %lnbsZ = getelementptr inbounds i64, i64* %lnbsW, i32 1
  store i64 %lnbsY, i64* %lnbsZ, !tbaa !2
  %lnbt1 = load i64, i64* %lsaDL
  %lnbt2 = add i64 %lnbt1, 1
  %lnbt0 = load i64*, i64** %Sp_Var
  %lnbt3 = getelementptr inbounds i64, i64* %lnbt0, i32 2
  store i64 %lnbt2, i64* %lnbt3, !tbaa !2
  %lnbt4 = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbaG_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbt5 = load i64*, i64** %Sp_Var
  %lnbt6 = load i64*, i64** %Hp_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbt4( i64* %Base_Arg, i64* %lnbt5, i64* %lnbt6, i64 %R1_Arg, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cbbp:
  %lnbt7 = load i64*, i64** %Hp_Var
  %lnbt8 = getelementptr inbounds i64, i64* %lnbt7, i32 -3
  %lnbt9 = ptrtoint i64* %lnbt8 to i64
  %lnbta = inttoptr i64 %lnbt9 to i64*
  store i64* %lnbta, i64** %Hp_Var
  %lnbtc = load i64, i64* %lsaDL
  %lnbtb = load i64*, i64** %Sp_Var
  %lnbtd = getelementptr inbounds i64, i64* %lnbtb, i32 6
  store i64 %lnbtc, i64* %lnbtd, !tbaa !2
  %lnbte = load i64*, i64** %Sp_Var
  %lnbtf = getelementptr inbounds i64, i64* %lnbte, i32 3
  %lnbtg = ptrtoint i64* %lnbtf to i64
  %lnbth = inttoptr i64 %lnbtg to i64*
  store i64* %lnbth, i64** %Sp_Var
  %lnbti = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @_cbbf$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbtj = load i64*, i64** %Sp_Var
  %lnbtk = load i64*, i64** %Hp_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbti( i64* %Base_Arg, i64* %lnbtj, i64* %lnbtk, i64 %R1_Arg, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cbbm:
  %lnbtl = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 24, i64* %lnbtl, !tbaa !5
  %lnbtn = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbaG_info$def to i64
  %lnbtm = load i64*, i64** %Sp_Var
  %lnbto = getelementptr inbounds i64, i64* %lnbtm, i32 0
  store i64 %lnbtn, i64* %lnbto, !tbaa !2
  %lnbtp = bitcast i8* @stg_gc_noregs to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbtq = load i64*, i64** %Sp_Var
  %lnbtr = load i64*, i64** %Hp_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbtp( i64* %Base_Arg, i64* %lnbtq, i64* %lnbtr, i64 %R1_Arg, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@_cbbf = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @_cbbf$def to i8*)
define internal ghccc void @_cbbf$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind
{
cbbf:
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %lsaDD = alloca i64, i32 1
  %lsaDA = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnbts = load i64*, i64** %Hp_Var
  %lnbtt = getelementptr inbounds i64, i64* %lnbts, i32 4
  %lnbtu = ptrtoint i64* %lnbtt to i64
  %lnbtv = inttoptr i64 %lnbtu to i64*
  store i64* %lnbtv, i64** %Hp_Var
  %lnbtw = load i64*, i64** %Sp_Var
  %lnbtx = getelementptr inbounds i64, i64* %lnbtw, i32 3
  %lnbty = bitcast i64* %lnbtx to i64*
  %lnbtz = load i64, i64* %lnbty, !tbaa !2
  store i64 %lnbtz, i64* %lsaDD
  %lnbtA = load i64*, i64** %Hp_Var
  %lnbtB = ptrtoint i64* %lnbtA to i64
  %lnbtC = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lnbtD = bitcast i64* %lnbtC to i64*
  %lnbtE = load i64, i64* %lnbtD, !tbaa !5
  %lnbtF = icmp ugt i64 %lnbtB, %lnbtE
  %lnbtG = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnbtF, i1 0 )
  br i1 %lnbtG, label %cbbj, label %cbbi
cbbi:
  %lnbtH = load i64*, i64** %Sp_Var
  %lnbtI = getelementptr inbounds i64, i64* %lnbtH, i32 0
  %lnbtJ = bitcast i64* %lnbtI to i64*
  %lnbtK = load i64, i64* %lnbtJ, !tbaa !2
  store i64 %lnbtK, i64* %lsaDA
  %lnbtL = load i64, i64* %lsaDA
  %lnbtM = ptrtoint i8* @stg_MUT_ARR_PTRS_FROZEN_DIRTY_info to i64
  %lnbtN = inttoptr i64 %lnbtL to i64*
  store i64 %lnbtM, i64* %lnbtN, !tbaa !1
  %lnbtP = ptrtoint i8* @vctrzm0zi12zi0zi2zm9a8f7398_DataziVector_Vector_con_info to i64
  %lnbtO = load i64*, i64** %Hp_Var
  %lnbtQ = getelementptr inbounds i64, i64* %lnbtO, i32 -3
  store i64 %lnbtP, i64* %lnbtQ, !tbaa !3
  %lnbtS = load i64, i64* %lsaDA
  %lnbtR = load i64*, i64** %Hp_Var
  %lnbtT = getelementptr inbounds i64, i64* %lnbtR, i32 -2
  store i64 %lnbtS, i64* %lnbtT, !tbaa !3
  %lnbtU = load i64*, i64** %Hp_Var
  %lnbtV = getelementptr inbounds i64, i64* %lnbtU, i32 -1
  store i64 0, i64* %lnbtV, !tbaa !3
  %lnbtX = load i64, i64* %lsaDD
  %lnbtW = load i64*, i64** %Hp_Var
  %lnbtY = getelementptr inbounds i64, i64* %lnbtW, i32 0
  store i64 %lnbtX, i64* %lnbtY, !tbaa !3
  %lnbu0 = load i64*, i64** %Hp_Var
  %lnbu1 = ptrtoint i64* %lnbu0 to i64
  %lnbu2 = add i64 %lnbu1, -23
  %lnbu3 = and i64 %lnbu2, -8
  store i64 %lnbu3, i64* %R1_Var
  %lnbu4 = load i64*, i64** %Sp_Var
  %lnbu5 = getelementptr inbounds i64, i64* %lnbu4, i32 4
  %lnbu6 = ptrtoint i64* %lnbu5 to i64
  %lnbu7 = inttoptr i64 %lnbu6 to i64*
  store i64* %lnbu7, i64** %Sp_Var
  %lnbu9 = load i64, i64* %R1_Var
  %lnbua = inttoptr i64 %lnbu9 to i64*
  %lnbub = load i64, i64* %lnbua, !tbaa !4
  %lnbuc = inttoptr i64 %lnbub to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbud = load i64*, i64** %Sp_Var
  %lnbue = load i64*, i64** %Hp_Var
  %lnbuf = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbuc( i64* %Base_Arg, i64* %lnbud, i64* %lnbue, i64 %lnbuf, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cbbj:
  %lnbug = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 32, i64* %lnbug, !tbaa !5
  %lnbui = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbbe_info$def to i64
  %lnbuh = load i64*, i64** %Sp_Var
  %lnbuj = getelementptr inbounds i64, i64* %lnbuh, i32 -1
  store i64 %lnbui, i64* %lnbuj, !tbaa !2
  %lnbuk = load i64, i64* %lsaDD
  store i64 %lnbuk, i64* %R1_Var
  %lnbul = load i64*, i64** %Sp_Var
  %lnbum = getelementptr inbounds i64, i64* %lnbul, i32 -1
  %lnbun = ptrtoint i64* %lnbum to i64
  %lnbuo = inttoptr i64 %lnbun to i64*
  store i64* %lnbuo, i64** %Sp_Var
  %lnbup = bitcast i8* @stg_gc_unbx_r1 to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbuq = load i64*, i64** %Sp_Var
  %lnbur = load i64*, i64** %Hp_Var
  %lnbus = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbup( i64* %Base_Arg, i64* %lnbuq, i64* %lnbur, i64 %lnbus, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cbbe_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbbe_info$def to i8*)
define internal ghccc void @cbbe_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 900, i32 30, i32 0}>
{
cbbe:
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnbut = load i64*, i64** %Sp_Var
  %lnbuu = getelementptr inbounds i64, i64* %lnbut, i32 4
  store i64 %R1_Arg, i64* %lnbuu, !tbaa !2
  %lnbuv = load i64*, i64** %Sp_Var
  %lnbuw = getelementptr inbounds i64, i64* %lnbuv, i32 1
  %lnbux = ptrtoint i64* %lnbuw to i64
  %lnbuy = inttoptr i64 %lnbux to i64*
  store i64* %lnbuy, i64** %Sp_Var
  %lnbuz = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @_cbbf$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbuA = load i64*, i64** %Sp_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbuz( i64* %Base_Arg, i64* %lnbuA, i64* %Hp_Arg, i64 %R1_Arg, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saE0_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saE0_info$def to i8*)
define internal ghccc void @saE0_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 2, i32 18, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%ubml_srt_struct* @ubml_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saE0_info$def to i64)) to i32),i32 0)}>
{
cbbN:
  %lsaDt = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnbuB = load i64*, i64** %Sp_Var
  %lnbuC = getelementptr inbounds i64, i64* %lnbuB, i32 -4
  %lnbuD = ptrtoint i64* %lnbuC to i64
  %lnbuE = icmp ult i64 %lnbuD, %SpLim_Arg
  %lnbuF = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnbuE, i1 0 )
  br i1 %lnbuF, label %cbbO, label %cbbP
cbbP:
  %lnbuH = ptrtoint i8* @stg_upd_frame_info to i64
  %lnbuG = load i64*, i64** %Sp_Var
  %lnbuI = getelementptr inbounds i64, i64* %lnbuG, i32 -2
  store i64 %lnbuH, i64* %lnbuI, !tbaa !2
  %lnbuK = load i64, i64* %R1_Var
  %lnbuJ = load i64*, i64** %Sp_Var
  %lnbuL = getelementptr inbounds i64, i64* %lnbuJ, i32 -1
  store i64 %lnbuK, i64* %lnbuL, !tbaa !2
  %lnbuN = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbbK_info$def to i64
  %lnbuM = load i64*, i64** %Sp_Var
  %lnbuO = getelementptr inbounds i64, i64* %lnbuM, i32 -4
  store i64 %lnbuN, i64* %lnbuO, !tbaa !2
  %lnbuR = load i64, i64* %R1_Var
  %lnbuS = add i64 %lnbuR, 24
  %lnbuT = inttoptr i64 %lnbuS to i64*
  %lnbuU = load i64, i64* %lnbuT, !tbaa !4
  store i64 %lnbuU, i64* %lsaDt
  %lnbuX = load i64, i64* %R1_Var
  %lnbuY = add i64 %lnbuX, 16
  %lnbuZ = inttoptr i64 %lnbuY to i64*
  %lnbv0 = load i64, i64* %lnbuZ, !tbaa !4
  store i64 %lnbv0, i64* %R1_Var
  %lnbv2 = load i64, i64* %lsaDt
  %lnbv1 = load i64*, i64** %Sp_Var
  %lnbv3 = getelementptr inbounds i64, i64* %lnbv1, i32 -3
  store i64 %lnbv2, i64* %lnbv3, !tbaa !2
  %lnbv4 = load i64*, i64** %Sp_Var
  %lnbv5 = getelementptr inbounds i64, i64* %lnbv4, i32 -4
  %lnbv6 = ptrtoint i64* %lnbv5 to i64
  %lnbv7 = inttoptr i64 %lnbv6 to i64*
  store i64* %lnbv7, i64** %Sp_Var
  %lnbv8 = load i64, i64* %R1_Var
  %lnbv9 = and i64 %lnbv8, 7
  %lnbva = icmp ne i64 %lnbv9, 0
  br i1 %lnbva, label %ubbT, label %cbbL
cbbL:
  %lnbvc = load i64, i64* %R1_Var
  %lnbvd = inttoptr i64 %lnbvc to i64*
  %lnbve = load i64, i64* %lnbvd, !tbaa !4
  %lnbvf = inttoptr i64 %lnbve to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbvg = load i64*, i64** %Sp_Var
  %lnbvh = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbvf( i64* %Base_Arg, i64* %lnbvg, i64* %Hp_Arg, i64 %lnbvh, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ubbT:
  %lnbvi = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbbK_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbvj = load i64*, i64** %Sp_Var
  %lnbvk = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbvi( i64* %Base_Arg, i64* %lnbvj, i64* %Hp_Arg, i64 %lnbvk, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cbbO:
  %lnbvl = load i64, i64* %R1_Var
  store i64 %lnbvl, i64* %R1_Var
  %lnbvm = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lnbvn = bitcast i64* %lnbvm to i64*
  %lnbvo = load i64, i64* %lnbvn, !tbaa !5
  %lnbvp = inttoptr i64 %lnbvo to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbvq = load i64*, i64** %Sp_Var
  %lnbvr = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbvp( i64* %Base_Arg, i64* %lnbvq, i64* %Hp_Arg, i64 %lnbvr, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cbbK_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbbK_info$def to i8*)
define internal ghccc void @cbbK_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 1, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%ubmk_srt_struct* @ubmk_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbbK_info$def to i64)) to i32),i32 0)}>
{
cbbK:
  %R6_Var = alloca i64, i32 1
  store i64 undef, i64* %R6_Var
  %R5_Var = alloca i64, i32 1
  store i64 undef, i64* %R5_Var
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnbvs = load i64*, i64** %Sp_Var
  %lnbvt = getelementptr inbounds i64, i64* %lnbvs, i32 1
  %lnbvu = bitcast i64* %lnbvt to i64*
  %lnbvv = load i64, i64* %lnbvu, !tbaa !2
  store i64 %lnbvv, i64* %R6_Var
  %lnbvw = add i64 %R1_Arg, 7
  %lnbvx = inttoptr i64 %lnbvw to i64*
  %lnbvy = load i64, i64* %lnbvx, !tbaa !4
  store i64 %lnbvy, i64* %R5_Var
  %lnbvz = add i64 %R1_Arg, 23
  %lnbvA = inttoptr i64 %lnbvz to i64*
  %lnbvB = load i64, i64* %lnbvA, !tbaa !4
  store i64 %lnbvB, i64* %R4_Var
  %lnbvC = add i64 %R1_Arg, 15
  %lnbvD = inttoptr i64 %lnbvC to i64*
  %lnbvE = load i64, i64* %lnbvD, !tbaa !4
  store i64 %lnbvE, i64* %R3_Var
  %lnbvF = ptrtoint i8* @base_GHCziFloat_zdfNumDouble_closure to i64
  store i64 %lnbvF, i64* %R2_Var
  %lnbvG = load i64*, i64** %Sp_Var
  %lnbvH = getelementptr inbounds i64, i64* %lnbvG, i32 2
  %lnbvI = ptrtoint i64* %lnbvH to i64
  %lnbvJ = inttoptr i64 %lnbvI to i64*
  store i64* %lnbvJ, i64** %Sp_Var
  %lnbvK = bitcast i8* @hblaszm0zi0zi0zi0zminplace_HBLASziLevel2_zdwgemvzq_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbvL = load i64*, i64** %Sp_Var
  %lnbvM = load i64, i64* %R2_Var
  %lnbvN = load i64, i64* %R3_Var
  %lnbvO = load i64, i64* %R4_Var
  %lnbvP = load i64, i64* %R5_Var
  %lnbvQ = load i64, i64* %R6_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbvK( i64* %Base_Arg, i64* %lnbvL, i64* %Hp_Arg, i64 %R1_Arg, i64 %lnbvM, i64 %lnbvN, i64 %lnbvO, i64 %lnbvP, i64 %lnbvQ, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saE5_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saE5_info$def to i8*)
define internal ghccc void @saE5_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 2, i32 18, i32 0}>
{
cbbZ:
  %lsaE0 = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnbvR = load i64*, i64** %Sp_Var
  %lnbvS = getelementptr inbounds i64, i64* %lnbvR, i32 -13
  %lnbvT = ptrtoint i64* %lnbvS to i64
  %lnbvU = icmp ult i64 %lnbvT, %SpLim_Arg
  %lnbvV = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnbvU, i1 0 )
  br i1 %lnbvV, label %cbc3, label %cbc4
cbc4:
  %lnbvX = ptrtoint i8* @stg_upd_frame_info to i64
  %lnbvW = load i64*, i64** %Sp_Var
  %lnbvY = getelementptr inbounds i64, i64* %lnbvW, i32 -2
  store i64 %lnbvX, i64* %lnbvY, !tbaa !2
  %lnbw0 = load i64, i64* %R1_Var
  %lnbvZ = load i64*, i64** %Sp_Var
  %lnbw1 = getelementptr inbounds i64, i64* %lnbvZ, i32 -1
  store i64 %lnbw0, i64* %lnbw1, !tbaa !2
  %lnbw3 = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbbW_info$def to i64
  %lnbw2 = load i64*, i64** %Sp_Var
  %lnbw4 = getelementptr inbounds i64, i64* %lnbw2, i32 -4
  store i64 %lnbw3, i64* %lnbw4, !tbaa !2
  %lnbw7 = load i64, i64* %R1_Var
  %lnbw8 = add i64 %lnbw7, 24
  %lnbw9 = inttoptr i64 %lnbw8 to i64*
  %lnbwa = load i64, i64* %lnbw9, !tbaa !4
  store i64 %lnbwa, i64* %lsaE0
  %lnbwd = load i64, i64* %R1_Var
  %lnbwe = add i64 %lnbwd, 16
  %lnbwf = inttoptr i64 %lnbwe to i64*
  %lnbwg = load i64, i64* %lnbwf, !tbaa !4
  store i64 %lnbwg, i64* %R1_Var
  %lnbwi = load i64, i64* %lsaE0
  %lnbwh = load i64*, i64** %Sp_Var
  %lnbwj = getelementptr inbounds i64, i64* %lnbwh, i32 -3
  store i64 %lnbwi, i64* %lnbwj, !tbaa !2
  %lnbwk = load i64*, i64** %Sp_Var
  %lnbwl = getelementptr inbounds i64, i64* %lnbwk, i32 -4
  %lnbwm = ptrtoint i64* %lnbwl to i64
  %lnbwn = inttoptr i64 %lnbwm to i64*
  store i64* %lnbwn, i64** %Sp_Var
  %lnbwo = load i64, i64* %R1_Var
  %lnbwp = and i64 %lnbwo, 7
  %lnbwq = icmp ne i64 %lnbwp, 0
  br i1 %lnbwq, label %ubd4, label %cbbX
cbbX:
  %lnbws = load i64, i64* %R1_Var
  %lnbwt = inttoptr i64 %lnbws to i64*
  %lnbwu = load i64, i64* %lnbwt, !tbaa !4
  %lnbwv = inttoptr i64 %lnbwu to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbww = load i64*, i64** %Sp_Var
  %lnbwx = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbwv( i64* %Base_Arg, i64* %lnbww, i64* %Hp_Arg, i64 %lnbwx, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ubd4:
  %lnbwy = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbbW_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbwz = load i64*, i64** %Sp_Var
  %lnbwA = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbwy( i64* %Base_Arg, i64* %lnbwz, i64* %Hp_Arg, i64 %lnbwA, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cbc3:
  %lnbwB = load i64, i64* %R1_Var
  store i64 %lnbwB, i64* %R1_Var
  %lnbwC = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lnbwD = bitcast i64* %lnbwC to i64*
  %lnbwE = load i64, i64* %lnbwD, !tbaa !5
  %lnbwF = inttoptr i64 %lnbwE to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbwG = load i64*, i64** %Sp_Var
  %lnbwH = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbwF( i64* %Base_Arg, i64* %lnbwG, i64* %Hp_Arg, i64 %lnbwH, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cbbW_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbbW_info$def to i8*)
define internal ghccc void @cbbW_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 1, i32 30, i32 0}>
{
cbbW:
  %lsaE9 = alloca i64, i32 1
  %lsaE7 = alloca i64, i32 1
  %lsaE8 = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnbwJ = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbc2_info$def to i64
  %lnbwI = load i64*, i64** %Sp_Var
  %lnbwK = getelementptr inbounds i64, i64* %lnbwI, i32 -2
  store i64 %lnbwJ, i64* %lnbwK, !tbaa !2
  %lnbwN = load i64, i64* %R1_Var
  %lnbwO = add i64 %lnbwN, 7
  %lnbwP = inttoptr i64 %lnbwO to i64*
  %lnbwQ = load i64, i64* %lnbwP, !tbaa !4
  store i64 %lnbwQ, i64* %lsaE9
  %lnbwT = load i64, i64* %R1_Var
  %lnbwU = add i64 %lnbwT, 15
  %lnbwV = inttoptr i64 %lnbwU to i64*
  %lnbwW = load i64, i64* %lnbwV, !tbaa !4
  store i64 %lnbwW, i64* %lsaE7
  %lnbwZ = load i64, i64* %R1_Var
  %lnbx0 = add i64 %lnbwZ, 23
  %lnbx1 = inttoptr i64 %lnbx0 to i64*
  %lnbx2 = load i64, i64* %lnbx1, !tbaa !4
  store i64 %lnbx2, i64* %lsaE8
  %lnbx3 = load i64*, i64** %Sp_Var
  %lnbx4 = getelementptr inbounds i64, i64* %lnbx3, i32 1
  %lnbx5 = bitcast i64* %lnbx4 to i64*
  %lnbx6 = load i64, i64* %lnbx5, !tbaa !2
  store i64 %lnbx6, i64* %R1_Var
  %lnbx8 = load i64, i64* %lsaE9
  %lnbx7 = load i64*, i64** %Sp_Var
  %lnbx9 = getelementptr inbounds i64, i64* %lnbx7, i32 -1
  store i64 %lnbx8, i64* %lnbx9, !tbaa !2
  %lnbxb = load i64, i64* %lsaE8
  %lnbxa = load i64*, i64** %Sp_Var
  %lnbxc = getelementptr inbounds i64, i64* %lnbxa, i32 0
  store i64 %lnbxb, i64* %lnbxc, !tbaa !2
  %lnbxe = load i64, i64* %lsaE7
  %lnbxd = load i64*, i64** %Sp_Var
  %lnbxf = getelementptr inbounds i64, i64* %lnbxd, i32 1
  store i64 %lnbxe, i64* %lnbxf, !tbaa !2
  %lnbxg = load i64*, i64** %Sp_Var
  %lnbxh = getelementptr inbounds i64, i64* %lnbxg, i32 -2
  %lnbxi = ptrtoint i64* %lnbxh to i64
  %lnbxj = inttoptr i64 %lnbxi to i64*
  store i64* %lnbxj, i64** %Sp_Var
  %lnbxk = load i64, i64* %R1_Var
  %lnbxl = and i64 %lnbxk, 7
  %lnbxm = icmp ne i64 %lnbxl, 0
  br i1 %lnbxm, label %ubd3, label %cbc6
cbc6:
  %lnbxo = load i64, i64* %R1_Var
  %lnbxp = inttoptr i64 %lnbxo to i64*
  %lnbxq = load i64, i64* %lnbxp, !tbaa !4
  %lnbxr = inttoptr i64 %lnbxq to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbxs = load i64*, i64** %Sp_Var
  %lnbxt = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbxr( i64* %Base_Arg, i64* %lnbxs, i64* %Hp_Arg, i64 %lnbxt, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ubd3:
  %lnbxu = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbc2_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbxv = load i64*, i64** %Sp_Var
  %lnbxw = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbxu( i64* %Base_Arg, i64* %lnbxv, i64* %Hp_Arg, i64 %lnbxw, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cbc2_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbc2_info$def to i8*)
define internal ghccc void @cbc2_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 387, i32 30, i32 0}>
{
cbc2:
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnbxy = add i64 %R1_Arg, 23
  %lnbxz = inttoptr i64 %lnbxy to i64*
  %lnbxA = load i64, i64* %lnbxz, !tbaa !4
  %lnbxx = load i64*, i64** %Sp_Var
  %lnbxB = getelementptr inbounds i64, i64* %lnbxx, i32 -5
  store i64 %lnbxA, i64* %lnbxB, !tbaa !2
  %lnbxD = add i64 %R1_Arg, 7
  %lnbxE = inttoptr i64 %lnbxD to i64*
  %lnbxF = load i64, i64* %lnbxE, !tbaa !4
  %lnbxC = load i64*, i64** %Sp_Var
  %lnbxG = getelementptr inbounds i64, i64* %lnbxC, i32 -4
  store i64 %lnbxF, i64* %lnbxG, !tbaa !2
  %lnbxH = load i64*, i64** %Sp_Var
  %lnbxI = getelementptr inbounds i64, i64* %lnbxH, i32 -3
  store i64 0, i64* %lnbxI, !tbaa !2
  %lnbxJ = load i64*, i64** %Sp_Var
  %lnbxK = getelementptr inbounds i64, i64* %lnbxJ, i32 -2
  store i64 0, i64* %lnbxK, !tbaa !2
  %lnbxL = load i64*, i64** %Sp_Var
  %lnbxM = getelementptr inbounds i64, i64* %lnbxL, i32 -1
  %lnbxN = bitcast i64* %lnbxM to double*
  store double 0x0000000000000000, double* %lnbxN, !tbaa !2
  %lnbxP = add i64 %R1_Arg, 15
  %lnbxQ = inttoptr i64 %lnbxP to i64*
  %lnbxR = load i64, i64* %lnbxQ, !tbaa !4
  %lnbxO = load i64*, i64** %Sp_Var
  %lnbxS = getelementptr inbounds i64, i64* %lnbxO, i32 0
  store i64 %lnbxR, i64* %lnbxS, !tbaa !2
  %lnbxT = load i64*, i64** %Sp_Var
  %lnbxU = getelementptr inbounds i64, i64* %lnbxT, i32 -6
  %lnbxV = ptrtoint i64* %lnbxU to i64
  %lnbxW = inttoptr i64 %lnbxV to i64*
  store i64* %lnbxW, i64** %Sp_Var
  %lnbxX = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbcd_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbxY = load i64*, i64** %Sp_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbxX( i64* %Base_Arg, i64* %lnbxY, i64* %Hp_Arg, i64 %R1_Arg, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cbcd_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbcd_info$def to i8*)
define internal ghccc void @cbcd_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 28489, i32 30, i32 0}>
{
cbcd:
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %lsaEg = alloca i64, i32 1
  %lsaEh = alloca double, i32 1
  %lsaEf = alloca i64, i32 1
  %lsaEl = alloca i64, i32 1
  %lsaEp = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnbxZ = load i64*, i64** %Hp_Var
  %lnby0 = getelementptr inbounds i64, i64* %lnbxZ, i32 2
  %lnby1 = ptrtoint i64* %lnby0 to i64
  %lnby2 = inttoptr i64 %lnby1 to i64*
  store i64* %lnby2, i64** %Hp_Var
  %lnby3 = load i64*, i64** %Hp_Var
  %lnby4 = ptrtoint i64* %lnby3 to i64
  %lnby5 = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lnby6 = bitcast i64* %lnby5 to i64*
  %lnby7 = load i64, i64* %lnby6, !tbaa !5
  %lnby8 = icmp ugt i64 %lnby4, %lnby7
  %lnby9 = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnby8, i1 0 )
  br i1 %lnby9, label %cbci, label %cbch
cbch:
  %lnbya = load i64*, i64** %Sp_Var
  %lnbyb = getelementptr inbounds i64, i64* %lnbya, i32 4
  %lnbyc = bitcast i64* %lnbyb to i64*
  %lnbyd = load i64, i64* %lnbyc, !tbaa !2
  store i64 %lnbyd, i64* %lsaEg
  %lnbye = load i64*, i64** %Sp_Var
  %lnbyf = getelementptr inbounds i64, i64* %lnbye, i32 5
  %lnbyg = bitcast i64* %lnbyf to double*
  %lnbyh = load double, double* %lnbyg, !tbaa !2
  store double %lnbyh, double* %lsaEh
  %lnbyi = load i64, i64* %lsaEg
  %lnbyj = load i64*, i64** %Sp_Var
  %lnbyk = getelementptr inbounds i64, i64* %lnbyj, i32 8
  %lnbyl = bitcast i64* %lnbyk to i64*
  %lnbym = load i64, i64* %lnbyl, !tbaa !2
  %lnbyn = icmp sge i64 %lnbyi, %lnbym
  %lnbyo = zext i1 %lnbyn to i64
  switch i64 %lnbyo, label %cbcN [i64 1, label %cbcQ]
cbcN:
  %lnbyp = load i64*, i64** %Sp_Var
  %lnbyq = getelementptr inbounds i64, i64* %lnbyp, i32 3
  %lnbyr = bitcast i64* %lnbyq to i64*
  %lnbys = load i64, i64* %lnbyr, !tbaa !2
  store i64 %lnbys, i64* %lsaEf
  %lnbyt = load i64, i64* %lsaEf
  %lnbyu = load i64*, i64** %Sp_Var
  %lnbyv = getelementptr inbounds i64, i64* %lnbyu, i32 1
  %lnbyw = bitcast i64* %lnbyv to i64*
  %lnbyx = load i64, i64* %lnbyw, !tbaa !2
  %lnbyy = icmp sge i64 %lnbyt, %lnbyx
  %lnbyz = zext i1 %lnbyy to i64
  switch i64 %lnbyz, label %cbcC [i64 1, label %cbcL]
cbcC:
  %lnbyA = load i64*, i64** %Hp_Var
  %lnbyB = getelementptr inbounds i64, i64* %lnbyA, i32 -2
  %lnbyC = ptrtoint i64* %lnbyB to i64
  %lnbyD = inttoptr i64 %lnbyC to i64*
  store i64* %lnbyD, i64** %Hp_Var
  %lnbyE = load i64*, i64** %Sp_Var
  %lnbyF = getelementptr inbounds i64, i64* %lnbyE, i32 7
  %lnbyG = bitcast i64* %lnbyF to i64*
  %lnbyH = load i64, i64* %lnbyG, !tbaa !2
  %lnbyI = load i64*, i64** %Sp_Var
  %lnbyJ = getelementptr inbounds i64, i64* %lnbyI, i32 9
  %lnbyK = bitcast i64* %lnbyJ to i64*
  %lnbyL = load i64, i64* %lnbyK, !tbaa !2
  %lnbyM = load i64, i64* %lsaEg
  %lnbyN = add i64 %lnbyL, %lnbyM
  %lnbyO = shl i64 %lnbyN, 3
  %lnbyP = add i64 %lnbyO, 24
  %lnbyQ = add i64 %lnbyH, %lnbyP
  %lnbyR = inttoptr i64 %lnbyQ to i64*
  %lnbyS = load i64, i64* %lnbyR, !tbaa !1
  store i64 %lnbyS, i64* %lsaEl
  %lnbyT = load i64*, i64** %Sp_Var
  %lnbyU = getelementptr inbounds i64, i64* %lnbyT, i32 2
  %lnbyV = bitcast i64* %lnbyU to i64*
  %lnbyW = load i64, i64* %lnbyV, !tbaa !2
  %lnbyX = load i64*, i64** %Sp_Var
  %lnbyY = getelementptr inbounds i64, i64* %lnbyX, i32 6
  %lnbyZ = bitcast i64* %lnbyY to i64*
  %lnbz0 = load i64, i64* %lnbyZ, !tbaa !2
  %lnbz1 = load i64, i64* %lsaEf
  %lnbz2 = add i64 %lnbz0, %lnbz1
  %lnbz3 = shl i64 %lnbz2, 3
  %lnbz4 = add i64 %lnbz3, 24
  %lnbz5 = add i64 %lnbyW, %lnbz4
  %lnbz6 = inttoptr i64 %lnbz5 to i64*
  %lnbz7 = load i64, i64* %lnbz6, !tbaa !1
  store i64 %lnbz7, i64* %lsaEp
  %lnbz9 = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbcv_info$def to i64
  %lnbz8 = load i64*, i64** %Sp_Var
  %lnbza = getelementptr inbounds i64, i64* %lnbz8, i32 -1
  store i64 %lnbz9, i64* %lnbza, !tbaa !2
  %lnbzb = load i64, i64* %lsaEl
  store i64 %lnbzb, i64* %R1_Var
  %lnbzd = load i64, i64* %lsaEp
  %lnbzc = load i64*, i64** %Sp_Var
  %lnbze = getelementptr inbounds i64, i64* %lnbzc, i32 0
  store i64 %lnbzd, i64* %lnbze, !tbaa !2
  %lnbzf = load i64*, i64** %Sp_Var
  %lnbzg = getelementptr inbounds i64, i64* %lnbzf, i32 -1
  %lnbzh = ptrtoint i64* %lnbzg to i64
  %lnbzi = inttoptr i64 %lnbzh to i64*
  store i64* %lnbzi, i64** %Sp_Var
  %lnbzj = load i64, i64* %R1_Var
  %lnbzk = and i64 %lnbzj, 7
  %lnbzl = icmp ne i64 %lnbzk, 0
  br i1 %lnbzl, label %ubd6, label %cbcw
cbcw:
  %lnbzn = load i64, i64* %R1_Var
  %lnbzo = inttoptr i64 %lnbzn to i64*
  %lnbzp = load i64, i64* %lnbzo, !tbaa !4
  %lnbzq = inttoptr i64 %lnbzp to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbzr = load i64*, i64** %Sp_Var
  %lnbzs = load i64*, i64** %Hp_Var
  %lnbzt = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbzq( i64* %Base_Arg, i64* %lnbzr, i64* %lnbzs, i64 %lnbzt, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ubd6:
  %lnbzu = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbcv_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbzv = load i64*, i64** %Sp_Var
  %lnbzw = load i64*, i64** %Hp_Var
  %lnbzx = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbzu( i64* %Base_Arg, i64* %lnbzv, i64* %lnbzw, i64 %lnbzx, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cbcL:
  %lnbzz = ptrtoint i8* @ghczmprim_GHCziTypes_Dzh_con_info to i64
  %lnbzy = load i64*, i64** %Hp_Var
  %lnbzA = getelementptr inbounds i64, i64* %lnbzy, i32 -1
  store i64 %lnbzz, i64* %lnbzA, !tbaa !3
  %lnbzC = load double, double* %lsaEh
  %lnbzB = load i64*, i64** %Hp_Var
  %lnbzD = getelementptr inbounds i64, i64* %lnbzB, i32 0
  %lnbzE = bitcast i64* %lnbzD to double*
  store double %lnbzC, double* %lnbzE, !tbaa !3
  %lnbzG = load i64*, i64** %Hp_Var
  %lnbzH = ptrtoint i64* %lnbzG to i64
  %lnbzI = add i64 %lnbzH, -7
  store i64 %lnbzI, i64* %R1_Var
  %lnbzJ = load i64*, i64** %Sp_Var
  %lnbzK = getelementptr inbounds i64, i64* %lnbzJ, i32 10
  %lnbzL = ptrtoint i64* %lnbzK to i64
  %lnbzM = inttoptr i64 %lnbzL to i64*
  store i64* %lnbzM, i64** %Sp_Var
  %lnbzN = load i64*, i64** %Sp_Var
  %lnbzO = getelementptr inbounds i64, i64* %lnbzN, i32 0
  %lnbzP = bitcast i64* %lnbzO to i64*
  %lnbzQ = load i64, i64* %lnbzP, !tbaa !2
  %lnbzR = inttoptr i64 %lnbzQ to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbzS = load i64*, i64** %Sp_Var
  %lnbzT = load i64*, i64** %Hp_Var
  %lnbzU = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbzR( i64* %Base_Arg, i64* %lnbzS, i64* %lnbzT, i64 %lnbzU, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cbcQ:
  %lnbzW = ptrtoint i8* @ghczmprim_GHCziTypes_Dzh_con_info to i64
  %lnbzV = load i64*, i64** %Hp_Var
  %lnbzX = getelementptr inbounds i64, i64* %lnbzV, i32 -1
  store i64 %lnbzW, i64* %lnbzX, !tbaa !3
  %lnbzZ = load double, double* %lsaEh
  %lnbzY = load i64*, i64** %Hp_Var
  %lnbA0 = getelementptr inbounds i64, i64* %lnbzY, i32 0
  %lnbA1 = bitcast i64* %lnbA0 to double*
  store double %lnbzZ, double* %lnbA1, !tbaa !3
  %lnbA3 = load i64*, i64** %Hp_Var
  %lnbA4 = ptrtoint i64* %lnbA3 to i64
  %lnbA5 = add i64 %lnbA4, -7
  store i64 %lnbA5, i64* %R1_Var
  %lnbA6 = load i64*, i64** %Sp_Var
  %lnbA7 = getelementptr inbounds i64, i64* %lnbA6, i32 10
  %lnbA8 = ptrtoint i64* %lnbA7 to i64
  %lnbA9 = inttoptr i64 %lnbA8 to i64*
  store i64* %lnbA9, i64** %Sp_Var
  %lnbAa = load i64*, i64** %Sp_Var
  %lnbAb = getelementptr inbounds i64, i64* %lnbAa, i32 0
  %lnbAc = bitcast i64* %lnbAb to i64*
  %lnbAd = load i64, i64* %lnbAc, !tbaa !2
  %lnbAe = inttoptr i64 %lnbAd to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbAf = load i64*, i64** %Sp_Var
  %lnbAg = load i64*, i64** %Hp_Var
  %lnbAh = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbAe( i64* %Base_Arg, i64* %lnbAf, i64* %lnbAg, i64 %lnbAh, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cbci:
  %lnbAi = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 16, i64* %lnbAi, !tbaa !5
  %lnbAk = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbcd_info$def to i64
  %lnbAj = load i64*, i64** %Sp_Var
  %lnbAl = getelementptr inbounds i64, i64* %lnbAj, i32 0
  store i64 %lnbAk, i64* %lnbAl, !tbaa !2
  %lnbAm = bitcast i8* @stg_gc_noregs to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbAn = load i64*, i64** %Sp_Var
  %lnbAo = load i64*, i64** %Hp_Var
  %lnbAp = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbAm( i64* %Base_Arg, i64* %lnbAn, i64* %lnbAo, i64 %lnbAp, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cbcv_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbcv_info$def to i8*)
define internal ghccc void @cbcv_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 56970, i32 30, i32 0}>
{
cbcv:
  %lsaEr = alloca double, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lnbAq = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbcA_info$def to i64
  %lnbAr = getelementptr inbounds i64, i64* %Sp_Arg, i32 0
  store i64 %lnbAq, i64* %lnbAr, !tbaa !2
  %lnbAu = load i64, i64* %R1_Var
  %lnbAv = add i64 %lnbAu, 7
  %lnbAw = inttoptr i64 %lnbAv to double*
  %lnbAx = load double, double* %lnbAw, !tbaa !4
  store double %lnbAx, double* %lsaEr
  %lnbAy = getelementptr inbounds i64, i64* %Sp_Arg, i32 1
  %lnbAz = bitcast i64* %lnbAy to i64*
  %lnbAA = load i64, i64* %lnbAz, !tbaa !2
  store i64 %lnbAA, i64* %R1_Var
  %lnbAB = load double, double* %lsaEr
  %lnbAC = getelementptr inbounds i64, i64* %Sp_Arg, i32 1
  %lnbAD = bitcast i64* %lnbAC to double*
  store double %lnbAB, double* %lnbAD, !tbaa !2
  %lnbAE = load i64, i64* %R1_Var
  %lnbAF = and i64 %lnbAE, 7
  %lnbAG = icmp ne i64 %lnbAF, 0
  br i1 %lnbAG, label %ubd7, label %cbcE
cbcE:
  %lnbAI = load i64, i64* %R1_Var
  %lnbAJ = inttoptr i64 %lnbAI to i64*
  %lnbAK = load i64, i64* %lnbAJ, !tbaa !4
  %lnbAL = inttoptr i64 %lnbAK to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbAM = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbAL( i64* %Base_Arg, i64* %Sp_Arg, i64* %Hp_Arg, i64 %lnbAM, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ubd7:
  %lnbAN = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbcA_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbAO = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbAN( i64* %Base_Arg, i64* %Sp_Arg, i64* %Hp_Arg, i64 %lnbAO, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cbcA_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbcA_info$def to i8*)
define internal ghccc void @cbcA_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 57034, i32 30, i32 0}>
{
cbcA:
  %lsaEh = alloca double, i32 1
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnbAP = load i64*, i64** %Sp_Var
  %lnbAQ = getelementptr inbounds i64, i64* %lnbAP, i32 6
  %lnbAR = bitcast i64* %lnbAQ to double*
  %lnbAS = load double, double* %lnbAR, !tbaa !2
  %lnbAT = load i64*, i64** %Sp_Var
  %lnbAU = getelementptr inbounds i64, i64* %lnbAT, i32 1
  %lnbAV = bitcast i64* %lnbAU to double*
  %lnbAW = load double, double* %lnbAV, !tbaa !2
  %lnbAX = add i64 %R1_Arg, 7
  %lnbAY = inttoptr i64 %lnbAX to double*
  %lnbAZ = load double, double* %lnbAY, !tbaa !4
  %lnbB0 = fmul double %lnbAW, %lnbAZ
  %lnbB1 = fadd double %lnbAS, %lnbB0
  store double %lnbB1, double* %lsaEh
  %lnbB3 = load i64*, i64** %Sp_Var
  %lnbB4 = getelementptr inbounds i64, i64* %lnbB3, i32 4
  %lnbB5 = bitcast i64* %lnbB4 to i64*
  %lnbB6 = load i64, i64* %lnbB5, !tbaa !2
  %lnbB7 = add i64 %lnbB6, 1
  %lnbB2 = load i64*, i64** %Sp_Var
  %lnbB8 = getelementptr inbounds i64, i64* %lnbB2, i32 4
  store i64 %lnbB7, i64* %lnbB8, !tbaa !2
  %lnbBa = load i64*, i64** %Sp_Var
  %lnbBb = getelementptr inbounds i64, i64* %lnbBa, i32 5
  %lnbBc = bitcast i64* %lnbBb to i64*
  %lnbBd = load i64, i64* %lnbBc, !tbaa !2
  %lnbBe = add i64 %lnbBd, 1
  %lnbB9 = load i64*, i64** %Sp_Var
  %lnbBf = getelementptr inbounds i64, i64* %lnbB9, i32 5
  store i64 %lnbBe, i64* %lnbBf, !tbaa !2
  %lnbBh = load double, double* %lsaEh
  %lnbBg = load i64*, i64** %Sp_Var
  %lnbBi = getelementptr inbounds i64, i64* %lnbBg, i32 6
  %lnbBj = bitcast i64* %lnbBi to double*
  store double %lnbBh, double* %lnbBj, !tbaa !2
  %lnbBk = load i64*, i64** %Sp_Var
  %lnbBl = getelementptr inbounds i64, i64* %lnbBk, i32 1
  %lnbBm = ptrtoint i64* %lnbBl to i64
  %lnbBn = inttoptr i64 %lnbBm to i64*
  store i64* %lnbBn, i64** %Sp_Var
  %lnbBo = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbcd_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbBp = load i64*, i64** %Sp_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbBo( i64* %Base_Arg, i64* %lnbBp, i64* %Hp_Arg, i64 %R1_Arg, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saEy_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saEy_info$def to i8*)
define internal ghccc void @saEy_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 3, i32 15, i32 0}>
{
cbde:
  %lsaDn = alloca i64, i32 1
  %lsaE5 = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnbBq = load i64*, i64** %Sp_Var
  %lnbBr = getelementptr inbounds i64, i64* %lnbBq, i32 -14
  %lnbBs = ptrtoint i64* %lnbBr to i64
  %lnbBt = icmp ult i64 %lnbBs, %SpLim_Arg
  %lnbBu = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnbBt, i1 0 )
  br i1 %lnbBu, label %cbdi, label %cbdj
cbdj:
  %lnbBw = ptrtoint i8* @stg_upd_frame_info to i64
  %lnbBv = load i64*, i64** %Sp_Var
  %lnbBx = getelementptr inbounds i64, i64* %lnbBv, i32 -2
  store i64 %lnbBw, i64* %lnbBx, !tbaa !2
  %lnbBz = load i64, i64* %R1_Var
  %lnbBy = load i64*, i64** %Sp_Var
  %lnbBA = getelementptr inbounds i64, i64* %lnbBy, i32 -1
  store i64 %lnbBz, i64* %lnbBA, !tbaa !2
  %lnbBC = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbdb_info$def to i64
  %lnbBB = load i64*, i64** %Sp_Var
  %lnbBD = getelementptr inbounds i64, i64* %lnbBB, i32 -5
  store i64 %lnbBC, i64* %lnbBD, !tbaa !2
  %lnbBG = load i64, i64* %R1_Var
  %lnbBH = add i64 %lnbBG, 16
  %lnbBI = inttoptr i64 %lnbBH to i64*
  %lnbBJ = load i64, i64* %lnbBI, !tbaa !4
  store i64 %lnbBJ, i64* %lsaDn
  %lnbBM = load i64, i64* %R1_Var
  %lnbBN = add i64 %lnbBM, 32
  %lnbBO = inttoptr i64 %lnbBN to i64*
  %lnbBP = load i64, i64* %lnbBO, !tbaa !4
  store i64 %lnbBP, i64* %lsaE5
  %lnbBS = load i64, i64* %R1_Var
  %lnbBT = add i64 %lnbBS, 24
  %lnbBU = inttoptr i64 %lnbBT to i64*
  %lnbBV = load i64, i64* %lnbBU, !tbaa !4
  store i64 %lnbBV, i64* %R1_Var
  %lnbBX = load i64, i64* %lsaDn
  %lnbBW = load i64*, i64** %Sp_Var
  %lnbBY = getelementptr inbounds i64, i64* %lnbBW, i32 -4
  store i64 %lnbBX, i64* %lnbBY, !tbaa !2
  %lnbC0 = load i64, i64* %lsaE5
  %lnbBZ = load i64*, i64** %Sp_Var
  %lnbC1 = getelementptr inbounds i64, i64* %lnbBZ, i32 -3
  store i64 %lnbC0, i64* %lnbC1, !tbaa !2
  %lnbC2 = load i64*, i64** %Sp_Var
  %lnbC3 = getelementptr inbounds i64, i64* %lnbC2, i32 -5
  %lnbC4 = ptrtoint i64* %lnbC3 to i64
  %lnbC5 = inttoptr i64 %lnbC4 to i64*
  store i64* %lnbC5, i64** %Sp_Var
  %lnbC6 = load i64, i64* %R1_Var
  %lnbC7 = and i64 %lnbC6, 7
  %lnbC8 = icmp ne i64 %lnbC7, 0
  br i1 %lnbC8, label %ubeN, label %cbdc
cbdc:
  %lnbCa = load i64, i64* %R1_Var
  %lnbCb = inttoptr i64 %lnbCa to i64*
  %lnbCc = load i64, i64* %lnbCb, !tbaa !4
  %lnbCd = inttoptr i64 %lnbCc to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbCe = load i64*, i64** %Sp_Var
  %lnbCf = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbCd( i64* %Base_Arg, i64* %lnbCe, i64* %Hp_Arg, i64 %lnbCf, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ubeN:
  %lnbCg = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbdb_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbCh = load i64*, i64** %Sp_Var
  %lnbCi = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbCg( i64* %Base_Arg, i64* %lnbCh, i64* %Hp_Arg, i64 %lnbCi, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cbdi:
  %lnbCj = load i64, i64* %R1_Var
  store i64 %lnbCj, i64* %R1_Var
  %lnbCk = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lnbCl = bitcast i64* %lnbCk to i64*
  %lnbCm = load i64, i64* %lnbCl, !tbaa !5
  %lnbCn = inttoptr i64 %lnbCm to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbCo = load i64*, i64** %Sp_Var
  %lnbCp = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbCn( i64* %Base_Arg, i64* %lnbCo, i64* %Hp_Arg, i64 %lnbCp, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cbdb_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbdb_info$def to i8*)
define internal ghccc void @cbdb_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 2, i32 30, i32 0}>
{
cbdb:
  %lsaEC = alloca i64, i32 1
  %lsaEA = alloca i64, i32 1
  %lsaEB = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnbCr = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbdh_info$def to i64
  %lnbCq = load i64*, i64** %Sp_Var
  %lnbCs = getelementptr inbounds i64, i64* %lnbCq, i32 -2
  store i64 %lnbCr, i64* %lnbCs, !tbaa !2
  %lnbCv = load i64, i64* %R1_Var
  %lnbCw = add i64 %lnbCv, 7
  %lnbCx = inttoptr i64 %lnbCw to i64*
  %lnbCy = load i64, i64* %lnbCx, !tbaa !4
  store i64 %lnbCy, i64* %lsaEC
  %lnbCB = load i64, i64* %R1_Var
  %lnbCC = add i64 %lnbCB, 15
  %lnbCD = inttoptr i64 %lnbCC to i64*
  %lnbCE = load i64, i64* %lnbCD, !tbaa !4
  store i64 %lnbCE, i64* %lsaEA
  %lnbCH = load i64, i64* %R1_Var
  %lnbCI = add i64 %lnbCH, 23
  %lnbCJ = inttoptr i64 %lnbCI to i64*
  %lnbCK = load i64, i64* %lnbCJ, !tbaa !4
  store i64 %lnbCK, i64* %lsaEB
  %lnbCL = load i64*, i64** %Sp_Var
  %lnbCM = getelementptr inbounds i64, i64* %lnbCL, i32 1
  %lnbCN = bitcast i64* %lnbCM to i64*
  %lnbCO = load i64, i64* %lnbCN, !tbaa !2
  store i64 %lnbCO, i64* %R1_Var
  %lnbCQ = load i64, i64* %lsaEC
  %lnbCP = load i64*, i64** %Sp_Var
  %lnbCR = getelementptr inbounds i64, i64* %lnbCP, i32 -1
  store i64 %lnbCQ, i64* %lnbCR, !tbaa !2
  %lnbCT = load i64, i64* %lsaEB
  %lnbCS = load i64*, i64** %Sp_Var
  %lnbCU = getelementptr inbounds i64, i64* %lnbCS, i32 0
  store i64 %lnbCT, i64* %lnbCU, !tbaa !2
  %lnbCW = load i64, i64* %lsaEA
  %lnbCV = load i64*, i64** %Sp_Var
  %lnbCX = getelementptr inbounds i64, i64* %lnbCV, i32 1
  store i64 %lnbCW, i64* %lnbCX, !tbaa !2
  %lnbCY = load i64*, i64** %Sp_Var
  %lnbCZ = getelementptr inbounds i64, i64* %lnbCY, i32 -2
  %lnbD0 = ptrtoint i64* %lnbCZ to i64
  %lnbD1 = inttoptr i64 %lnbD0 to i64*
  store i64* %lnbD1, i64** %Sp_Var
  %lnbD2 = load i64, i64* %R1_Var
  %lnbD3 = and i64 %lnbD2, 7
  %lnbD4 = icmp ne i64 %lnbD3, 0
  br i1 %lnbD4, label %ubeM, label %cbdl
cbdl:
  %lnbD6 = load i64, i64* %R1_Var
  %lnbD7 = inttoptr i64 %lnbD6 to i64*
  %lnbD8 = load i64, i64* %lnbD7, !tbaa !4
  %lnbD9 = inttoptr i64 %lnbD8 to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbDa = load i64*, i64** %Sp_Var
  %lnbDb = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbD9( i64* %Base_Arg, i64* %lnbDa, i64* %Hp_Arg, i64 %lnbDb, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ubeM:
  %lnbDc = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbdh_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbDd = load i64*, i64** %Sp_Var
  %lnbDe = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbDc( i64* %Base_Arg, i64* %lnbDd, i64* %Hp_Arg, i64 %lnbDe, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cbdh_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbdh_info$def to i8*)
define internal ghccc void @cbdh_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 388, i32 30, i32 0}>
{
cbdh:
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnbDg = add i64 %R1_Arg, 23
  %lnbDh = inttoptr i64 %lnbDg to i64*
  %lnbDi = load i64, i64* %lnbDh, !tbaa !4
  %lnbDf = load i64*, i64** %Sp_Var
  %lnbDj = getelementptr inbounds i64, i64* %lnbDf, i32 -5
  store i64 %lnbDi, i64* %lnbDj, !tbaa !2
  %lnbDl = add i64 %R1_Arg, 7
  %lnbDm = inttoptr i64 %lnbDl to i64*
  %lnbDn = load i64, i64* %lnbDm, !tbaa !4
  %lnbDk = load i64*, i64** %Sp_Var
  %lnbDo = getelementptr inbounds i64, i64* %lnbDk, i32 -4
  store i64 %lnbDn, i64* %lnbDo, !tbaa !2
  %lnbDp = load i64*, i64** %Sp_Var
  %lnbDq = getelementptr inbounds i64, i64* %lnbDp, i32 -3
  store i64 0, i64* %lnbDq, !tbaa !2
  %lnbDr = load i64*, i64** %Sp_Var
  %lnbDs = getelementptr inbounds i64, i64* %lnbDr, i32 -2
  store i64 0, i64* %lnbDs, !tbaa !2
  %lnbDt = load i64*, i64** %Sp_Var
  %lnbDu = getelementptr inbounds i64, i64* %lnbDt, i32 -1
  %lnbDv = bitcast i64* %lnbDu to double*
  store double 0x0000000000000000, double* %lnbDv, !tbaa !2
  %lnbDx = add i64 %R1_Arg, 15
  %lnbDy = inttoptr i64 %lnbDx to i64*
  %lnbDz = load i64, i64* %lnbDy, !tbaa !4
  %lnbDw = load i64*, i64** %Sp_Var
  %lnbDA = getelementptr inbounds i64, i64* %lnbDw, i32 0
  store i64 %lnbDz, i64* %lnbDA, !tbaa !2
  %lnbDB = load i64*, i64** %Sp_Var
  %lnbDC = getelementptr inbounds i64, i64* %lnbDB, i32 -5
  %lnbDD = ptrtoint i64* %lnbDC to i64
  %lnbDE = inttoptr i64 %lnbDD to i64*
  store i64* %lnbDE, i64** %Sp_Var
  %lnbDF = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @_cbe2$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbDG = load i64*, i64** %Sp_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbDF( i64* %Base_Arg, i64* %lnbDG, i64* %Hp_Arg, i64 %R1_Arg, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@_cbe2 = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @_cbe2$def to i8*)
define internal ghccc void @_cbe2$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind
{
cbe2:
  %lsaE5 = alloca i64, i32 1
  %lsaET = alloca i64, i32 1
  %lsaEU = alloca double, i32 1
  %lsaES = alloca i64, i32 1
  %lsaEY = alloca i64, i32 1
  %lsaF2 = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnbDH = load i64*, i64** %Sp_Var
  %lnbDI = getelementptr inbounds i64, i64* %lnbDH, i32 9
  %lnbDJ = bitcast i64* %lnbDI to i64*
  %lnbDK = load i64, i64* %lnbDJ, !tbaa !2
  store i64 %lnbDK, i64* %lsaE5
  %lnbDL = load i64*, i64** %Sp_Var
  %lnbDM = getelementptr inbounds i64, i64* %lnbDL, i32 3
  %lnbDN = bitcast i64* %lnbDM to i64*
  %lnbDO = load i64, i64* %lnbDN, !tbaa !2
  store i64 %lnbDO, i64* %lsaET
  %lnbDP = load i64*, i64** %Sp_Var
  %lnbDQ = getelementptr inbounds i64, i64* %lnbDP, i32 4
  %lnbDR = bitcast i64* %lnbDQ to double*
  %lnbDS = load double, double* %lnbDR, !tbaa !2
  store double %lnbDS, double* %lsaEU
  %lnbDT = load i64, i64* %lsaET
  %lnbDU = load i64*, i64** %Sp_Var
  %lnbDV = getelementptr inbounds i64, i64* %lnbDU, i32 7
  %lnbDW = bitcast i64* %lnbDV to i64*
  %lnbDX = load i64, i64* %lnbDW, !tbaa !2
  %lnbDY = icmp sge i64 %lnbDT, %lnbDX
  %lnbDZ = zext i1 %lnbDY to i64
  switch i64 %lnbDZ, label %cbey [i64 1, label %cbez]
cbey:
  %lnbE0 = load i64*, i64** %Sp_Var
  %lnbE1 = getelementptr inbounds i64, i64* %lnbE0, i32 2
  %lnbE2 = bitcast i64* %lnbE1 to i64*
  %lnbE3 = load i64, i64* %lnbE2, !tbaa !2
  store i64 %lnbE3, i64* %lsaES
  %lnbE4 = load i64, i64* %lsaES
  %lnbE5 = load i64*, i64** %Sp_Var
  %lnbE6 = getelementptr inbounds i64, i64* %lnbE5, i32 0
  %lnbE7 = bitcast i64* %lnbE6 to i64*
  %lnbE8 = load i64, i64* %lnbE7, !tbaa !2
  %lnbE9 = icmp sge i64 %lnbE4, %lnbE8
  %lnbEa = zext i1 %lnbE9 to i64
  switch i64 %lnbEa, label %cbep [i64 1, label %cbew]
cbep:
  %lnbEb = load i64*, i64** %Sp_Var
  %lnbEc = getelementptr inbounds i64, i64* %lnbEb, i32 6
  %lnbEd = bitcast i64* %lnbEc to i64*
  %lnbEe = load i64, i64* %lnbEd, !tbaa !2
  %lnbEf = load i64*, i64** %Sp_Var
  %lnbEg = getelementptr inbounds i64, i64* %lnbEf, i32 8
  %lnbEh = bitcast i64* %lnbEg to i64*
  %lnbEi = load i64, i64* %lnbEh, !tbaa !2
  %lnbEj = load i64, i64* %lsaET
  %lnbEk = add i64 %lnbEi, %lnbEj
  %lnbEl = shl i64 %lnbEk, 3
  %lnbEm = add i64 %lnbEl, 24
  %lnbEn = add i64 %lnbEe, %lnbEm
  %lnbEo = inttoptr i64 %lnbEn to i64*
  %lnbEp = load i64, i64* %lnbEo, !tbaa !1
  store i64 %lnbEp, i64* %lsaEY
  %lnbEq = load i64*, i64** %Sp_Var
  %lnbEr = getelementptr inbounds i64, i64* %lnbEq, i32 1
  %lnbEs = bitcast i64* %lnbEr to i64*
  %lnbEt = load i64, i64* %lnbEs, !tbaa !2
  %lnbEu = load i64*, i64** %Sp_Var
  %lnbEv = getelementptr inbounds i64, i64* %lnbEu, i32 5
  %lnbEw = bitcast i64* %lnbEv to i64*
  %lnbEx = load i64, i64* %lnbEw, !tbaa !2
  %lnbEy = load i64, i64* %lsaES
  %lnbEz = add i64 %lnbEx, %lnbEy
  %lnbEA = shl i64 %lnbEz, 3
  %lnbEB = add i64 %lnbEA, 24
  %lnbEC = add i64 %lnbEt, %lnbEB
  %lnbED = inttoptr i64 %lnbEC to i64*
  %lnbEE = load i64, i64* %lnbED, !tbaa !1
  store i64 %lnbEE, i64* %lsaF2
  %lnbEG = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbei_info$def to i64
  %lnbEF = load i64*, i64** %Sp_Var
  %lnbEH = getelementptr inbounds i64, i64* %lnbEF, i32 -2
  store i64 %lnbEG, i64* %lnbEH, !tbaa !2
  %lnbEI = load i64, i64* %lsaEY
  store i64 %lnbEI, i64* %R1_Var
  %lnbEK = load i64, i64* %lsaF2
  %lnbEJ = load i64*, i64** %Sp_Var
  %lnbEL = getelementptr inbounds i64, i64* %lnbEJ, i32 -1
  store i64 %lnbEK, i64* %lnbEL, !tbaa !2
  %lnbEM = load i64*, i64** %Sp_Var
  %lnbEN = getelementptr inbounds i64, i64* %lnbEM, i32 -2
  %lnbEO = ptrtoint i64* %lnbEN to i64
  %lnbEP = inttoptr i64 %lnbEO to i64*
  store i64* %lnbEP, i64** %Sp_Var
  %lnbEQ = load i64, i64* %R1_Var
  %lnbER = and i64 %lnbEQ, 7
  %lnbES = icmp ne i64 %lnbER, 0
  br i1 %lnbES, label %ubeP, label %cbej
cbej:
  %lnbEU = load i64, i64* %R1_Var
  %lnbEV = inttoptr i64 %lnbEU to i64*
  %lnbEW = load i64, i64* %lnbEV, !tbaa !4
  %lnbEX = inttoptr i64 %lnbEW to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbEY = load i64*, i64** %Sp_Var
  %lnbEZ = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbEX( i64* %Base_Arg, i64* %lnbEY, i64* %Hp_Arg, i64 %lnbEZ, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ubeP:
  %lnbF0 = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbei_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbF1 = load i64*, i64** %Sp_Var
  %lnbF2 = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbF0( i64* %Base_Arg, i64* %lnbF1, i64* %Hp_Arg, i64 %lnbF2, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cbew:
  %lnbF4 = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbdv_info$def to i64
  %lnbF3 = load i64*, i64** %Sp_Var
  %lnbF5 = getelementptr inbounds i64, i64* %lnbF3, i32 8
  store i64 %lnbF4, i64* %lnbF5, !tbaa !2
  %lnbF6 = load i64, i64* %lsaE5
  store i64 %lnbF6, i64* %R1_Var
  %lnbF8 = load double, double* %lsaEU
  %lnbF7 = load i64*, i64** %Sp_Var
  %lnbF9 = getelementptr inbounds i64, i64* %lnbF7, i32 9
  %lnbFa = bitcast i64* %lnbF9 to double*
  store double %lnbF8, double* %lnbFa, !tbaa !2
  %lnbFb = load i64*, i64** %Sp_Var
  %lnbFc = getelementptr inbounds i64, i64* %lnbFb, i32 8
  %lnbFd = ptrtoint i64* %lnbFc to i64
  %lnbFe = inttoptr i64 %lnbFd to i64*
  store i64* %lnbFe, i64** %Sp_Var
  %lnbFf = load i64, i64* %R1_Var
  %lnbFg = and i64 %lnbFf, 7
  %lnbFh = icmp ne i64 %lnbFg, 0
  br i1 %lnbFh, label %ubeQ, label %cbdw
cbdw:
  %lnbFj = load i64, i64* %R1_Var
  %lnbFk = inttoptr i64 %lnbFj to i64*
  %lnbFl = load i64, i64* %lnbFk, !tbaa !4
  %lnbFm = inttoptr i64 %lnbFl to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbFn = load i64*, i64** %Sp_Var
  %lnbFo = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbFm( i64* %Base_Arg, i64* %lnbFn, i64* %Hp_Arg, i64 %lnbFo, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ubeQ:
  %lnbFp = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbdv_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbFq = load i64*, i64** %Sp_Var
  %lnbFr = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbFp( i64* %Base_Arg, i64* %lnbFq, i64* %Hp_Arg, i64 %lnbFr, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cbez:
  %lnbFt = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbdN_info$def to i64
  %lnbFs = load i64*, i64** %Sp_Var
  %lnbFu = getelementptr inbounds i64, i64* %lnbFs, i32 8
  store i64 %lnbFt, i64* %lnbFu, !tbaa !2
  %lnbFv = load i64, i64* %lsaE5
  store i64 %lnbFv, i64* %R1_Var
  %lnbFx = load double, double* %lsaEU
  %lnbFw = load i64*, i64** %Sp_Var
  %lnbFy = getelementptr inbounds i64, i64* %lnbFw, i32 9
  %lnbFz = bitcast i64* %lnbFy to double*
  store double %lnbFx, double* %lnbFz, !tbaa !2
  %lnbFA = load i64*, i64** %Sp_Var
  %lnbFB = getelementptr inbounds i64, i64* %lnbFA, i32 8
  %lnbFC = ptrtoint i64* %lnbFB to i64
  %lnbFD = inttoptr i64 %lnbFC to i64*
  store i64* %lnbFD, i64** %Sp_Var
  %lnbFE = load i64, i64* %R1_Var
  %lnbFF = and i64 %lnbFE, 7
  %lnbFG = icmp ne i64 %lnbFF, 0
  br i1 %lnbFG, label %ubeR, label %cbdO
cbdO:
  %lnbFI = load i64, i64* %R1_Var
  %lnbFJ = inttoptr i64 %lnbFI to i64*
  %lnbFK = load i64, i64* %lnbFJ, !tbaa !4
  %lnbFL = inttoptr i64 %lnbFK to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbFM = load i64*, i64** %Sp_Var
  %lnbFN = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbFL( i64* %Base_Arg, i64* %lnbFM, i64* %Hp_Arg, i64 %lnbFN, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ubeR:
  %lnbFO = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbdN_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbFP = load i64*, i64** %Sp_Var
  %lnbFQ = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbFO( i64* %Base_Arg, i64* %lnbFP, i64* %Hp_Arg, i64 %lnbFQ, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cbdN_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbdN_info$def to i8*)
define internal ghccc void @cbdN_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 65, i32 30, i32 0}>
{
cbdN:
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %lsaEQ = alloca double, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnbFR = load i64*, i64** %Hp_Var
  %lnbFS = getelementptr inbounds i64, i64* %lnbFR, i32 2
  %lnbFT = ptrtoint i64* %lnbFS to i64
  %lnbFU = inttoptr i64 %lnbFT to i64*
  store i64* %lnbFU, i64** %Hp_Var
  %lnbFV = load i64*, i64** %Hp_Var
  %lnbFW = ptrtoint i64* %lnbFV to i64
  %lnbFX = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lnbFY = bitcast i64* %lnbFX to i64*
  %lnbFZ = load i64, i64* %lnbFY, !tbaa !5
  %lnbG0 = icmp ugt i64 %lnbFW, %lnbFZ
  %lnbG1 = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnbG0, i1 0 )
  br i1 %lnbG1, label %cbdZ, label %cbdY
cbdY:
  %lnbG2 = load i64*, i64** %Sp_Var
  %lnbG3 = getelementptr inbounds i64, i64* %lnbG2, i32 1
  %lnbG4 = bitcast i64* %lnbG3 to double*
  %lnbG5 = load double, double* %lnbG4, !tbaa !2
  %lnbG8 = load i64, i64* %R1_Var
  %lnbG9 = add i64 %lnbG8, 7
  %lnbGa = inttoptr i64 %lnbG9 to double*
  %lnbGb = load double, double* %lnbGa, !tbaa !4
  %lnbGc = fdiv double %lnbG5, %lnbGb
  store double %lnbGc, double* %lsaEQ
  %lnbGe = ptrtoint i8* @ghczmprim_GHCziTypes_Dzh_con_info to i64
  %lnbGd = load i64*, i64** %Hp_Var
  %lnbGf = getelementptr inbounds i64, i64* %lnbGd, i32 -1
  store i64 %lnbGe, i64* %lnbGf, !tbaa !3
  %lnbGh = load double, double* %lsaEQ
  %lnbGg = load i64*, i64** %Hp_Var
  %lnbGi = getelementptr inbounds i64, i64* %lnbGg, i32 0
  %lnbGj = bitcast i64* %lnbGi to double*
  store double %lnbGh, double* %lnbGj, !tbaa !3
  %lnbGl = load i64*, i64** %Hp_Var
  %lnbGm = ptrtoint i64* %lnbGl to i64
  %lnbGn = add i64 %lnbGm, -7
  store i64 %lnbGn, i64* %R1_Var
  %lnbGo = load i64*, i64** %Sp_Var
  %lnbGp = getelementptr inbounds i64, i64* %lnbGo, i32 2
  %lnbGq = ptrtoint i64* %lnbGp to i64
  %lnbGr = inttoptr i64 %lnbGq to i64*
  store i64* %lnbGr, i64** %Sp_Var
  %lnbGs = load i64*, i64** %Sp_Var
  %lnbGt = getelementptr inbounds i64, i64* %lnbGs, i32 0
  %lnbGu = bitcast i64* %lnbGt to i64*
  %lnbGv = load i64, i64* %lnbGu, !tbaa !2
  %lnbGw = inttoptr i64 %lnbGv to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbGx = load i64*, i64** %Sp_Var
  %lnbGy = load i64*, i64** %Hp_Var
  %lnbGz = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbGw( i64* %Base_Arg, i64* %lnbGx, i64* %lnbGy, i64 %lnbGz, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cbdZ:
  %lnbGA = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 16, i64* %lnbGA, !tbaa !5
  %lnbGB = load i64, i64* %R1_Var
  store i64 %lnbGB, i64* %R1_Var
  %lnbGC = bitcast i8* @stg_gc_unpt_r1 to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbGD = load i64*, i64** %Sp_Var
  %lnbGE = load i64*, i64** %Hp_Var
  %lnbGF = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbGC( i64* %Base_Arg, i64* %lnbGD, i64* %lnbGE, i64 %lnbGF, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cbdv_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbdv_info$def to i8*)
define internal ghccc void @cbdv_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 65, i32 30, i32 0}>
{
cbdv:
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %lsaEL = alloca double, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnbGG = load i64*, i64** %Hp_Var
  %lnbGH = getelementptr inbounds i64, i64* %lnbGG, i32 2
  %lnbGI = ptrtoint i64* %lnbGH to i64
  %lnbGJ = inttoptr i64 %lnbGI to i64*
  store i64* %lnbGJ, i64** %Hp_Var
  %lnbGK = load i64*, i64** %Hp_Var
  %lnbGL = ptrtoint i64* %lnbGK to i64
  %lnbGM = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lnbGN = bitcast i64* %lnbGM to i64*
  %lnbGO = load i64, i64* %lnbGN, !tbaa !5
  %lnbGP = icmp ugt i64 %lnbGL, %lnbGO
  %lnbGQ = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnbGP, i1 0 )
  br i1 %lnbGQ, label %cbdH, label %cbdG
cbdG:
  %lnbGR = load i64*, i64** %Sp_Var
  %lnbGS = getelementptr inbounds i64, i64* %lnbGR, i32 1
  %lnbGT = bitcast i64* %lnbGS to double*
  %lnbGU = load double, double* %lnbGT, !tbaa !2
  %lnbGX = load i64, i64* %R1_Var
  %lnbGY = add i64 %lnbGX, 7
  %lnbGZ = inttoptr i64 %lnbGY to double*
  %lnbH0 = load double, double* %lnbGZ, !tbaa !4
  %lnbH1 = fdiv double %lnbGU, %lnbH0
  store double %lnbH1, double* %lsaEL
  %lnbH3 = ptrtoint i8* @ghczmprim_GHCziTypes_Dzh_con_info to i64
  %lnbH2 = load i64*, i64** %Hp_Var
  %lnbH4 = getelementptr inbounds i64, i64* %lnbH2, i32 -1
  store i64 %lnbH3, i64* %lnbH4, !tbaa !3
  %lnbH6 = load double, double* %lsaEL
  %lnbH5 = load i64*, i64** %Hp_Var
  %lnbH7 = getelementptr inbounds i64, i64* %lnbH5, i32 0
  %lnbH8 = bitcast i64* %lnbH7 to double*
  store double %lnbH6, double* %lnbH8, !tbaa !3
  %lnbHa = load i64*, i64** %Hp_Var
  %lnbHb = ptrtoint i64* %lnbHa to i64
  %lnbHc = add i64 %lnbHb, -7
  store i64 %lnbHc, i64* %R1_Var
  %lnbHd = load i64*, i64** %Sp_Var
  %lnbHe = getelementptr inbounds i64, i64* %lnbHd, i32 2
  %lnbHf = ptrtoint i64* %lnbHe to i64
  %lnbHg = inttoptr i64 %lnbHf to i64*
  store i64* %lnbHg, i64** %Sp_Var
  %lnbHh = load i64*, i64** %Sp_Var
  %lnbHi = getelementptr inbounds i64, i64* %lnbHh, i32 0
  %lnbHj = bitcast i64* %lnbHi to i64*
  %lnbHk = load i64, i64* %lnbHj, !tbaa !2
  %lnbHl = inttoptr i64 %lnbHk to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbHm = load i64*, i64** %Sp_Var
  %lnbHn = load i64*, i64** %Hp_Var
  %lnbHo = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbHl( i64* %Base_Arg, i64* %lnbHm, i64* %lnbHn, i64 %lnbHo, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cbdH:
  %lnbHp = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 16, i64* %lnbHp, !tbaa !5
  %lnbHq = load i64, i64* %R1_Var
  store i64 %lnbHq, i64* %R1_Var
  %lnbHr = bitcast i8* @stg_gc_unpt_r1 to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbHs = load i64*, i64** %Sp_Var
  %lnbHt = load i64*, i64** %Hp_Var
  %lnbHu = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbHr( i64* %Base_Arg, i64* %lnbHs, i64* %lnbHt, i64 %lnbHu, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cbei_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbei_info$def to i8*)
define internal ghccc void @cbei_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 56971, i32 30, i32 0}>
{
cbei:
  %lsaF4 = alloca double, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lnbHv = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cben_info$def to i64
  %lnbHw = getelementptr inbounds i64, i64* %Sp_Arg, i32 0
  store i64 %lnbHv, i64* %lnbHw, !tbaa !2
  %lnbHz = load i64, i64* %R1_Var
  %lnbHA = add i64 %lnbHz, 7
  %lnbHB = inttoptr i64 %lnbHA to double*
  %lnbHC = load double, double* %lnbHB, !tbaa !4
  store double %lnbHC, double* %lsaF4
  %lnbHD = getelementptr inbounds i64, i64* %Sp_Arg, i32 1
  %lnbHE = bitcast i64* %lnbHD to i64*
  %lnbHF = load i64, i64* %lnbHE, !tbaa !2
  store i64 %lnbHF, i64* %R1_Var
  %lnbHG = load double, double* %lsaF4
  %lnbHH = getelementptr inbounds i64, i64* %Sp_Arg, i32 1
  %lnbHI = bitcast i64* %lnbHH to double*
  store double %lnbHG, double* %lnbHI, !tbaa !2
  %lnbHJ = load i64, i64* %R1_Var
  %lnbHK = and i64 %lnbHJ, 7
  %lnbHL = icmp ne i64 %lnbHK, 0
  br i1 %lnbHL, label %ubeS, label %cber
cber:
  %lnbHN = load i64, i64* %R1_Var
  %lnbHO = inttoptr i64 %lnbHN to i64*
  %lnbHP = load i64, i64* %lnbHO, !tbaa !4
  %lnbHQ = inttoptr i64 %lnbHP to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbHR = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbHQ( i64* %Base_Arg, i64* %Sp_Arg, i64* %Hp_Arg, i64 %lnbHR, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ubeS:
  %lnbHS = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cben_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbHT = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbHS( i64* %Base_Arg, i64* %Sp_Arg, i64* %Hp_Arg, i64 %lnbHT, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cben_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cben_info$def to i8*)
define internal ghccc void @cben_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 57035, i32 30, i32 0}>
{
cben:
  %lsaEU = alloca double, i32 1
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnbHU = load i64*, i64** %Sp_Var
  %lnbHV = getelementptr inbounds i64, i64* %lnbHU, i32 6
  %lnbHW = bitcast i64* %lnbHV to double*
  %lnbHX = load double, double* %lnbHW, !tbaa !2
  %lnbHY = load i64*, i64** %Sp_Var
  %lnbHZ = getelementptr inbounds i64, i64* %lnbHY, i32 1
  %lnbI0 = bitcast i64* %lnbHZ to double*
  %lnbI1 = load double, double* %lnbI0, !tbaa !2
  %lnbI2 = add i64 %R1_Arg, 7
  %lnbI3 = inttoptr i64 %lnbI2 to double*
  %lnbI4 = load double, double* %lnbI3, !tbaa !4
  %lnbI5 = fmul double %lnbI1, %lnbI4
  %lnbI6 = fadd double %lnbHX, %lnbI5
  store double %lnbI6, double* %lsaEU
  %lnbI8 = load i64*, i64** %Sp_Var
  %lnbI9 = getelementptr inbounds i64, i64* %lnbI8, i32 4
  %lnbIa = bitcast i64* %lnbI9 to i64*
  %lnbIb = load i64, i64* %lnbIa, !tbaa !2
  %lnbIc = add i64 %lnbIb, 1
  %lnbI7 = load i64*, i64** %Sp_Var
  %lnbId = getelementptr inbounds i64, i64* %lnbI7, i32 4
  store i64 %lnbIc, i64* %lnbId, !tbaa !2
  %lnbIf = load i64*, i64** %Sp_Var
  %lnbIg = getelementptr inbounds i64, i64* %lnbIf, i32 5
  %lnbIh = bitcast i64* %lnbIg to i64*
  %lnbIi = load i64, i64* %lnbIh, !tbaa !2
  %lnbIj = add i64 %lnbIi, 1
  %lnbIe = load i64*, i64** %Sp_Var
  %lnbIk = getelementptr inbounds i64, i64* %lnbIe, i32 5
  store i64 %lnbIj, i64* %lnbIk, !tbaa !2
  %lnbIm = load double, double* %lsaEU
  %lnbIl = load i64*, i64** %Sp_Var
  %lnbIn = getelementptr inbounds i64, i64* %lnbIl, i32 6
  %lnbIo = bitcast i64* %lnbIn to double*
  store double %lnbIm, double* %lnbIo, !tbaa !2
  %lnbIp = load i64*, i64** %Sp_Var
  %lnbIq = getelementptr inbounds i64, i64* %lnbIp, i32 2
  %lnbIr = ptrtoint i64* %lnbIq to i64
  %lnbIs = inttoptr i64 %lnbIr to i64*
  store i64* %lnbIs, i64** %Sp_Var
  %lnbIt = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @_cbe2$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbIu = load i64*, i64** %Sp_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbIt( i64* %Base_Arg, i64* %lnbIu, i64* %Hp_Arg, i64 %R1_Arg, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saHU_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saHU_info$def to i8*)
define internal ghccc void @saHU_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 4, i32 15, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%ubmj_srt_struct* @ubmj_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saHU_info$def to i64)) to i32),i32 0)}>
{
cbeW:
  %R6_Var = alloca i64, i32 1
  store i64 undef, i64* %R6_Var
  %R5_Var = alloca i64, i32 1
  store i64 undef, i64* %R5_Var
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %lnbIv = add i64 %R1_Arg, 16
  %lnbIw = inttoptr i64 %lnbIv to i64*
  %lnbIx = load i64, i64* %lnbIw, !tbaa !4
  store i64 %lnbIx, i64* %R6_Var
  %lnbIy = add i64 %R1_Arg, 24
  %lnbIz = inttoptr i64 %lnbIy to i64*
  %lnbIA = load i64, i64* %lnbIz, !tbaa !4
  store i64 %lnbIA, i64* %R5_Var
  %lnbIB = add i64 %R1_Arg, 32
  %lnbIC = inttoptr i64 %lnbIB to i64*
  %lnbID = load i64, i64* %lnbIC, !tbaa !4
  store i64 %lnbID, i64* %R4_Var
  %lnbIE = add i64 %R1_Arg, 40
  %lnbIF = inttoptr i64 %lnbIE to i64*
  %lnbIG = load i64, i64* %lnbIF, !tbaa !4
  store i64 %lnbIG, i64* %R3_Var
  %lnbIH = ptrtoint i8* @base_GHCziFloat_zdfNumDouble_closure to i64
  store i64 %lnbIH, i64* %R2_Var
  %lnbII = bitcast i8* @hblaszm0zi0zi0zi0zminplace_HBLASziLevel1_axpyzq_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbIJ = load i64, i64* %R2_Var
  %lnbIK = load i64, i64* %R3_Var
  %lnbIL = load i64, i64* %R4_Var
  %lnbIM = load i64, i64* %R5_Var
  %lnbIN = load i64, i64* %R6_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbII( i64* %Base_Arg, i64* %Sp_Arg, i64* %Hp_Arg, i64 %R1_Arg, i64 %lnbIJ, i64 %lnbIK, i64 %lnbIL, i64 %lnbIM, i64 %lnbIN, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saFr_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saFr_info$def to i8*)
define internal ghccc void @saFr_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 1, i32 16, i32 0}>
{
cbf8:
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnbIO = load i64*, i64** %Sp_Var
  %lnbIP = getelementptr inbounds i64, i64* %lnbIO, i32 -3
  %lnbIQ = ptrtoint i64* %lnbIP to i64
  %lnbIR = icmp ult i64 %lnbIQ, %SpLim_Arg
  %lnbIS = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnbIR, i1 0 )
  br i1 %lnbIS, label %cbff, label %cbfg
cbfg:
  %lnbIU = ptrtoint i8* @stg_upd_frame_info to i64
  %lnbIT = load i64*, i64** %Sp_Var
  %lnbIV = getelementptr inbounds i64, i64* %lnbIT, i32 -2
  store i64 %lnbIU, i64* %lnbIV, !tbaa !2
  %lnbIX = load i64, i64* %R1_Var
  %lnbIW = load i64*, i64** %Sp_Var
  %lnbIY = getelementptr inbounds i64, i64* %lnbIW, i32 -1
  store i64 %lnbIX, i64* %lnbIY, !tbaa !2
  %lnbJ0 = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbf5_info$def to i64
  %lnbIZ = load i64*, i64** %Sp_Var
  %lnbJ1 = getelementptr inbounds i64, i64* %lnbIZ, i32 -3
  store i64 %lnbJ0, i64* %lnbJ1, !tbaa !2
  %lnbJ4 = load i64, i64* %R1_Var
  %lnbJ5 = add i64 %lnbJ4, 16
  %lnbJ6 = inttoptr i64 %lnbJ5 to i64*
  %lnbJ7 = load i64, i64* %lnbJ6, !tbaa !4
  store i64 %lnbJ7, i64* %R1_Var
  %lnbJ8 = load i64*, i64** %Sp_Var
  %lnbJ9 = getelementptr inbounds i64, i64* %lnbJ8, i32 -3
  %lnbJa = ptrtoint i64* %lnbJ9 to i64
  %lnbJb = inttoptr i64 %lnbJa to i64*
  store i64* %lnbJb, i64** %Sp_Var
  %lnbJc = load i64, i64* %R1_Var
  %lnbJd = and i64 %lnbJc, 7
  %lnbJe = icmp ne i64 %lnbJd, 0
  br i1 %lnbJe, label %ubfk, label %cbf6
cbf6:
  %lnbJg = load i64, i64* %R1_Var
  %lnbJh = inttoptr i64 %lnbJg to i64*
  %lnbJi = load i64, i64* %lnbJh, !tbaa !4
  %lnbJj = inttoptr i64 %lnbJi to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbJk = load i64*, i64** %Sp_Var
  %lnbJl = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbJj( i64* %Base_Arg, i64* %lnbJk, i64* %Hp_Arg, i64 %lnbJl, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ubfk:
  %lnbJm = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbf5_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbJn = load i64*, i64** %Sp_Var
  %lnbJo = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbJm( i64* %Base_Arg, i64* %lnbJn, i64* %Hp_Arg, i64 %lnbJo, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cbff:
  %lnbJp = load i64, i64* %R1_Var
  store i64 %lnbJp, i64* %R1_Var
  %lnbJq = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lnbJr = bitcast i64* %lnbJq to i64*
  %lnbJs = load i64, i64* %lnbJr, !tbaa !5
  %lnbJt = inttoptr i64 %lnbJs to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbJu = load i64*, i64** %Sp_Var
  %lnbJv = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbJt( i64* %Base_Arg, i64* %lnbJu, i64* %Hp_Arg, i64 %lnbJv, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cbf5_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbf5_info$def to i8*)
define internal ghccc void @cbf5_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 0, i32 30, i32 0}>
{
cbf5:
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %lsaFq = alloca double, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnbJw = load i64*, i64** %Hp_Var
  %lnbJx = getelementptr inbounds i64, i64* %lnbJw, i32 2
  %lnbJy = ptrtoint i64* %lnbJx to i64
  %lnbJz = inttoptr i64 %lnbJy to i64*
  store i64* %lnbJz, i64** %Hp_Var
  %lnbJA = load i64*, i64** %Hp_Var
  %lnbJB = ptrtoint i64* %lnbJA to i64
  %lnbJC = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lnbJD = bitcast i64* %lnbJC to i64*
  %lnbJE = load i64, i64* %lnbJD, !tbaa !5
  %lnbJF = icmp ugt i64 %lnbJB, %lnbJE
  %lnbJG = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnbJF, i1 0 )
  br i1 %lnbJG, label %cbfj, label %cbfi
cbfi:
  %lnbJJ = load i64, i64* %R1_Var
  %lnbJK = add i64 %lnbJJ, 7
  %lnbJL = inttoptr i64 %lnbJK to double*
  %lnbJM = load double, double* %lnbJL, !tbaa !4
  %lnbJN = fmul double %lnbJM, 0xBFF0000000000000
  store double %lnbJN, double* %lsaFq
  %lnbJP = ptrtoint i8* @ghczmprim_GHCziTypes_Dzh_con_info to i64
  %lnbJO = load i64*, i64** %Hp_Var
  %lnbJQ = getelementptr inbounds i64, i64* %lnbJO, i32 -1
  store i64 %lnbJP, i64* %lnbJQ, !tbaa !3
  %lnbJS = load double, double* %lsaFq
  %lnbJR = load i64*, i64** %Hp_Var
  %lnbJT = getelementptr inbounds i64, i64* %lnbJR, i32 0
  %lnbJU = bitcast i64* %lnbJT to double*
  store double %lnbJS, double* %lnbJU, !tbaa !3
  %lnbJW = load i64*, i64** %Hp_Var
  %lnbJX = ptrtoint i64* %lnbJW to i64
  %lnbJY = add i64 %lnbJX, -7
  store i64 %lnbJY, i64* %R1_Var
  %lnbJZ = load i64*, i64** %Sp_Var
  %lnbK0 = getelementptr inbounds i64, i64* %lnbJZ, i32 1
  %lnbK1 = ptrtoint i64* %lnbK0 to i64
  %lnbK2 = inttoptr i64 %lnbK1 to i64*
  store i64* %lnbK2, i64** %Sp_Var
  %lnbK3 = load i64*, i64** %Sp_Var
  %lnbK4 = getelementptr inbounds i64, i64* %lnbK3, i32 0
  %lnbK5 = bitcast i64* %lnbK4 to i64*
  %lnbK6 = load i64, i64* %lnbK5, !tbaa !2
  %lnbK7 = inttoptr i64 %lnbK6 to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbK8 = load i64*, i64** %Sp_Var
  %lnbK9 = load i64*, i64** %Hp_Var
  %lnbKa = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbK7( i64* %Base_Arg, i64* %lnbK8, i64* %lnbK9, i64 %lnbKa, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cbfj:
  %lnbKb = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 16, i64* %lnbKb, !tbaa !5
  %lnbKc = load i64, i64* %R1_Var
  store i64 %lnbKc, i64* %R1_Var
  %lnbKd = bitcast i8* @stg_gc_unpt_r1 to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbKe = load i64*, i64** %Sp_Var
  %lnbKf = load i64*, i64** %Hp_Var
  %lnbKg = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbKd( i64* %Base_Arg, i64* %lnbKe, i64* %lnbKf, i64 %lnbKg, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saFn_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saFn_info$def to i8*)
define internal ghccc void @saFn_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 4, i32 15, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%ubmj_srt_struct* @ubmj_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saFn_info$def to i64)) to i32),i32 0)}>
{
cbfl:
  %lsaFn = alloca i64, i32 1
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %lsaDl = alloca i64, i32 1
  %lsaFd = alloca i64, i32 1
  %lsaFf = alloca i64, i32 1
  %lsaFh = alloca i64, i32 1
  %R6_Var = alloca i64, i32 1
  store i64 undef, i64* %R6_Var
  %R5_Var = alloca i64, i32 1
  store i64 undef, i64* %R5_Var
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lnbKh = load i64, i64* %R1_Var
  store i64 %lnbKh, i64* %lsaFn
  %lnbKi = load i64*, i64** %Sp_Var
  %lnbKj = getelementptr inbounds i64, i64* %lnbKi, i32 -2
  %lnbKk = ptrtoint i64* %lnbKj to i64
  %lnbKl = icmp ult i64 %lnbKk, %SpLim_Arg
  %lnbKm = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnbKl, i1 0 )
  br i1 %lnbKm, label %cbfm, label %cbfn
cbfn:
  %lnbKn = load i64*, i64** %Hp_Var
  %lnbKo = getelementptr inbounds i64, i64* %lnbKn, i32 3
  %lnbKp = ptrtoint i64* %lnbKo to i64
  %lnbKq = inttoptr i64 %lnbKp to i64*
  store i64* %lnbKq, i64** %Hp_Var
  %lnbKr = load i64*, i64** %Hp_Var
  %lnbKs = ptrtoint i64* %lnbKr to i64
  %lnbKt = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lnbKu = bitcast i64* %lnbKt to i64*
  %lnbKv = load i64, i64* %lnbKu, !tbaa !5
  %lnbKw = icmp ugt i64 %lnbKs, %lnbKv
  %lnbKx = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnbKw, i1 0 )
  br i1 %lnbKx, label %cbfp, label %cbfo
cbfo:
  %lnbKz = ptrtoint i8* @stg_upd_frame_info to i64
  %lnbKy = load i64*, i64** %Sp_Var
  %lnbKA = getelementptr inbounds i64, i64* %lnbKy, i32 -2
  store i64 %lnbKz, i64* %lnbKA, !tbaa !2
  %lnbKC = load i64, i64* %lsaFn
  %lnbKB = load i64*, i64** %Sp_Var
  %lnbKD = getelementptr inbounds i64, i64* %lnbKB, i32 -1
  store i64 %lnbKC, i64* %lnbKD, !tbaa !2
  %lnbKE = load i64, i64* %lsaFn
  %lnbKF = add i64 %lnbKE, 16
  %lnbKG = inttoptr i64 %lnbKF to i64*
  %lnbKH = load i64, i64* %lnbKG, !tbaa !1
  store i64 %lnbKH, i64* %lsaDl
  %lnbKI = load i64, i64* %lsaFn
  %lnbKJ = add i64 %lnbKI, 24
  %lnbKK = inttoptr i64 %lnbKJ to i64*
  %lnbKL = load i64, i64* %lnbKK, !tbaa !1
  store i64 %lnbKL, i64* %lsaFd
  %lnbKM = load i64, i64* %lsaFn
  %lnbKN = add i64 %lnbKM, 32
  %lnbKO = inttoptr i64 %lnbKN to i64*
  %lnbKP = load i64, i64* %lnbKO, !tbaa !1
  store i64 %lnbKP, i64* %lsaFf
  %lnbKQ = load i64, i64* %lsaFn
  %lnbKR = add i64 %lnbKQ, 40
  %lnbKS = inttoptr i64 %lnbKR to i64*
  %lnbKT = load i64, i64* %lnbKS, !tbaa !1
  store i64 %lnbKT, i64* %lsaFh
  %lnbKV = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saFr_info$def to i64
  %lnbKU = load i64*, i64** %Hp_Var
  %lnbKW = getelementptr inbounds i64, i64* %lnbKU, i32 -2
  store i64 %lnbKV, i64* %lnbKW, !tbaa !3
  %lnbKY = load i64, i64* %lsaFh
  %lnbKX = load i64*, i64** %Hp_Var
  %lnbKZ = getelementptr inbounds i64, i64* %lnbKX, i32 0
  store i64 %lnbKY, i64* %lnbKZ, !tbaa !3
  %lnbL0 = load i64, i64* %lsaDl
  store i64 %lnbL0, i64* %R6_Var
  %lnbL1 = load i64, i64* %lsaFd
  store i64 %lnbL1, i64* %R5_Var
  %lnbL2 = load i64, i64* %lsaFf
  store i64 %lnbL2, i64* %R4_Var
  %lnbL3 = load i64*, i64** %Hp_Var
  %lnbL4 = getelementptr inbounds i64, i64* %lnbL3, i32 -2
  %lnbL5 = ptrtoint i64* %lnbL4 to i64
  store i64 %lnbL5, i64* %R3_Var
  %lnbL6 = ptrtoint i8* @base_GHCziFloat_zdfNumDouble_closure to i64
  store i64 %lnbL6, i64* %R2_Var
  %lnbL7 = load i64*, i64** %Sp_Var
  %lnbL8 = getelementptr inbounds i64, i64* %lnbL7, i32 -2
  %lnbL9 = ptrtoint i64* %lnbL8 to i64
  %lnbLa = inttoptr i64 %lnbL9 to i64*
  store i64* %lnbLa, i64** %Sp_Var
  %lnbLb = bitcast i8* @hblaszm0zi0zi0zi0zminplace_HBLASziLevel1_axpyzq_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbLc = load i64*, i64** %Sp_Var
  %lnbLd = load i64*, i64** %Hp_Var
  %lnbLe = load i64, i64* %R1_Var
  %lnbLf = load i64, i64* %R2_Var
  %lnbLg = load i64, i64* %R3_Var
  %lnbLh = load i64, i64* %R4_Var
  %lnbLi = load i64, i64* %R5_Var
  %lnbLj = load i64, i64* %R6_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbLb( i64* %Base_Arg, i64* %lnbLc, i64* %lnbLd, i64 %lnbLe, i64 %lnbLf, i64 %lnbLg, i64 %lnbLh, i64 %lnbLi, i64 %lnbLj, i64 %SpLim_Arg ) nounwind
  ret void
cbfp:
  %lnbLk = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 24, i64* %lnbLk, !tbaa !5
  br label %cbfm
cbfm:
  %lnbLl = load i64, i64* %lsaFn
  store i64 %lnbLl, i64* %R1_Var
  %lnbLm = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lnbLn = bitcast i64* %lnbLm to i64*
  %lnbLo = load i64, i64* %lnbLn, !tbaa !5
  %lnbLp = inttoptr i64 %lnbLo to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbLq = load i64*, i64** %Sp_Var
  %lnbLr = load i64*, i64** %Hp_Var
  %lnbLs = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbLp( i64* %Base_Arg, i64* %lnbLq, i64* %lnbLr, i64 %lnbLs, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saFD_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saFD_info$def to i8*)
define internal ghccc void @saFD_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 3, i32 15, i32 0}>
{
cbfG:
  %lsaFf = alloca i64, i32 1
  %lsaFg = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnbLt = load i64*, i64** %Sp_Var
  %lnbLu = getelementptr inbounds i64, i64* %lnbLt, i32 -14
  %lnbLv = ptrtoint i64* %lnbLu to i64
  %lnbLw = icmp ult i64 %lnbLv, %SpLim_Arg
  %lnbLx = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnbLw, i1 0 )
  br i1 %lnbLx, label %cbfK, label %cbfL
cbfL:
  %lnbLz = ptrtoint i8* @stg_upd_frame_info to i64
  %lnbLy = load i64*, i64** %Sp_Var
  %lnbLA = getelementptr inbounds i64, i64* %lnbLy, i32 -2
  store i64 %lnbLz, i64* %lnbLA, !tbaa !2
  %lnbLC = load i64, i64* %R1_Var
  %lnbLB = load i64*, i64** %Sp_Var
  %lnbLD = getelementptr inbounds i64, i64* %lnbLB, i32 -1
  store i64 %lnbLC, i64* %lnbLD, !tbaa !2
  %lnbLF = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbfD_info$def to i64
  %lnbLE = load i64*, i64** %Sp_Var
  %lnbLG = getelementptr inbounds i64, i64* %lnbLE, i32 -5
  store i64 %lnbLF, i64* %lnbLG, !tbaa !2
  %lnbLJ = load i64, i64* %R1_Var
  %lnbLK = add i64 %lnbLJ, 16
  %lnbLL = inttoptr i64 %lnbLK to i64*
  %lnbLM = load i64, i64* %lnbLL, !tbaa !4
  store i64 %lnbLM, i64* %lsaFf
  %lnbLP = load i64, i64* %R1_Var
  %lnbLQ = add i64 %lnbLP, 24
  %lnbLR = inttoptr i64 %lnbLQ to i64*
  %lnbLS = load i64, i64* %lnbLR, !tbaa !4
  store i64 %lnbLS, i64* %lsaFg
  %lnbLV = load i64, i64* %R1_Var
  %lnbLW = add i64 %lnbLV, 32
  %lnbLX = inttoptr i64 %lnbLW to i64*
  %lnbLY = load i64, i64* %lnbLX, !tbaa !4
  store i64 %lnbLY, i64* %R1_Var
  %lnbM0 = load i64, i64* %lsaFf
  %lnbLZ = load i64*, i64** %Sp_Var
  %lnbM1 = getelementptr inbounds i64, i64* %lnbLZ, i32 -4
  store i64 %lnbM0, i64* %lnbM1, !tbaa !2
  %lnbM3 = load i64, i64* %lsaFg
  %lnbM2 = load i64*, i64** %Sp_Var
  %lnbM4 = getelementptr inbounds i64, i64* %lnbM2, i32 -3
  store i64 %lnbM3, i64* %lnbM4, !tbaa !2
  %lnbM5 = load i64*, i64** %Sp_Var
  %lnbM6 = getelementptr inbounds i64, i64* %lnbM5, i32 -5
  %lnbM7 = ptrtoint i64* %lnbM6 to i64
  %lnbM8 = inttoptr i64 %lnbM7 to i64*
  store i64* %lnbM8, i64** %Sp_Var
  %lnbM9 = load i64, i64* %R1_Var
  %lnbMa = and i64 %lnbM9, 7
  %lnbMb = icmp ne i64 %lnbMa, 0
  br i1 %lnbMb, label %ubhf, label %cbfE
cbfE:
  %lnbMd = load i64, i64* %R1_Var
  %lnbMe = inttoptr i64 %lnbMd to i64*
  %lnbMf = load i64, i64* %lnbMe, !tbaa !4
  %lnbMg = inttoptr i64 %lnbMf to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbMh = load i64*, i64** %Sp_Var
  %lnbMi = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbMg( i64* %Base_Arg, i64* %lnbMh, i64* %Hp_Arg, i64 %lnbMi, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ubhf:
  %lnbMj = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbfD_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbMk = load i64*, i64** %Sp_Var
  %lnbMl = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbMj( i64* %Base_Arg, i64* %lnbMk, i64* %Hp_Arg, i64 %lnbMl, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cbfK:
  %lnbMm = load i64, i64* %R1_Var
  store i64 %lnbMm, i64* %R1_Var
  %lnbMn = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lnbMo = bitcast i64* %lnbMn to i64*
  %lnbMp = load i64, i64* %lnbMo, !tbaa !5
  %lnbMq = inttoptr i64 %lnbMp to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbMr = load i64*, i64** %Sp_Var
  %lnbMs = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbMq( i64* %Base_Arg, i64* %lnbMr, i64* %Hp_Arg, i64 %lnbMs, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cbfD_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbfD_info$def to i8*)
define internal ghccc void @cbfD_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 2, i32 30, i32 0}>
{
cbfD:
  %lsaFH = alloca i64, i32 1
  %lsaFF = alloca i64, i32 1
  %lsaFG = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnbMu = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbfJ_info$def to i64
  %lnbMt = load i64*, i64** %Sp_Var
  %lnbMv = getelementptr inbounds i64, i64* %lnbMt, i32 -2
  store i64 %lnbMu, i64* %lnbMv, !tbaa !2
  %lnbMy = load i64, i64* %R1_Var
  %lnbMz = add i64 %lnbMy, 7
  %lnbMA = inttoptr i64 %lnbMz to i64*
  %lnbMB = load i64, i64* %lnbMA, !tbaa !4
  store i64 %lnbMB, i64* %lsaFH
  %lnbME = load i64, i64* %R1_Var
  %lnbMF = add i64 %lnbME, 15
  %lnbMG = inttoptr i64 %lnbMF to i64*
  %lnbMH = load i64, i64* %lnbMG, !tbaa !4
  store i64 %lnbMH, i64* %lsaFF
  %lnbMK = load i64, i64* %R1_Var
  %lnbML = add i64 %lnbMK, 23
  %lnbMM = inttoptr i64 %lnbML to i64*
  %lnbMN = load i64, i64* %lnbMM, !tbaa !4
  store i64 %lnbMN, i64* %lsaFG
  %lnbMO = load i64*, i64** %Sp_Var
  %lnbMP = getelementptr inbounds i64, i64* %lnbMO, i32 1
  %lnbMQ = bitcast i64* %lnbMP to i64*
  %lnbMR = load i64, i64* %lnbMQ, !tbaa !2
  store i64 %lnbMR, i64* %R1_Var
  %lnbMT = load i64, i64* %lsaFH
  %lnbMS = load i64*, i64** %Sp_Var
  %lnbMU = getelementptr inbounds i64, i64* %lnbMS, i32 -1
  store i64 %lnbMT, i64* %lnbMU, !tbaa !2
  %lnbMW = load i64, i64* %lsaFG
  %lnbMV = load i64*, i64** %Sp_Var
  %lnbMX = getelementptr inbounds i64, i64* %lnbMV, i32 0
  store i64 %lnbMW, i64* %lnbMX, !tbaa !2
  %lnbMZ = load i64, i64* %lsaFF
  %lnbMY = load i64*, i64** %Sp_Var
  %lnbN0 = getelementptr inbounds i64, i64* %lnbMY, i32 1
  store i64 %lnbMZ, i64* %lnbN0, !tbaa !2
  %lnbN1 = load i64*, i64** %Sp_Var
  %lnbN2 = getelementptr inbounds i64, i64* %lnbN1, i32 -2
  %lnbN3 = ptrtoint i64* %lnbN2 to i64
  %lnbN4 = inttoptr i64 %lnbN3 to i64*
  store i64* %lnbN4, i64** %Sp_Var
  %lnbN5 = load i64, i64* %R1_Var
  %lnbN6 = and i64 %lnbN5, 7
  %lnbN7 = icmp ne i64 %lnbN6, 0
  br i1 %lnbN7, label %ubhe, label %cbfN
cbfN:
  %lnbN9 = load i64, i64* %R1_Var
  %lnbNa = inttoptr i64 %lnbN9 to i64*
  %lnbNb = load i64, i64* %lnbNa, !tbaa !4
  %lnbNc = inttoptr i64 %lnbNb to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbNd = load i64*, i64** %Sp_Var
  %lnbNe = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbNc( i64* %Base_Arg, i64* %lnbNd, i64* %Hp_Arg, i64 %lnbNe, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ubhe:
  %lnbNf = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbfJ_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbNg = load i64*, i64** %Sp_Var
  %lnbNh = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbNf( i64* %Base_Arg, i64* %lnbNg, i64* %Hp_Arg, i64 %lnbNh, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cbfJ_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbfJ_info$def to i8*)
define internal ghccc void @cbfJ_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 388, i32 30, i32 0}>
{
cbfJ:
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnbNj = add i64 %R1_Arg, 23
  %lnbNk = inttoptr i64 %lnbNj to i64*
  %lnbNl = load i64, i64* %lnbNk, !tbaa !4
  %lnbNi = load i64*, i64** %Sp_Var
  %lnbNm = getelementptr inbounds i64, i64* %lnbNi, i32 -5
  store i64 %lnbNl, i64* %lnbNm, !tbaa !2
  %lnbNo = add i64 %R1_Arg, 7
  %lnbNp = inttoptr i64 %lnbNo to i64*
  %lnbNq = load i64, i64* %lnbNp, !tbaa !4
  %lnbNn = load i64*, i64** %Sp_Var
  %lnbNr = getelementptr inbounds i64, i64* %lnbNn, i32 -4
  store i64 %lnbNq, i64* %lnbNr, !tbaa !2
  %lnbNs = load i64*, i64** %Sp_Var
  %lnbNt = getelementptr inbounds i64, i64* %lnbNs, i32 -3
  store i64 0, i64* %lnbNt, !tbaa !2
  %lnbNu = load i64*, i64** %Sp_Var
  %lnbNv = getelementptr inbounds i64, i64* %lnbNu, i32 -2
  store i64 0, i64* %lnbNv, !tbaa !2
  %lnbNw = load i64*, i64** %Sp_Var
  %lnbNx = getelementptr inbounds i64, i64* %lnbNw, i32 -1
  %lnbNy = bitcast i64* %lnbNx to double*
  store double 0x0000000000000000, double* %lnbNy, !tbaa !2
  %lnbNA = add i64 %R1_Arg, 15
  %lnbNB = inttoptr i64 %lnbNA to i64*
  %lnbNC = load i64, i64* %lnbNB, !tbaa !4
  %lnbNz = load i64*, i64** %Sp_Var
  %lnbND = getelementptr inbounds i64, i64* %lnbNz, i32 0
  store i64 %lnbNC, i64* %lnbND, !tbaa !2
  %lnbNE = load i64*, i64** %Sp_Var
  %lnbNF = getelementptr inbounds i64, i64* %lnbNE, i32 -5
  %lnbNG = ptrtoint i64* %lnbNF to i64
  %lnbNH = inttoptr i64 %lnbNG to i64*
  store i64* %lnbNH, i64** %Sp_Var
  %lnbNI = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @_cbgu$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbNJ = load i64*, i64** %Sp_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbNI( i64* %Base_Arg, i64* %lnbNJ, i64* %Hp_Arg, i64 %R1_Arg, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@_cbgu = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @_cbgu$def to i8*)
define internal ghccc void @_cbgu$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind
{
cbgu:
  %lsaFg = alloca i64, i32 1
  %lsaFY = alloca i64, i32 1
  %lsaFZ = alloca double, i32 1
  %lsaFX = alloca i64, i32 1
  %lsaG3 = alloca i64, i32 1
  %lsaG7 = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnbNK = load i64*, i64** %Sp_Var
  %lnbNL = getelementptr inbounds i64, i64* %lnbNK, i32 9
  %lnbNM = bitcast i64* %lnbNL to i64*
  %lnbNN = load i64, i64* %lnbNM, !tbaa !2
  store i64 %lnbNN, i64* %lsaFg
  %lnbNO = load i64*, i64** %Sp_Var
  %lnbNP = getelementptr inbounds i64, i64* %lnbNO, i32 3
  %lnbNQ = bitcast i64* %lnbNP to i64*
  %lnbNR = load i64, i64* %lnbNQ, !tbaa !2
  store i64 %lnbNR, i64* %lsaFY
  %lnbNS = load i64*, i64** %Sp_Var
  %lnbNT = getelementptr inbounds i64, i64* %lnbNS, i32 4
  %lnbNU = bitcast i64* %lnbNT to double*
  %lnbNV = load double, double* %lnbNU, !tbaa !2
  store double %lnbNV, double* %lsaFZ
  %lnbNW = load i64, i64* %lsaFY
  %lnbNX = load i64*, i64** %Sp_Var
  %lnbNY = getelementptr inbounds i64, i64* %lnbNX, i32 7
  %lnbNZ = bitcast i64* %lnbNY to i64*
  %lnbO0 = load i64, i64* %lnbNZ, !tbaa !2
  %lnbO1 = icmp sge i64 %lnbNW, %lnbO0
  %lnbO2 = zext i1 %lnbO1 to i64
  switch i64 %lnbO2, label %cbh0 [i64 1, label %cbh1]
cbh0:
  %lnbO3 = load i64*, i64** %Sp_Var
  %lnbO4 = getelementptr inbounds i64, i64* %lnbO3, i32 2
  %lnbO5 = bitcast i64* %lnbO4 to i64*
  %lnbO6 = load i64, i64* %lnbO5, !tbaa !2
  store i64 %lnbO6, i64* %lsaFX
  %lnbO7 = load i64, i64* %lsaFX
  %lnbO8 = load i64*, i64** %Sp_Var
  %lnbO9 = getelementptr inbounds i64, i64* %lnbO8, i32 0
  %lnbOa = bitcast i64* %lnbO9 to i64*
  %lnbOb = load i64, i64* %lnbOa, !tbaa !2
  %lnbOc = icmp sge i64 %lnbO7, %lnbOb
  %lnbOd = zext i1 %lnbOc to i64
  switch i64 %lnbOd, label %cbgR [i64 1, label %cbgY]
cbgR:
  %lnbOe = load i64*, i64** %Sp_Var
  %lnbOf = getelementptr inbounds i64, i64* %lnbOe, i32 6
  %lnbOg = bitcast i64* %lnbOf to i64*
  %lnbOh = load i64, i64* %lnbOg, !tbaa !2
  %lnbOi = load i64*, i64** %Sp_Var
  %lnbOj = getelementptr inbounds i64, i64* %lnbOi, i32 8
  %lnbOk = bitcast i64* %lnbOj to i64*
  %lnbOl = load i64, i64* %lnbOk, !tbaa !2
  %lnbOm = load i64, i64* %lsaFY
  %lnbOn = add i64 %lnbOl, %lnbOm
  %lnbOo = shl i64 %lnbOn, 3
  %lnbOp = add i64 %lnbOo, 24
  %lnbOq = add i64 %lnbOh, %lnbOp
  %lnbOr = inttoptr i64 %lnbOq to i64*
  %lnbOs = load i64, i64* %lnbOr, !tbaa !1
  store i64 %lnbOs, i64* %lsaG3
  %lnbOt = load i64*, i64** %Sp_Var
  %lnbOu = getelementptr inbounds i64, i64* %lnbOt, i32 1
  %lnbOv = bitcast i64* %lnbOu to i64*
  %lnbOw = load i64, i64* %lnbOv, !tbaa !2
  %lnbOx = load i64*, i64** %Sp_Var
  %lnbOy = getelementptr inbounds i64, i64* %lnbOx, i32 5
  %lnbOz = bitcast i64* %lnbOy to i64*
  %lnbOA = load i64, i64* %lnbOz, !tbaa !2
  %lnbOB = load i64, i64* %lsaFX
  %lnbOC = add i64 %lnbOA, %lnbOB
  %lnbOD = shl i64 %lnbOC, 3
  %lnbOE = add i64 %lnbOD, 24
  %lnbOF = add i64 %lnbOw, %lnbOE
  %lnbOG = inttoptr i64 %lnbOF to i64*
  %lnbOH = load i64, i64* %lnbOG, !tbaa !1
  store i64 %lnbOH, i64* %lsaG7
  %lnbOJ = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbgK_info$def to i64
  %lnbOI = load i64*, i64** %Sp_Var
  %lnbOK = getelementptr inbounds i64, i64* %lnbOI, i32 -2
  store i64 %lnbOJ, i64* %lnbOK, !tbaa !2
  %lnbOL = load i64, i64* %lsaG3
  store i64 %lnbOL, i64* %R1_Var
  %lnbON = load i64, i64* %lsaG7
  %lnbOM = load i64*, i64** %Sp_Var
  %lnbOO = getelementptr inbounds i64, i64* %lnbOM, i32 -1
  store i64 %lnbON, i64* %lnbOO, !tbaa !2
  %lnbOP = load i64*, i64** %Sp_Var
  %lnbOQ = getelementptr inbounds i64, i64* %lnbOP, i32 -2
  %lnbOR = ptrtoint i64* %lnbOQ to i64
  %lnbOS = inttoptr i64 %lnbOR to i64*
  store i64* %lnbOS, i64** %Sp_Var
  %lnbOT = load i64, i64* %R1_Var
  %lnbOU = and i64 %lnbOT, 7
  %lnbOV = icmp ne i64 %lnbOU, 0
  br i1 %lnbOV, label %ubhh, label %cbgL
cbgL:
  %lnbOX = load i64, i64* %R1_Var
  %lnbOY = inttoptr i64 %lnbOX to i64*
  %lnbOZ = load i64, i64* %lnbOY, !tbaa !4
  %lnbP0 = inttoptr i64 %lnbOZ to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbP1 = load i64*, i64** %Sp_Var
  %lnbP2 = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbP0( i64* %Base_Arg, i64* %lnbP1, i64* %Hp_Arg, i64 %lnbP2, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ubhh:
  %lnbP3 = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbgK_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbP4 = load i64*, i64** %Sp_Var
  %lnbP5 = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbP3( i64* %Base_Arg, i64* %lnbP4, i64* %Hp_Arg, i64 %lnbP5, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cbgY:
  %lnbP7 = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbfX_info$def to i64
  %lnbP6 = load i64*, i64** %Sp_Var
  %lnbP8 = getelementptr inbounds i64, i64* %lnbP6, i32 8
  store i64 %lnbP7, i64* %lnbP8, !tbaa !2
  %lnbP9 = load i64, i64* %lsaFg
  store i64 %lnbP9, i64* %R1_Var
  %lnbPb = load double, double* %lsaFZ
  %lnbPa = load i64*, i64** %Sp_Var
  %lnbPc = getelementptr inbounds i64, i64* %lnbPa, i32 9
  %lnbPd = bitcast i64* %lnbPc to double*
  store double %lnbPb, double* %lnbPd, !tbaa !2
  %lnbPe = load i64*, i64** %Sp_Var
  %lnbPf = getelementptr inbounds i64, i64* %lnbPe, i32 8
  %lnbPg = ptrtoint i64* %lnbPf to i64
  %lnbPh = inttoptr i64 %lnbPg to i64*
  store i64* %lnbPh, i64** %Sp_Var
  %lnbPi = load i64, i64* %R1_Var
  %lnbPj = and i64 %lnbPi, 7
  %lnbPk = icmp ne i64 %lnbPj, 0
  br i1 %lnbPk, label %ubhi, label %cbfY
cbfY:
  %lnbPm = load i64, i64* %R1_Var
  %lnbPn = inttoptr i64 %lnbPm to i64*
  %lnbPo = load i64, i64* %lnbPn, !tbaa !4
  %lnbPp = inttoptr i64 %lnbPo to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbPq = load i64*, i64** %Sp_Var
  %lnbPr = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbPp( i64* %Base_Arg, i64* %lnbPq, i64* %Hp_Arg, i64 %lnbPr, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ubhi:
  %lnbPs = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbfX_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbPt = load i64*, i64** %Sp_Var
  %lnbPu = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbPs( i64* %Base_Arg, i64* %lnbPt, i64* %Hp_Arg, i64 %lnbPu, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cbh1:
  %lnbPw = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbgf_info$def to i64
  %lnbPv = load i64*, i64** %Sp_Var
  %lnbPx = getelementptr inbounds i64, i64* %lnbPv, i32 8
  store i64 %lnbPw, i64* %lnbPx, !tbaa !2
  %lnbPy = load i64, i64* %lsaFg
  store i64 %lnbPy, i64* %R1_Var
  %lnbPA = load double, double* %lsaFZ
  %lnbPz = load i64*, i64** %Sp_Var
  %lnbPB = getelementptr inbounds i64, i64* %lnbPz, i32 9
  %lnbPC = bitcast i64* %lnbPB to double*
  store double %lnbPA, double* %lnbPC, !tbaa !2
  %lnbPD = load i64*, i64** %Sp_Var
  %lnbPE = getelementptr inbounds i64, i64* %lnbPD, i32 8
  %lnbPF = ptrtoint i64* %lnbPE to i64
  %lnbPG = inttoptr i64 %lnbPF to i64*
  store i64* %lnbPG, i64** %Sp_Var
  %lnbPH = load i64, i64* %R1_Var
  %lnbPI = and i64 %lnbPH, 7
  %lnbPJ = icmp ne i64 %lnbPI, 0
  br i1 %lnbPJ, label %ubhj, label %cbgg
cbgg:
  %lnbPL = load i64, i64* %R1_Var
  %lnbPM = inttoptr i64 %lnbPL to i64*
  %lnbPN = load i64, i64* %lnbPM, !tbaa !4
  %lnbPO = inttoptr i64 %lnbPN to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbPP = load i64*, i64** %Sp_Var
  %lnbPQ = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbPO( i64* %Base_Arg, i64* %lnbPP, i64* %Hp_Arg, i64 %lnbPQ, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ubhj:
  %lnbPR = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbgf_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbPS = load i64*, i64** %Sp_Var
  %lnbPT = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbPR( i64* %Base_Arg, i64* %lnbPS, i64* %Hp_Arg, i64 %lnbPT, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cbgf_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbgf_info$def to i8*)
define internal ghccc void @cbgf_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 65, i32 30, i32 0}>
{
cbgf:
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %lsaFV = alloca double, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnbPU = load i64*, i64** %Hp_Var
  %lnbPV = getelementptr inbounds i64, i64* %lnbPU, i32 2
  %lnbPW = ptrtoint i64* %lnbPV to i64
  %lnbPX = inttoptr i64 %lnbPW to i64*
  store i64* %lnbPX, i64** %Hp_Var
  %lnbPY = load i64*, i64** %Hp_Var
  %lnbPZ = ptrtoint i64* %lnbPY to i64
  %lnbQ0 = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lnbQ1 = bitcast i64* %lnbQ0 to i64*
  %lnbQ2 = load i64, i64* %lnbQ1, !tbaa !5
  %lnbQ3 = icmp ugt i64 %lnbPZ, %lnbQ2
  %lnbQ4 = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnbQ3, i1 0 )
  br i1 %lnbQ4, label %cbgr, label %cbgq
cbgq:
  %lnbQ5 = load i64*, i64** %Sp_Var
  %lnbQ6 = getelementptr inbounds i64, i64* %lnbQ5, i32 1
  %lnbQ7 = bitcast i64* %lnbQ6 to double*
  %lnbQ8 = load double, double* %lnbQ7, !tbaa !2
  %lnbQb = load i64, i64* %R1_Var
  %lnbQc = add i64 %lnbQb, 7
  %lnbQd = inttoptr i64 %lnbQc to double*
  %lnbQe = load double, double* %lnbQd, !tbaa !4
  %lnbQf = fdiv double %lnbQ8, %lnbQe
  store double %lnbQf, double* %lsaFV
  %lnbQh = ptrtoint i8* @ghczmprim_GHCziTypes_Dzh_con_info to i64
  %lnbQg = load i64*, i64** %Hp_Var
  %lnbQi = getelementptr inbounds i64, i64* %lnbQg, i32 -1
  store i64 %lnbQh, i64* %lnbQi, !tbaa !3
  %lnbQk = load double, double* %lsaFV
  %lnbQj = load i64*, i64** %Hp_Var
  %lnbQl = getelementptr inbounds i64, i64* %lnbQj, i32 0
  %lnbQm = bitcast i64* %lnbQl to double*
  store double %lnbQk, double* %lnbQm, !tbaa !3
  %lnbQo = load i64*, i64** %Hp_Var
  %lnbQp = ptrtoint i64* %lnbQo to i64
  %lnbQq = add i64 %lnbQp, -7
  store i64 %lnbQq, i64* %R1_Var
  %lnbQr = load i64*, i64** %Sp_Var
  %lnbQs = getelementptr inbounds i64, i64* %lnbQr, i32 2
  %lnbQt = ptrtoint i64* %lnbQs to i64
  %lnbQu = inttoptr i64 %lnbQt to i64*
  store i64* %lnbQu, i64** %Sp_Var
  %lnbQv = load i64*, i64** %Sp_Var
  %lnbQw = getelementptr inbounds i64, i64* %lnbQv, i32 0
  %lnbQx = bitcast i64* %lnbQw to i64*
  %lnbQy = load i64, i64* %lnbQx, !tbaa !2
  %lnbQz = inttoptr i64 %lnbQy to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbQA = load i64*, i64** %Sp_Var
  %lnbQB = load i64*, i64** %Hp_Var
  %lnbQC = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbQz( i64* %Base_Arg, i64* %lnbQA, i64* %lnbQB, i64 %lnbQC, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cbgr:
  %lnbQD = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 16, i64* %lnbQD, !tbaa !5
  %lnbQE = load i64, i64* %R1_Var
  store i64 %lnbQE, i64* %R1_Var
  %lnbQF = bitcast i8* @stg_gc_unpt_r1 to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbQG = load i64*, i64** %Sp_Var
  %lnbQH = load i64*, i64** %Hp_Var
  %lnbQI = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbQF( i64* %Base_Arg, i64* %lnbQG, i64* %lnbQH, i64 %lnbQI, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cbfX_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbfX_info$def to i8*)
define internal ghccc void @cbfX_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 65, i32 30, i32 0}>
{
cbfX:
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %lsaFQ = alloca double, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnbQJ = load i64*, i64** %Hp_Var
  %lnbQK = getelementptr inbounds i64, i64* %lnbQJ, i32 2
  %lnbQL = ptrtoint i64* %lnbQK to i64
  %lnbQM = inttoptr i64 %lnbQL to i64*
  store i64* %lnbQM, i64** %Hp_Var
  %lnbQN = load i64*, i64** %Hp_Var
  %lnbQO = ptrtoint i64* %lnbQN to i64
  %lnbQP = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lnbQQ = bitcast i64* %lnbQP to i64*
  %lnbQR = load i64, i64* %lnbQQ, !tbaa !5
  %lnbQS = icmp ugt i64 %lnbQO, %lnbQR
  %lnbQT = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnbQS, i1 0 )
  br i1 %lnbQT, label %cbg9, label %cbg8
cbg8:
  %lnbQU = load i64*, i64** %Sp_Var
  %lnbQV = getelementptr inbounds i64, i64* %lnbQU, i32 1
  %lnbQW = bitcast i64* %lnbQV to double*
  %lnbQX = load double, double* %lnbQW, !tbaa !2
  %lnbR0 = load i64, i64* %R1_Var
  %lnbR1 = add i64 %lnbR0, 7
  %lnbR2 = inttoptr i64 %lnbR1 to double*
  %lnbR3 = load double, double* %lnbR2, !tbaa !4
  %lnbR4 = fdiv double %lnbQX, %lnbR3
  store double %lnbR4, double* %lsaFQ
  %lnbR6 = ptrtoint i8* @ghczmprim_GHCziTypes_Dzh_con_info to i64
  %lnbR5 = load i64*, i64** %Hp_Var
  %lnbR7 = getelementptr inbounds i64, i64* %lnbR5, i32 -1
  store i64 %lnbR6, i64* %lnbR7, !tbaa !3
  %lnbR9 = load double, double* %lsaFQ
  %lnbR8 = load i64*, i64** %Hp_Var
  %lnbRa = getelementptr inbounds i64, i64* %lnbR8, i32 0
  %lnbRb = bitcast i64* %lnbRa to double*
  store double %lnbR9, double* %lnbRb, !tbaa !3
  %lnbRd = load i64*, i64** %Hp_Var
  %lnbRe = ptrtoint i64* %lnbRd to i64
  %lnbRf = add i64 %lnbRe, -7
  store i64 %lnbRf, i64* %R1_Var
  %lnbRg = load i64*, i64** %Sp_Var
  %lnbRh = getelementptr inbounds i64, i64* %lnbRg, i32 2
  %lnbRi = ptrtoint i64* %lnbRh to i64
  %lnbRj = inttoptr i64 %lnbRi to i64*
  store i64* %lnbRj, i64** %Sp_Var
  %lnbRk = load i64*, i64** %Sp_Var
  %lnbRl = getelementptr inbounds i64, i64* %lnbRk, i32 0
  %lnbRm = bitcast i64* %lnbRl to i64*
  %lnbRn = load i64, i64* %lnbRm, !tbaa !2
  %lnbRo = inttoptr i64 %lnbRn to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbRp = load i64*, i64** %Sp_Var
  %lnbRq = load i64*, i64** %Hp_Var
  %lnbRr = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbRo( i64* %Base_Arg, i64* %lnbRp, i64* %lnbRq, i64 %lnbRr, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cbg9:
  %lnbRs = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 16, i64* %lnbRs, !tbaa !5
  %lnbRt = load i64, i64* %R1_Var
  store i64 %lnbRt, i64* %R1_Var
  %lnbRu = bitcast i8* @stg_gc_unpt_r1 to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbRv = load i64*, i64** %Sp_Var
  %lnbRw = load i64*, i64** %Hp_Var
  %lnbRx = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbRu( i64* %Base_Arg, i64* %lnbRv, i64* %lnbRw, i64 %lnbRx, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cbgK_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbgK_info$def to i8*)
define internal ghccc void @cbgK_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 56971, i32 30, i32 0}>
{
cbgK:
  %lsaG9 = alloca double, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lnbRy = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbgP_info$def to i64
  %lnbRz = getelementptr inbounds i64, i64* %Sp_Arg, i32 0
  store i64 %lnbRy, i64* %lnbRz, !tbaa !2
  %lnbRC = load i64, i64* %R1_Var
  %lnbRD = add i64 %lnbRC, 7
  %lnbRE = inttoptr i64 %lnbRD to double*
  %lnbRF = load double, double* %lnbRE, !tbaa !4
  store double %lnbRF, double* %lsaG9
  %lnbRG = getelementptr inbounds i64, i64* %Sp_Arg, i32 1
  %lnbRH = bitcast i64* %lnbRG to i64*
  %lnbRI = load i64, i64* %lnbRH, !tbaa !2
  store i64 %lnbRI, i64* %R1_Var
  %lnbRJ = load double, double* %lsaG9
  %lnbRK = getelementptr inbounds i64, i64* %Sp_Arg, i32 1
  %lnbRL = bitcast i64* %lnbRK to double*
  store double %lnbRJ, double* %lnbRL, !tbaa !2
  %lnbRM = load i64, i64* %R1_Var
  %lnbRN = and i64 %lnbRM, 7
  %lnbRO = icmp ne i64 %lnbRN, 0
  br i1 %lnbRO, label %ubhk, label %cbgT
cbgT:
  %lnbRQ = load i64, i64* %R1_Var
  %lnbRR = inttoptr i64 %lnbRQ to i64*
  %lnbRS = load i64, i64* %lnbRR, !tbaa !4
  %lnbRT = inttoptr i64 %lnbRS to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbRU = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbRT( i64* %Base_Arg, i64* %Sp_Arg, i64* %Hp_Arg, i64 %lnbRU, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ubhk:
  %lnbRV = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbgP_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbRW = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbRV( i64* %Base_Arg, i64* %Sp_Arg, i64* %Hp_Arg, i64 %lnbRW, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cbgP_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbgP_info$def to i8*)
define internal ghccc void @cbgP_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 57035, i32 30, i32 0}>
{
cbgP:
  %lsaFZ = alloca double, i32 1
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnbRX = load i64*, i64** %Sp_Var
  %lnbRY = getelementptr inbounds i64, i64* %lnbRX, i32 6
  %lnbRZ = bitcast i64* %lnbRY to double*
  %lnbS0 = load double, double* %lnbRZ, !tbaa !2
  %lnbS1 = load i64*, i64** %Sp_Var
  %lnbS2 = getelementptr inbounds i64, i64* %lnbS1, i32 1
  %lnbS3 = bitcast i64* %lnbS2 to double*
  %lnbS4 = load double, double* %lnbS3, !tbaa !2
  %lnbS5 = add i64 %R1_Arg, 7
  %lnbS6 = inttoptr i64 %lnbS5 to double*
  %lnbS7 = load double, double* %lnbS6, !tbaa !4
  %lnbS8 = fmul double %lnbS4, %lnbS7
  %lnbS9 = fadd double %lnbS0, %lnbS8
  store double %lnbS9, double* %lsaFZ
  %lnbSb = load i64*, i64** %Sp_Var
  %lnbSc = getelementptr inbounds i64, i64* %lnbSb, i32 4
  %lnbSd = bitcast i64* %lnbSc to i64*
  %lnbSe = load i64, i64* %lnbSd, !tbaa !2
  %lnbSf = add i64 %lnbSe, 1
  %lnbSa = load i64*, i64** %Sp_Var
  %lnbSg = getelementptr inbounds i64, i64* %lnbSa, i32 4
  store i64 %lnbSf, i64* %lnbSg, !tbaa !2
  %lnbSi = load i64*, i64** %Sp_Var
  %lnbSj = getelementptr inbounds i64, i64* %lnbSi, i32 5
  %lnbSk = bitcast i64* %lnbSj to i64*
  %lnbSl = load i64, i64* %lnbSk, !tbaa !2
  %lnbSm = add i64 %lnbSl, 1
  %lnbSh = load i64*, i64** %Sp_Var
  %lnbSn = getelementptr inbounds i64, i64* %lnbSh, i32 5
  store i64 %lnbSm, i64* %lnbSn, !tbaa !2
  %lnbSp = load double, double* %lsaFZ
  %lnbSo = load i64*, i64** %Sp_Var
  %lnbSq = getelementptr inbounds i64, i64* %lnbSo, i32 6
  %lnbSr = bitcast i64* %lnbSq to double*
  store double %lnbSp, double* %lnbSr, !tbaa !2
  %lnbSs = load i64*, i64** %Sp_Var
  %lnbSt = getelementptr inbounds i64, i64* %lnbSs, i32 2
  %lnbSu = ptrtoint i64* %lnbSt to i64
  %lnbSv = inttoptr i64 %lnbSu to i64*
  store i64* %lnbSv, i64** %Sp_Var
  %lnbSw = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @_cbgu$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbSx = load i64*, i64** %Sp_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbSw( i64* %Base_Arg, i64* %lnbSx, i64* %Hp_Arg, i64 %R1_Arg, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saGA_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saGA_info$def to i8*)
define internal ghccc void @saGA_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 2, i32 18, i32 0}>
{
cbhG:
  %lsaGu = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnbSy = load i64*, i64** %Sp_Var
  %lnbSz = getelementptr inbounds i64, i64* %lnbSy, i32 -4
  %lnbSA = ptrtoint i64* %lnbSz to i64
  %lnbSB = icmp ult i64 %lnbSA, %SpLim_Arg
  %lnbSC = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnbSB, i1 0 )
  br i1 %lnbSC, label %cbhS, label %cbhT
cbhT:
  %lnbSE = ptrtoint i8* @stg_upd_frame_info to i64
  %lnbSD = load i64*, i64** %Sp_Var
  %lnbSF = getelementptr inbounds i64, i64* %lnbSD, i32 -2
  store i64 %lnbSE, i64* %lnbSF, !tbaa !2
  %lnbSH = load i64, i64* %R1_Var
  %lnbSG = load i64*, i64** %Sp_Var
  %lnbSI = getelementptr inbounds i64, i64* %lnbSG, i32 -1
  store i64 %lnbSH, i64* %lnbSI, !tbaa !2
  %lnbSK = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbhD_info$def to i64
  %lnbSJ = load i64*, i64** %Sp_Var
  %lnbSL = getelementptr inbounds i64, i64* %lnbSJ, i32 -4
  store i64 %lnbSK, i64* %lnbSL, !tbaa !2
  %lnbSO = load i64, i64* %R1_Var
  %lnbSP = add i64 %lnbSO, 24
  %lnbSQ = inttoptr i64 %lnbSP to i64*
  %lnbSR = load i64, i64* %lnbSQ, !tbaa !4
  store i64 %lnbSR, i64* %lsaGu
  %lnbSU = load i64, i64* %R1_Var
  %lnbSV = add i64 %lnbSU, 16
  %lnbSW = inttoptr i64 %lnbSV to i64*
  %lnbSX = load i64, i64* %lnbSW, !tbaa !4
  store i64 %lnbSX, i64* %R1_Var
  %lnbSZ = load i64, i64* %lsaGu
  %lnbSY = load i64*, i64** %Sp_Var
  %lnbT0 = getelementptr inbounds i64, i64* %lnbSY, i32 -3
  store i64 %lnbSZ, i64* %lnbT0, !tbaa !2
  %lnbT1 = load i64*, i64** %Sp_Var
  %lnbT2 = getelementptr inbounds i64, i64* %lnbT1, i32 -4
  %lnbT3 = ptrtoint i64* %lnbT2 to i64
  %lnbT4 = inttoptr i64 %lnbT3 to i64*
  store i64* %lnbT4, i64** %Sp_Var
  %lnbT5 = load i64, i64* %R1_Var
  %lnbT6 = and i64 %lnbT5, 7
  %lnbT7 = icmp ne i64 %lnbT6, 0
  br i1 %lnbT7, label %ubhZ, label %cbhE
cbhE:
  %lnbT9 = load i64, i64* %R1_Var
  %lnbTa = inttoptr i64 %lnbT9 to i64*
  %lnbTb = load i64, i64* %lnbTa, !tbaa !4
  %lnbTc = inttoptr i64 %lnbTb to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbTd = load i64*, i64** %Sp_Var
  %lnbTe = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbTc( i64* %Base_Arg, i64* %lnbTd, i64* %Hp_Arg, i64 %lnbTe, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ubhZ:
  %lnbTf = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbhD_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbTg = load i64*, i64** %Sp_Var
  %lnbTh = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbTf( i64* %Base_Arg, i64* %lnbTg, i64* %Hp_Arg, i64 %lnbTh, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cbhS:
  %lnbTi = load i64, i64* %R1_Var
  store i64 %lnbTi, i64* %R1_Var
  %lnbTj = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lnbTk = bitcast i64* %lnbTj to i64*
  %lnbTl = load i64, i64* %lnbTk, !tbaa !5
  %lnbTm = inttoptr i64 %lnbTl to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbTn = load i64*, i64** %Sp_Var
  %lnbTo = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbTm( i64* %Base_Arg, i64* %lnbTn, i64* %Hp_Arg, i64 %lnbTo, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cbhD_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbhD_info$def to i8*)
define internal ghccc void @cbhD_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 1, i32 30, i32 0}>
{
cbhD:
  %lsaGw = alloca double, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lnbTp = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbhJ_info$def to i64
  %lnbTq = getelementptr inbounds i64, i64* %Sp_Arg, i32 0
  store i64 %lnbTp, i64* %lnbTq, !tbaa !2
  %lnbTt = load i64, i64* %R1_Var
  %lnbTu = add i64 %lnbTt, 7
  %lnbTv = inttoptr i64 %lnbTu to double*
  %lnbTw = load double, double* %lnbTv, !tbaa !4
  store double %lnbTw, double* %lsaGw
  %lnbTx = getelementptr inbounds i64, i64* %Sp_Arg, i32 1
  %lnbTy = bitcast i64* %lnbTx to i64*
  %lnbTz = load i64, i64* %lnbTy, !tbaa !2
  store i64 %lnbTz, i64* %R1_Var
  %lnbTA = load double, double* %lsaGw
  %lnbTB = getelementptr inbounds i64, i64* %Sp_Arg, i32 1
  %lnbTC = bitcast i64* %lnbTB to double*
  store double %lnbTA, double* %lnbTC, !tbaa !2
  %lnbTD = load i64, i64* %R1_Var
  %lnbTE = and i64 %lnbTD, 7
  %lnbTF = icmp ne i64 %lnbTE, 0
  br i1 %lnbTF, label %ubhY, label %cbhK
cbhK:
  %lnbTH = load i64, i64* %R1_Var
  %lnbTI = inttoptr i64 %lnbTH to i64*
  %lnbTJ = load i64, i64* %lnbTI, !tbaa !4
  %lnbTK = inttoptr i64 %lnbTJ to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbTL = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbTK( i64* %Base_Arg, i64* %Sp_Arg, i64* %Hp_Arg, i64 %lnbTL, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ubhY:
  %lnbTM = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbhJ_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbTN = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbTM( i64* %Base_Arg, i64* %Sp_Arg, i64* %Hp_Arg, i64 %lnbTN, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cbhJ_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbhJ_info$def to i8*)
define internal ghccc void @cbhJ_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 65, i32 30, i32 0}>
{
cbhJ:
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %lsaGz = alloca double, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnbTO = load i64*, i64** %Hp_Var
  %lnbTP = getelementptr inbounds i64, i64* %lnbTO, i32 2
  %lnbTQ = ptrtoint i64* %lnbTP to i64
  %lnbTR = inttoptr i64 %lnbTQ to i64*
  store i64* %lnbTR, i64** %Hp_Var
  %lnbTS = load i64*, i64** %Hp_Var
  %lnbTT = ptrtoint i64* %lnbTS to i64
  %lnbTU = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lnbTV = bitcast i64* %lnbTU to i64*
  %lnbTW = load i64, i64* %lnbTV, !tbaa !5
  %lnbTX = icmp ugt i64 %lnbTT, %lnbTW
  %lnbTY = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnbTX, i1 0 )
  br i1 %lnbTY, label %cbhX, label %cbhW
cbhW:
  %lnbTZ = load i64*, i64** %Sp_Var
  %lnbU0 = getelementptr inbounds i64, i64* %lnbTZ, i32 1
  %lnbU1 = bitcast i64* %lnbU0 to double*
  %lnbU2 = load double, double* %lnbU1, !tbaa !2
  %lnbU5 = load i64, i64* %R1_Var
  %lnbU6 = add i64 %lnbU5, 7
  %lnbU7 = inttoptr i64 %lnbU6 to double*
  %lnbU8 = load double, double* %lnbU7, !tbaa !4
  %lnbU9 = fmul double %lnbU2, %lnbU8
  store double %lnbU9, double* %lsaGz
  %lnbUb = ptrtoint i8* @ghczmprim_GHCziTypes_Dzh_con_info to i64
  %lnbUa = load i64*, i64** %Hp_Var
  %lnbUc = getelementptr inbounds i64, i64* %lnbUa, i32 -1
  store i64 %lnbUb, i64* %lnbUc, !tbaa !3
  %lnbUe = load double, double* %lsaGz
  %lnbUd = load i64*, i64** %Hp_Var
  %lnbUf = getelementptr inbounds i64, i64* %lnbUd, i32 0
  %lnbUg = bitcast i64* %lnbUf to double*
  store double %lnbUe, double* %lnbUg, !tbaa !3
  %lnbUi = load i64*, i64** %Hp_Var
  %lnbUj = ptrtoint i64* %lnbUi to i64
  %lnbUk = add i64 %lnbUj, -7
  store i64 %lnbUk, i64* %R1_Var
  %lnbUl = load i64*, i64** %Sp_Var
  %lnbUm = getelementptr inbounds i64, i64* %lnbUl, i32 2
  %lnbUn = ptrtoint i64* %lnbUm to i64
  %lnbUo = inttoptr i64 %lnbUn to i64*
  store i64* %lnbUo, i64** %Sp_Var
  %lnbUp = load i64*, i64** %Sp_Var
  %lnbUq = getelementptr inbounds i64, i64* %lnbUp, i32 0
  %lnbUr = bitcast i64* %lnbUq to i64*
  %lnbUs = load i64, i64* %lnbUr, !tbaa !2
  %lnbUt = inttoptr i64 %lnbUs to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbUu = load i64*, i64** %Sp_Var
  %lnbUv = load i64*, i64** %Hp_Var
  %lnbUw = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbUt( i64* %Base_Arg, i64* %lnbUu, i64* %lnbUv, i64 %lnbUw, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cbhX:
  %lnbUx = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 16, i64* %lnbUx, !tbaa !5
  %lnbUy = load i64, i64* %R1_Var
  store i64 %lnbUy, i64* %R1_Var
  %lnbUz = bitcast i8* @stg_gc_unpt_r1 to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbUA = load i64*, i64** %Sp_Var
  %lnbUB = load i64*, i64** %Hp_Var
  %lnbUC = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbUz( i64* %Base_Arg, i64* %lnbUA, i64* %lnbUB, i64 %lnbUC, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saFv_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saFv_info$def to i8*)
define internal ghccc void @saFv_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 5, i32 15, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%ubmp_srt_struct* @ubmp_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saFv_info$def to i64)) to i32),i32 0)}>
{
cbi0:
  %lsaDl = alloca i64, i32 1
  %lsaFf = alloca i64, i32 1
  %lsaFg = alloca i64, i32 1
  %lsaFn = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnbUD = load i64*, i64** %Sp_Var
  %lnbUE = getelementptr inbounds i64, i64* %lnbUD, i32 -12
  %lnbUF = ptrtoint i64* %lnbUE to i64
  %lnbUG = icmp ult i64 %lnbUF, %SpLim_Arg
  %lnbUH = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnbUG, i1 0 )
  br i1 %lnbUH, label %cbi1, label %cbi2
cbi2:
  %lnbUJ = ptrtoint i8* @stg_upd_frame_info to i64
  %lnbUI = load i64*, i64** %Sp_Var
  %lnbUK = getelementptr inbounds i64, i64* %lnbUI, i32 -2
  store i64 %lnbUJ, i64* %lnbUK, !tbaa !2
  %lnbUM = load i64, i64* %R1_Var
  %lnbUL = load i64*, i64** %Sp_Var
  %lnbUN = getelementptr inbounds i64, i64* %lnbUL, i32 -1
  store i64 %lnbUM, i64* %lnbUN, !tbaa !2
  %lnbUP = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbfs_info$def to i64
  %lnbUO = load i64*, i64** %Sp_Var
  %lnbUQ = getelementptr inbounds i64, i64* %lnbUO, i32 -7
  store i64 %lnbUP, i64* %lnbUQ, !tbaa !2
  %lnbUT = load i64, i64* %R1_Var
  %lnbUU = add i64 %lnbUT, 16
  %lnbUV = inttoptr i64 %lnbUU to i64*
  %lnbUW = load i64, i64* %lnbUV, !tbaa !4
  store i64 %lnbUW, i64* %lsaDl
  %lnbUZ = load i64, i64* %R1_Var
  %lnbV0 = add i64 %lnbUZ, 32
  %lnbV1 = inttoptr i64 %lnbV0 to i64*
  %lnbV2 = load i64, i64* %lnbV1, !tbaa !4
  store i64 %lnbV2, i64* %lsaFf
  %lnbV5 = load i64, i64* %R1_Var
  %lnbV6 = add i64 %lnbV5, 40
  %lnbV7 = inttoptr i64 %lnbV6 to i64*
  %lnbV8 = load i64, i64* %lnbV7, !tbaa !4
  store i64 %lnbV8, i64* %lsaFg
  %lnbVb = load i64, i64* %R1_Var
  %lnbVc = add i64 %lnbVb, 48
  %lnbVd = inttoptr i64 %lnbVc to i64*
  %lnbVe = load i64, i64* %lnbVd, !tbaa !4
  store i64 %lnbVe, i64* %lsaFn
  %lnbVh = load i64, i64* %R1_Var
  %lnbVi = add i64 %lnbVh, 24
  %lnbVj = inttoptr i64 %lnbVi to i64*
  %lnbVk = load i64, i64* %lnbVj, !tbaa !4
  store i64 %lnbVk, i64* %R1_Var
  %lnbVm = load i64, i64* %lsaDl
  %lnbVl = load i64*, i64** %Sp_Var
  %lnbVn = getelementptr inbounds i64, i64* %lnbVl, i32 -6
  store i64 %lnbVm, i64* %lnbVn, !tbaa !2
  %lnbVp = load i64, i64* %lsaFf
  %lnbVo = load i64*, i64** %Sp_Var
  %lnbVq = getelementptr inbounds i64, i64* %lnbVo, i32 -5
  store i64 %lnbVp, i64* %lnbVq, !tbaa !2
  %lnbVs = load i64, i64* %lsaFg
  %lnbVr = load i64*, i64** %Sp_Var
  %lnbVt = getelementptr inbounds i64, i64* %lnbVr, i32 -4
  store i64 %lnbVs, i64* %lnbVt, !tbaa !2
  %lnbVv = load i64, i64* %lsaFn
  %lnbVu = load i64*, i64** %Sp_Var
  %lnbVw = getelementptr inbounds i64, i64* %lnbVu, i32 -3
  store i64 %lnbVv, i64* %lnbVw, !tbaa !2
  %lnbVx = load i64*, i64** %Sp_Var
  %lnbVy = getelementptr inbounds i64, i64* %lnbVx, i32 -7
  %lnbVz = ptrtoint i64* %lnbVy to i64
  %lnbVA = inttoptr i64 %lnbVz to i64*
  store i64* %lnbVA, i64** %Sp_Var
  %lnbVB = load i64, i64* %R1_Var
  %lnbVC = and i64 %lnbVB, 7
  %lnbVD = icmp ne i64 %lnbVC, 0
  br i1 %lnbVD, label %ubiz, label %cbft
cbft:
  %lnbVF = load i64, i64* %R1_Var
  %lnbVG = inttoptr i64 %lnbVF to i64*
  %lnbVH = load i64, i64* %lnbVG, !tbaa !4
  %lnbVI = inttoptr i64 %lnbVH to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbVJ = load i64*, i64** %Sp_Var
  %lnbVK = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbVI( i64* %Base_Arg, i64* %lnbVJ, i64* %Hp_Arg, i64 %lnbVK, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ubiz:
  %lnbVL = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbfs_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbVM = load i64*, i64** %Sp_Var
  %lnbVN = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbVL( i64* %Base_Arg, i64* %lnbVM, i64* %Hp_Arg, i64 %lnbVN, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cbi1:
  %lnbVO = load i64, i64* %R1_Var
  store i64 %lnbVO, i64* %R1_Var
  %lnbVP = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lnbVQ = bitcast i64* %lnbVP to i64*
  %lnbVR = load i64, i64* %lnbVQ, !tbaa !5
  %lnbVS = inttoptr i64 %lnbVR to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbVT = load i64*, i64** %Sp_Var
  %lnbVU = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbVS( i64* %Base_Arg, i64* %lnbVT, i64* %Hp_Arg, i64 %lnbVU, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cbfs_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbfs_info$def to i8*)
define internal ghccc void @cbfs_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 4, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%ubmo_srt_struct* @ubmo_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbfs_info$def to i64)) to i32),i32 0)}>
{
cbfs:
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %lsaFz = alloca i64, i32 1
  %lsaFx = alloca i64, i32 1
  %lsaFy = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnbVW = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbfx_info$def to i64
  %lnbVV = load i64*, i64** %Sp_Var
  %lnbVX = getelementptr inbounds i64, i64* %lnbVV, i32 -3
  store i64 %lnbVW, i64* %lnbVX, !tbaa !2
  %lnbVY = ptrtoint i8* @vctrzm0zi12zi0zi2zm9a8f7398_DataziVectorziMutable_uninitialised_closure to i64
  store i64 %lnbVY, i64* %R2_Var
  %lnbW1 = load i64, i64* %R1_Var
  %lnbW2 = add i64 %lnbW1, 7
  %lnbW3 = inttoptr i64 %lnbW2 to i64*
  %lnbW4 = load i64, i64* %lnbW3, !tbaa !4
  store i64 %lnbW4, i64* %lsaFz
  %lnbW7 = load i64, i64* %R1_Var
  %lnbW8 = add i64 %lnbW7, 15
  %lnbW9 = inttoptr i64 %lnbW8 to i64*
  %lnbWa = load i64, i64* %lnbW9, !tbaa !4
  store i64 %lnbWa, i64* %lsaFx
  %lnbWd = load i64, i64* %R1_Var
  %lnbWe = add i64 %lnbWd, 23
  %lnbWf = inttoptr i64 %lnbWe to i64*
  %lnbWg = load i64, i64* %lnbWf, !tbaa !4
  store i64 %lnbWg, i64* %lsaFy
  %lnbWh = load i64, i64* %lsaFy
  store i64 %lnbWh, i64* %R1_Var
  %lnbWj = load i64, i64* %lsaFy
  %lnbWi = load i64*, i64** %Sp_Var
  %lnbWk = getelementptr inbounds i64, i64* %lnbWi, i32 -2
  store i64 %lnbWj, i64* %lnbWk, !tbaa !2
  %lnbWm = load i64, i64* %lsaFz
  %lnbWl = load i64*, i64** %Sp_Var
  %lnbWn = getelementptr inbounds i64, i64* %lnbWl, i32 -1
  store i64 %lnbWm, i64* %lnbWn, !tbaa !2
  %lnbWp = load i64, i64* %lsaFx
  %lnbWo = load i64*, i64** %Sp_Var
  %lnbWq = getelementptr inbounds i64, i64* %lnbWo, i32 0
  store i64 %lnbWp, i64* %lnbWq, !tbaa !2
  %lnbWr = load i64*, i64** %Sp_Var
  %lnbWs = getelementptr inbounds i64, i64* %lnbWr, i32 -3
  %lnbWt = ptrtoint i64* %lnbWs to i64
  %lnbWu = inttoptr i64 %lnbWt to i64*
  store i64* %lnbWu, i64** %Sp_Var
  %lnbWv = bitcast i8* @stg_newArrayzh to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbWw = load i64*, i64** %Sp_Var
  %lnbWx = load i64, i64* %R1_Var
  %lnbWy = load i64, i64* %R2_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbWv( i64* %Base_Arg, i64* %lnbWw, i64* %Hp_Arg, i64 %lnbWx, i64 %lnbWy, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cbfx_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbfx_info$def to i8*)
define internal ghccc void @cbfx_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 327, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%ubmn_srt_struct* @ubmn_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbfx_info$def to i64)) to i32),i32 0)}>
{
cbfx:
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lnbWz = load i64*, i64** %Hp_Var
  %lnbWA = getelementptr inbounds i64, i64* %lnbWz, i32 5
  %lnbWB = ptrtoint i64* %lnbWA to i64
  %lnbWC = inttoptr i64 %lnbWB to i64*
  store i64* %lnbWC, i64** %Hp_Var
  %lnbWD = load i64*, i64** %Hp_Var
  %lnbWE = ptrtoint i64* %lnbWD to i64
  %lnbWF = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lnbWG = bitcast i64* %lnbWF to i64*
  %lnbWH = load i64, i64* %lnbWG, !tbaa !5
  %lnbWI = icmp ugt i64 %lnbWE, %lnbWH
  %lnbWJ = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnbWI, i1 0 )
  br i1 %lnbWJ, label %cbi6, label %cbi5
cbi5:
  %lnbWL = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saFD_info$def to i64
  %lnbWK = load i64*, i64** %Hp_Var
  %lnbWM = getelementptr inbounds i64, i64* %lnbWK, i32 -4
  store i64 %lnbWL, i64* %lnbWM, !tbaa !3
  %lnbWO = load i64*, i64** %Sp_Var
  %lnbWP = getelementptr inbounds i64, i64* %lnbWO, i32 5
  %lnbWQ = bitcast i64* %lnbWP to i64*
  %lnbWR = load i64, i64* %lnbWQ, !tbaa !2
  %lnbWN = load i64*, i64** %Hp_Var
  %lnbWS = getelementptr inbounds i64, i64* %lnbWN, i32 -2
  store i64 %lnbWR, i64* %lnbWS, !tbaa !3
  %lnbWU = load i64*, i64** %Sp_Var
  %lnbWV = getelementptr inbounds i64, i64* %lnbWU, i32 6
  %lnbWW = bitcast i64* %lnbWV to i64*
  %lnbWX = load i64, i64* %lnbWW, !tbaa !2
  %lnbWT = load i64*, i64** %Hp_Var
  %lnbWY = getelementptr inbounds i64, i64* %lnbWT, i32 -1
  store i64 %lnbWX, i64* %lnbWY, !tbaa !3
  %lnbX0 = load i64*, i64** %Sp_Var
  %lnbX1 = getelementptr inbounds i64, i64* %lnbX0, i32 7
  %lnbX2 = bitcast i64* %lnbX1 to i64*
  %lnbX3 = load i64, i64* %lnbX2, !tbaa !2
  %lnbWZ = load i64*, i64** %Hp_Var
  %lnbX4 = getelementptr inbounds i64, i64* %lnbWZ, i32 0
  store i64 %lnbX3, i64* %lnbX4, !tbaa !3
  %lnbX5 = load i64*, i64** %Sp_Var
  %lnbX6 = getelementptr inbounds i64, i64* %lnbX5, i32 -1
  store i64 0, i64* %lnbX6, !tbaa !2
  %lnbX7 = load i64*, i64** %Sp_Var
  %lnbX8 = getelementptr inbounds i64, i64* %lnbX7, i32 0
  store i64 0, i64* %lnbX8, !tbaa !2
  %lnbXa = load i64, i64* %R1_Var
  %lnbX9 = load i64*, i64** %Sp_Var
  %lnbXb = getelementptr inbounds i64, i64* %lnbX9, i32 5
  store i64 %lnbXa, i64* %lnbXb, !tbaa !2
  %lnbXd = load i64*, i64** %Hp_Var
  %lnbXe = getelementptr inbounds i64, i64* %lnbXd, i32 -4
  %lnbXf = ptrtoint i64* %lnbXe to i64
  %lnbXc = load i64*, i64** %Sp_Var
  %lnbXg = getelementptr inbounds i64, i64* %lnbXc, i32 6
  store i64 %lnbXf, i64* %lnbXg, !tbaa !2
  %lnbXh = load i64*, i64** %Sp_Var
  %lnbXi = getelementptr inbounds i64, i64* %lnbXh, i32 -2
  %lnbXj = ptrtoint i64* %lnbXi to i64
  %lnbXk = inttoptr i64 %lnbXj to i64*
  store i64* %lnbXk, i64** %Sp_Var
  %lnbXl = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbhq_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbXm = load i64*, i64** %Sp_Var
  %lnbXn = load i64*, i64** %Hp_Var
  %lnbXo = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbXl( i64* %Base_Arg, i64* %lnbXm, i64* %lnbXn, i64 %lnbXo, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cbi6:
  %lnbXp = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 40, i64* %lnbXp, !tbaa !5
  %lnbXq = load i64, i64* %R1_Var
  store i64 %lnbXq, i64* %R1_Var
  %lnbXr = bitcast i8* @stg_gc_unpt_r1 to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbXs = load i64*, i64** %Sp_Var
  %lnbXt = load i64*, i64** %Hp_Var
  %lnbXu = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbXr( i64* %Base_Arg, i64* %lnbXs, i64* %lnbXt, i64 %lnbXu, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cbhq_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbhq_info$def to i8*)
define internal ghccc void @cbhq_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 1481, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%ubmm_srt_struct* @ubmm_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbhq_info$def to i64)) to i32),i32 0)}>
{
cbhq:
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %lsaGp = alloca i64, i32 1
  %lsaGq = alloca i64, i32 1
  %lsaFC = alloca i64, i32 1
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R5_Var = alloca i64, i32 1
  store i64 undef, i64* %R5_Var
  %R6_Var = alloca i64, i32 1
  store i64 undef, i64* %R6_Var
  %F1_Var = alloca float, i32 1
  store float undef, float* %F1_Var
  %D1_Var = alloca double, i32 1
  store double undef, double* %D1_Var
  %F2_Var = alloca float, i32 1
  store float undef, float* %F2_Var
  %D2_Var = alloca double, i32 1
  store double undef, double* %D2_Var
  %F3_Var = alloca float, i32 1
  store float undef, float* %F3_Var
  %D3_Var = alloca double, i32 1
  store double undef, double* %D3_Var
  %F4_Var = alloca float, i32 1
  store float undef, float* %F4_Var
  %D4_Var = alloca double, i32 1
  store double undef, double* %D4_Var
  %F5_Var = alloca float, i32 1
  store float undef, float* %F5_Var
  %D5_Var = alloca double, i32 1
  store double undef, double* %D5_Var
  %F6_Var = alloca float, i32 1
  store float undef, float* %F6_Var
  %D6_Var = alloca double, i32 1
  store double undef, double* %D6_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnbXv = load i64*, i64** %Hp_Var
  %lnbXw = getelementptr inbounds i64, i64* %lnbXv, i32 4
  %lnbXx = ptrtoint i64* %lnbXw to i64
  %lnbXy = inttoptr i64 %lnbXx to i64*
  store i64* %lnbXy, i64** %Hp_Var
  %lnbXz = load i64*, i64** %Hp_Var
  %lnbXA = ptrtoint i64* %lnbXz to i64
  %lnbXB = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lnbXC = bitcast i64* %lnbXB to i64*
  %lnbXD = load i64, i64* %lnbXC, !tbaa !5
  %lnbXE = icmp ugt i64 %lnbXA, %lnbXD
  %lnbXF = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnbXE, i1 0 )
  br i1 %lnbXF, label %cbif, label %cbie
cbie:
  %lnbXG = load i64*, i64** %Sp_Var
  %lnbXH = getelementptr inbounds i64, i64* %lnbXG, i32 2
  %lnbXI = bitcast i64* %lnbXH to i64*
  %lnbXJ = load i64, i64* %lnbXI, !tbaa !2
  store i64 %lnbXJ, i64* %lsaGp
  %lnbXK = load i64*, i64** %Sp_Var
  %lnbXL = getelementptr inbounds i64, i64* %lnbXK, i32 1
  %lnbXM = bitcast i64* %lnbXL to i64*
  %lnbXN = load i64, i64* %lnbXM, !tbaa !2
  store i64 %lnbXN, i64* %lsaGq
  %lnbXO = load i64, i64* %lsaGp
  %lnbXP = load i64*, i64** %Sp_Var
  %lnbXQ = getelementptr inbounds i64, i64* %lnbXP, i32 3
  %lnbXR = bitcast i64* %lnbXQ to i64*
  %lnbXS = load i64, i64* %lnbXR, !tbaa !2
  %lnbXT = icmp sge i64 %lnbXO, %lnbXS
  %lnbXU = zext i1 %lnbXT to i64
  switch i64 %lnbXU, label %cbih [i64 1, label %cbii]
cbih:
  %lnbXW = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saGA_info$def to i64
  %lnbXV = load i64*, i64** %Hp_Var
  %lnbXX = getelementptr inbounds i64, i64* %lnbXV, i32 -3
  store i64 %lnbXW, i64* %lnbXX, !tbaa !3
  %lnbXZ = load i64*, i64** %Sp_Var
  %lnbY0 = getelementptr inbounds i64, i64* %lnbXZ, i32 8
  %lnbY1 = bitcast i64* %lnbY0 to i64*
  %lnbY2 = load i64, i64* %lnbY1, !tbaa !2
  %lnbXY = load i64*, i64** %Hp_Var
  %lnbY3 = getelementptr inbounds i64, i64* %lnbXY, i32 -1
  store i64 %lnbY2, i64* %lnbY3, !tbaa !3
  %lnbY5 = load i64*, i64** %Sp_Var
  %lnbY6 = getelementptr inbounds i64, i64* %lnbY5, i32 4
  %lnbY7 = bitcast i64* %lnbY6 to i64*
  %lnbY8 = load i64, i64* %lnbY7, !tbaa !2
  %lnbY9 = load i64*, i64** %Sp_Var
  %lnbYa = getelementptr inbounds i64, i64* %lnbY9, i32 5
  %lnbYb = bitcast i64* %lnbYa to i64*
  %lnbYc = load i64, i64* %lnbYb, !tbaa !2
  %lnbYd = load i64, i64* %lsaGp
  %lnbYe = add i64 %lnbYc, %lnbYd
  %lnbYf = shl i64 %lnbYe, 3
  %lnbYg = add i64 %lnbYf, 24
  %lnbYh = add i64 %lnbY8, %lnbYg
  %lnbYi = inttoptr i64 %lnbYh to i64*
  %lnbYj = load i64, i64* %lnbYi, !tbaa !1
  %lnbY4 = load i64*, i64** %Hp_Var
  %lnbYk = getelementptr inbounds i64, i64* %lnbY4, i32 0
  store i64 %lnbYj, i64* %lnbYk, !tbaa !3
  %lnbYl = load i64*, i64** %Sp_Var
  %lnbYm = getelementptr inbounds i64, i64* %lnbYl, i32 7
  %lnbYn = bitcast i64* %lnbYm to i64*
  %lnbYo = load i64, i64* %lnbYn, !tbaa !2
  store i64 %lnbYo, i64* %lsaFC
  %lnbYp = load i64, i64* %lsaFC
  %lnbYq = add i64 %lnbYp, 24
  %lnbYr = load i64, i64* %lsaGq
  %lnbYs = shl i64 %lnbYr, 3
  %lnbYt = add i64 %lnbYq, %lnbYs
  %lnbYu = load i64*, i64** %Hp_Var
  %lnbYv = getelementptr inbounds i64, i64* %lnbYu, i32 -3
  %lnbYw = ptrtoint i64* %lnbYv to i64
  %lnbYx = inttoptr i64 %lnbYt to i64*
  store i64 %lnbYw, i64* %lnbYx, !tbaa !1
  %lnbYy = load i64, i64* %lsaFC
  %lnbYz = ptrtoint i8* @stg_MUT_ARR_PTRS_DIRTY_info to i64
  %lnbYA = inttoptr i64 %lnbYy to i64*
  store i64 %lnbYz, i64* %lnbYA, !tbaa !1
  %lnbYB = load i64, i64* %lsaFC
  %lnbYC = add i64 %lnbYB, 24
  %lnbYD = load i64, i64* %lsaFC
  %lnbYE = add i64 %lnbYD, 8
  %lnbYF = inttoptr i64 %lnbYE to i64*
  %lnbYG = load i64, i64* %lnbYF, !tbaa !1
  %lnbYH = shl i64 %lnbYG, 3
  %lnbYI = load i64, i64* %lsaGq
  %lnbYJ = lshr i64 %lnbYI, 7
  %lnbYK = add i64 %lnbYH, %lnbYJ
  %lnbYL = add i64 %lnbYC, %lnbYK
  %lnbYM = inttoptr i64 %lnbYL to i8*
  store i8 1, i8* %lnbYM, !tbaa !1
  %lnbYO = load i64, i64* %lsaGp
  %lnbYP = add i64 %lnbYO, 1
  %lnbYN = load i64*, i64** %Sp_Var
  %lnbYQ = getelementptr inbounds i64, i64* %lnbYN, i32 2
  store i64 %lnbYP, i64* %lnbYQ, !tbaa !2
  %lnbYS = load i64, i64* %lsaGq
  %lnbYT = add i64 %lnbYS, 1
  %lnbYR = load i64*, i64** %Sp_Var
  %lnbYU = getelementptr inbounds i64, i64* %lnbYR, i32 1
  store i64 %lnbYT, i64* %lnbYU, !tbaa !2
  %lnbYV = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbhq_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbYW = load i64*, i64** %Sp_Var
  %lnbYX = load i64*, i64** %Hp_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbYV( i64* %Base_Arg, i64* %lnbYW, i64* %lnbYX, i64 %R1_Arg, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cbii:
  %lnbYY = load i64*, i64** %Hp_Var
  %lnbYZ = getelementptr inbounds i64, i64* %lnbYY, i32 -4
  %lnbZ0 = ptrtoint i64* %lnbYZ to i64
  %lnbZ1 = inttoptr i64 %lnbZ0 to i64*
  store i64* %lnbZ1, i64** %Hp_Var
  %lnbZ3 = load i64, i64* %lsaGq
  %lnbZ2 = load i64*, i64** %Sp_Var
  %lnbZ4 = getelementptr inbounds i64, i64* %lnbZ2, i32 8
  store i64 %lnbZ3, i64* %lnbZ4, !tbaa !2
  %lnbZ5 = load i64*, i64** %Sp_Var
  %lnbZ6 = getelementptr inbounds i64, i64* %lnbZ5, i32 6
  %lnbZ7 = ptrtoint i64* %lnbZ6 to i64
  %lnbZ8 = inttoptr i64 %lnbZ7 to i64*
  store i64* %lnbZ8, i64** %Sp_Var
  %lnbZ9 = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @_cbi8$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbZa = load i64*, i64** %Sp_Var
  %lnbZb = load i64*, i64** %Hp_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbZ9( i64* %Base_Arg, i64* %lnbZa, i64* %lnbZb, i64 %R1_Arg, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cbif:
  %lnbZc = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 32, i64* %lnbZc, !tbaa !5
  %lnbZe = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbhq_info$def to i64
  %lnbZd = load i64*, i64** %Sp_Var
  %lnbZf = getelementptr inbounds i64, i64* %lnbZd, i32 0
  store i64 %lnbZe, i64* %lnbZf, !tbaa !2
  %lnbZg = bitcast i8* @stg_gc_noregs to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnbZh = load i64*, i64** %Sp_Var
  %lnbZi = load i64*, i64** %Hp_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnbZg( i64* %Base_Arg, i64* %lnbZh, i64* %lnbZi, i64 %R1_Arg, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@_cbi8 = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @_cbi8$def to i8*)
define internal ghccc void @_cbi8$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind
{
cbi8:
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %lsaGi = alloca i64, i32 1
  %lsaFC = alloca i64, i32 1
  %R6_Var = alloca i64, i32 1
  store i64 undef, i64* %R6_Var
  %R5_Var = alloca i64, i32 1
  store i64 undef, i64* %R5_Var
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lnbZj = load i64*, i64** %Hp_Var
  %lnbZk = getelementptr inbounds i64, i64* %lnbZj, i32 4
  %lnbZl = ptrtoint i64* %lnbZk to i64
  %lnbZm = inttoptr i64 %lnbZl to i64*
  store i64* %lnbZm, i64** %Hp_Var
  %lnbZn = load i64*, i64** %Sp_Var
  %lnbZo = getelementptr inbounds i64, i64* %lnbZn, i32 2
  %lnbZp = bitcast i64* %lnbZo to i64*
  %lnbZq = load i64, i64* %lnbZp, !tbaa !2
  store i64 %lnbZq, i64* %lsaGi
  %lnbZr = load i64*, i64** %Hp_Var
  %lnbZs = ptrtoint i64* %lnbZr to i64
  %lnbZt = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lnbZu = bitcast i64* %lnbZt to i64*
  %lnbZv = load i64, i64* %lnbZu, !tbaa !5
  %lnbZw = icmp ugt i64 %lnbZs, %lnbZv
  %lnbZx = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnbZw, i1 0 )
  br i1 %lnbZx, label %cbic, label %cbib
cbib:
  %lnbZy = load i64*, i64** %Sp_Var
  %lnbZz = getelementptr inbounds i64, i64* %lnbZy, i32 1
  %lnbZA = bitcast i64* %lnbZz to i64*
  %lnbZB = load i64, i64* %lnbZA, !tbaa !2
  store i64 %lnbZB, i64* %lsaFC
  %lnbZC = load i64, i64* %lsaFC
  %lnbZD = ptrtoint i8* @stg_MUT_ARR_PTRS_FROZEN_DIRTY_info to i64
  %lnbZE = inttoptr i64 %lnbZC to i64*
  store i64 %lnbZD, i64* %lnbZE, !tbaa !1
  %lnbZG = ptrtoint i8* @vctrzm0zi12zi0zi2zm9a8f7398_DataziVector_Vector_con_info to i64
  %lnbZF = load i64*, i64** %Hp_Var
  %lnbZH = getelementptr inbounds i64, i64* %lnbZF, i32 -3
  store i64 %lnbZG, i64* %lnbZH, !tbaa !3
  %lnbZJ = load i64, i64* %lsaFC
  %lnbZI = load i64*, i64** %Hp_Var
  %lnbZK = getelementptr inbounds i64, i64* %lnbZI, i32 -2
  store i64 %lnbZJ, i64* %lnbZK, !tbaa !3
  %lnbZL = load i64*, i64** %Hp_Var
  %lnbZM = getelementptr inbounds i64, i64* %lnbZL, i32 -1
  store i64 0, i64* %lnbZM, !tbaa !3
  %lnbZO = load i64, i64* %lsaGi
  %lnbZN = load i64*, i64** %Hp_Var
  %lnbZP = getelementptr inbounds i64, i64* %lnbZN, i32 0
  store i64 %lnbZO, i64* %lnbZP, !tbaa !3
  %lnbZQ = load i64*, i64** %Sp_Var
  %lnbZR = getelementptr inbounds i64, i64* %lnbZQ, i32 0
  %lnbZS = bitcast i64* %lnbZR to i64*
  %lnbZT = load i64, i64* %lnbZS, !tbaa !2
  store i64 %lnbZT, i64* %R6_Var
  %lnbZV = load i64*, i64** %Hp_Var
  %lnbZW = ptrtoint i64* %lnbZV to i64
  %lnbZX = add i64 %lnbZW, -23
  store i64 %lnbZX, i64* %R5_Var
  %lnbZY = load i64*, i64** %Sp_Var
  %lnbZZ = getelementptr inbounds i64, i64* %lnbZY, i32 3
  %lnc00 = bitcast i64* %lnbZZ to i64*
  %lnc01 = load i64, i64* %lnc00, !tbaa !2
  store i64 %lnc01, i64* %R4_Var
  %lnc02 = ptrtoint %raBO_closure_struct* @raBO_closure$def to i64
  %lnc03 = add i64 %lnc02, 1
  store i64 %lnc03, i64* %R3_Var
  %lnc04 = ptrtoint i8* @base_GHCziFloat_zdfNumDouble_closure to i64
  store i64 %lnc04, i64* %R2_Var
  %lnc05 = load i64*, i64** %Sp_Var
  %lnc06 = getelementptr inbounds i64, i64* %lnc05, i32 4
  %lnc07 = ptrtoint i64* %lnc06 to i64
  %lnc08 = inttoptr i64 %lnc07 to i64*
  store i64* %lnc08, i64** %Sp_Var
  %lnc09 = bitcast i8* @hblaszm0zi0zi0zi0zminplace_HBLASziLevel1_axpyzq_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnc0a = load i64*, i64** %Sp_Var
  %lnc0b = load i64*, i64** %Hp_Var
  %lnc0c = load i64, i64* %R1_Var
  %lnc0d = load i64, i64* %R2_Var
  %lnc0e = load i64, i64* %R3_Var
  %lnc0f = load i64, i64* %R4_Var
  %lnc0g = load i64, i64* %R5_Var
  %lnc0h = load i64, i64* %R6_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnc09( i64* %Base_Arg, i64* %lnc0a, i64* %lnc0b, i64 %lnc0c, i64 %lnc0d, i64 %lnc0e, i64 %lnc0f, i64 %lnc0g, i64 %lnc0h, i64 %SpLim_Arg ) nounwind
  ret void
cbic:
  %lnc0i = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 32, i64* %lnc0i, !tbaa !5
  %lnc0k = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbi7_info$def to i64
  %lnc0j = load i64*, i64** %Sp_Var
  %lnc0l = getelementptr inbounds i64, i64* %lnc0j, i32 -1
  store i64 %lnc0k, i64* %lnc0l, !tbaa !2
  %lnc0m = load i64, i64* %lsaGi
  store i64 %lnc0m, i64* %R1_Var
  %lnc0n = load i64*, i64** %Sp_Var
  %lnc0o = getelementptr inbounds i64, i64* %lnc0n, i32 -1
  %lnc0p = ptrtoint i64* %lnc0o to i64
  %lnc0q = inttoptr i64 %lnc0p to i64*
  store i64* %lnc0q, i64** %Sp_Var
  %lnc0r = bitcast i8* @stg_gc_unbx_r1 to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnc0s = load i64*, i64** %Sp_Var
  %lnc0t = load i64*, i64** %Hp_Var
  %lnc0u = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnc0r( i64* %Base_Arg, i64* %lnc0s, i64* %lnc0t, i64 %lnc0u, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cbi7_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbi7_info$def to i8*)
define internal ghccc void @cbi7_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 260, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%ubmj_srt_struct* @ubmj_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbi7_info$def to i64)) to i32),i32 0)}>
{
cbi7:
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnc0v = load i64*, i64** %Sp_Var
  %lnc0w = getelementptr inbounds i64, i64* %lnc0v, i32 3
  store i64 %R1_Arg, i64* %lnc0w, !tbaa !2
  %lnc0x = load i64*, i64** %Sp_Var
  %lnc0y = getelementptr inbounds i64, i64* %lnc0x, i32 1
  %lnc0z = ptrtoint i64* %lnc0y to i64
  %lnc0A = inttoptr i64 %lnc0z to i64*
  store i64* %lnc0A, i64** %Sp_Var
  %lnc0B = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @_cbi8$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnc0C = load i64*, i64** %Sp_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnc0B( i64* %Base_Arg, i64* %lnc0C, i64* %Hp_Arg, i64 %R1_Arg, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saGH_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saGH_info$def to i8*)
define internal ghccc void @saGH_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 2, i32 18, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%ubml_srt_struct* @ubml_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saGH_info$def to i64)) to i32),i32 0)}>
{
cbiG:
  %lsaFv = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnc0D = load i64*, i64** %Sp_Var
  %lnc0E = getelementptr inbounds i64, i64* %lnc0D, i32 -4
  %lnc0F = ptrtoint i64* %lnc0E to i64
  %lnc0G = icmp ult i64 %lnc0F, %SpLim_Arg
  %lnc0H = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnc0G, i1 0 )
  br i1 %lnc0H, label %cbiH, label %cbiI
cbiI:
  %lnc0J = ptrtoint i8* @stg_upd_frame_info to i64
  %lnc0I = load i64*, i64** %Sp_Var
  %lnc0K = getelementptr inbounds i64, i64* %lnc0I, i32 -2
  store i64 %lnc0J, i64* %lnc0K, !tbaa !2
  %lnc0M = load i64, i64* %R1_Var
  %lnc0L = load i64*, i64** %Sp_Var
  %lnc0N = getelementptr inbounds i64, i64* %lnc0L, i32 -1
  store i64 %lnc0M, i64* %lnc0N, !tbaa !2
  %lnc0P = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbiD_info$def to i64
  %lnc0O = load i64*, i64** %Sp_Var
  %lnc0Q = getelementptr inbounds i64, i64* %lnc0O, i32 -4
  store i64 %lnc0P, i64* %lnc0Q, !tbaa !2
  %lnc0T = load i64, i64* %R1_Var
  %lnc0U = add i64 %lnc0T, 24
  %lnc0V = inttoptr i64 %lnc0U to i64*
  %lnc0W = load i64, i64* %lnc0V, !tbaa !4
  store i64 %lnc0W, i64* %lsaFv
  %lnc0Z = load i64, i64* %R1_Var
  %lnc10 = add i64 %lnc0Z, 16
  %lnc11 = inttoptr i64 %lnc10 to i64*
  %lnc12 = load i64, i64* %lnc11, !tbaa !4
  store i64 %lnc12, i64* %R1_Var
  %lnc14 = load i64, i64* %lsaFv
  %lnc13 = load i64*, i64** %Sp_Var
  %lnc15 = getelementptr inbounds i64, i64* %lnc13, i32 -3
  store i64 %lnc14, i64* %lnc15, !tbaa !2
  %lnc16 = load i64*, i64** %Sp_Var
  %lnc17 = getelementptr inbounds i64, i64* %lnc16, i32 -4
  %lnc18 = ptrtoint i64* %lnc17 to i64
  %lnc19 = inttoptr i64 %lnc18 to i64*
  store i64* %lnc19, i64** %Sp_Var
  %lnc1a = load i64, i64* %R1_Var
  %lnc1b = and i64 %lnc1a, 7
  %lnc1c = icmp ne i64 %lnc1b, 0
  br i1 %lnc1c, label %ubiM, label %cbiE
cbiE:
  %lnc1e = load i64, i64* %R1_Var
  %lnc1f = inttoptr i64 %lnc1e to i64*
  %lnc1g = load i64, i64* %lnc1f, !tbaa !4
  %lnc1h = inttoptr i64 %lnc1g to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnc1i = load i64*, i64** %Sp_Var
  %lnc1j = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnc1h( i64* %Base_Arg, i64* %lnc1i, i64* %Hp_Arg, i64 %lnc1j, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ubiM:
  %lnc1k = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbiD_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnc1l = load i64*, i64** %Sp_Var
  %lnc1m = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnc1k( i64* %Base_Arg, i64* %lnc1l, i64* %Hp_Arg, i64 %lnc1m, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cbiH:
  %lnc1n = load i64, i64* %R1_Var
  store i64 %lnc1n, i64* %R1_Var
  %lnc1o = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lnc1p = bitcast i64* %lnc1o to i64*
  %lnc1q = load i64, i64* %lnc1p, !tbaa !5
  %lnc1r = inttoptr i64 %lnc1q to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnc1s = load i64*, i64** %Sp_Var
  %lnc1t = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnc1r( i64* %Base_Arg, i64* %lnc1s, i64* %Hp_Arg, i64 %lnc1t, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cbiD_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbiD_info$def to i8*)
define internal ghccc void @cbiD_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 1, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%ubmk_srt_struct* @ubmk_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbiD_info$def to i64)) to i32),i32 0)}>
{
cbiD:
  %R6_Var = alloca i64, i32 1
  store i64 undef, i64* %R6_Var
  %R5_Var = alloca i64, i32 1
  store i64 undef, i64* %R5_Var
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnc1u = load i64*, i64** %Sp_Var
  %lnc1v = getelementptr inbounds i64, i64* %lnc1u, i32 1
  %lnc1w = bitcast i64* %lnc1v to i64*
  %lnc1x = load i64, i64* %lnc1w, !tbaa !2
  store i64 %lnc1x, i64* %R6_Var
  %lnc1y = add i64 %R1_Arg, 7
  %lnc1z = inttoptr i64 %lnc1y to i64*
  %lnc1A = load i64, i64* %lnc1z, !tbaa !4
  store i64 %lnc1A, i64* %R5_Var
  %lnc1B = add i64 %R1_Arg, 23
  %lnc1C = inttoptr i64 %lnc1B to i64*
  %lnc1D = load i64, i64* %lnc1C, !tbaa !4
  store i64 %lnc1D, i64* %R4_Var
  %lnc1E = add i64 %R1_Arg, 15
  %lnc1F = inttoptr i64 %lnc1E to i64*
  %lnc1G = load i64, i64* %lnc1F, !tbaa !4
  store i64 %lnc1G, i64* %R3_Var
  %lnc1H = ptrtoint i8* @base_GHCziFloat_zdfNumDouble_closure to i64
  store i64 %lnc1H, i64* %R2_Var
  %lnc1I = load i64*, i64** %Sp_Var
  %lnc1J = getelementptr inbounds i64, i64* %lnc1I, i32 2
  %lnc1K = ptrtoint i64* %lnc1J to i64
  %lnc1L = inttoptr i64 %lnc1K to i64*
  store i64* %lnc1L, i64** %Sp_Var
  %lnc1M = bitcast i8* @hblaszm0zi0zi0zi0zminplace_HBLASziLevel2_zdwgemvzq_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnc1N = load i64*, i64** %Sp_Var
  %lnc1O = load i64, i64* %R2_Var
  %lnc1P = load i64, i64* %R3_Var
  %lnc1Q = load i64, i64* %R4_Var
  %lnc1R = load i64, i64* %R5_Var
  %lnc1S = load i64, i64* %R6_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnc1M( i64* %Base_Arg, i64* %lnc1N, i64* %Hp_Arg, i64 %R1_Arg, i64 %lnc1O, i64 %lnc1P, i64 %lnc1Q, i64 %lnc1R, i64 %lnc1S, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saGM_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saGM_info$def to i8*)
define internal ghccc void @saGM_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 2, i32 18, i32 0}>
{
cbiS:
  %lsaGH = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnc1T = load i64*, i64** %Sp_Var
  %lnc1U = getelementptr inbounds i64, i64* %lnc1T, i32 -13
  %lnc1V = ptrtoint i64* %lnc1U to i64
  %lnc1W = icmp ult i64 %lnc1V, %SpLim_Arg
  %lnc1X = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnc1W, i1 0 )
  br i1 %lnc1X, label %cbiW, label %cbiX
cbiX:
  %lnc1Z = ptrtoint i8* @stg_upd_frame_info to i64
  %lnc1Y = load i64*, i64** %Sp_Var
  %lnc20 = getelementptr inbounds i64, i64* %lnc1Y, i32 -2
  store i64 %lnc1Z, i64* %lnc20, !tbaa !2
  %lnc22 = load i64, i64* %R1_Var
  %lnc21 = load i64*, i64** %Sp_Var
  %lnc23 = getelementptr inbounds i64, i64* %lnc21, i32 -1
  store i64 %lnc22, i64* %lnc23, !tbaa !2
  %lnc25 = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbiP_info$def to i64
  %lnc24 = load i64*, i64** %Sp_Var
  %lnc26 = getelementptr inbounds i64, i64* %lnc24, i32 -4
  store i64 %lnc25, i64* %lnc26, !tbaa !2
  %lnc29 = load i64, i64* %R1_Var
  %lnc2a = add i64 %lnc29, 24
  %lnc2b = inttoptr i64 %lnc2a to i64*
  %lnc2c = load i64, i64* %lnc2b, !tbaa !4
  store i64 %lnc2c, i64* %lsaGH
  %lnc2f = load i64, i64* %R1_Var
  %lnc2g = add i64 %lnc2f, 16
  %lnc2h = inttoptr i64 %lnc2g to i64*
  %lnc2i = load i64, i64* %lnc2h, !tbaa !4
  store i64 %lnc2i, i64* %R1_Var
  %lnc2k = load i64, i64* %lsaGH
  %lnc2j = load i64*, i64** %Sp_Var
  %lnc2l = getelementptr inbounds i64, i64* %lnc2j, i32 -3
  store i64 %lnc2k, i64* %lnc2l, !tbaa !2
  %lnc2m = load i64*, i64** %Sp_Var
  %lnc2n = getelementptr inbounds i64, i64* %lnc2m, i32 -4
  %lnc2o = ptrtoint i64* %lnc2n to i64
  %lnc2p = inttoptr i64 %lnc2o to i64*
  store i64* %lnc2p, i64** %Sp_Var
  %lnc2q = load i64, i64* %R1_Var
  %lnc2r = and i64 %lnc2q, 7
  %lnc2s = icmp ne i64 %lnc2r, 0
  br i1 %lnc2s, label %ubjX, label %cbiQ
cbiQ:
  %lnc2u = load i64, i64* %R1_Var
  %lnc2v = inttoptr i64 %lnc2u to i64*
  %lnc2w = load i64, i64* %lnc2v, !tbaa !4
  %lnc2x = inttoptr i64 %lnc2w to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnc2y = load i64*, i64** %Sp_Var
  %lnc2z = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnc2x( i64* %Base_Arg, i64* %lnc2y, i64* %Hp_Arg, i64 %lnc2z, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ubjX:
  %lnc2A = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbiP_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnc2B = load i64*, i64** %Sp_Var
  %lnc2C = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnc2A( i64* %Base_Arg, i64* %lnc2B, i64* %Hp_Arg, i64 %lnc2C, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cbiW:
  %lnc2D = load i64, i64* %R1_Var
  store i64 %lnc2D, i64* %R1_Var
  %lnc2E = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lnc2F = bitcast i64* %lnc2E to i64*
  %lnc2G = load i64, i64* %lnc2F, !tbaa !5
  %lnc2H = inttoptr i64 %lnc2G to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnc2I = load i64*, i64** %Sp_Var
  %lnc2J = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnc2H( i64* %Base_Arg, i64* %lnc2I, i64* %Hp_Arg, i64 %lnc2J, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cbiP_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbiP_info$def to i8*)
define internal ghccc void @cbiP_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 1, i32 30, i32 0}>
{
cbiP:
  %lsaGQ = alloca i64, i32 1
  %lsaGO = alloca i64, i32 1
  %lsaGP = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnc2L = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbiV_info$def to i64
  %lnc2K = load i64*, i64** %Sp_Var
  %lnc2M = getelementptr inbounds i64, i64* %lnc2K, i32 -2
  store i64 %lnc2L, i64* %lnc2M, !tbaa !2
  %lnc2P = load i64, i64* %R1_Var
  %lnc2Q = add i64 %lnc2P, 7
  %lnc2R = inttoptr i64 %lnc2Q to i64*
  %lnc2S = load i64, i64* %lnc2R, !tbaa !4
  store i64 %lnc2S, i64* %lsaGQ
  %lnc2V = load i64, i64* %R1_Var
  %lnc2W = add i64 %lnc2V, 15
  %lnc2X = inttoptr i64 %lnc2W to i64*
  %lnc2Y = load i64, i64* %lnc2X, !tbaa !4
  store i64 %lnc2Y, i64* %lsaGO
  %lnc31 = load i64, i64* %R1_Var
  %lnc32 = add i64 %lnc31, 23
  %lnc33 = inttoptr i64 %lnc32 to i64*
  %lnc34 = load i64, i64* %lnc33, !tbaa !4
  store i64 %lnc34, i64* %lsaGP
  %lnc35 = load i64*, i64** %Sp_Var
  %lnc36 = getelementptr inbounds i64, i64* %lnc35, i32 1
  %lnc37 = bitcast i64* %lnc36 to i64*
  %lnc38 = load i64, i64* %lnc37, !tbaa !2
  store i64 %lnc38, i64* %R1_Var
  %lnc3a = load i64, i64* %lsaGQ
  %lnc39 = load i64*, i64** %Sp_Var
  %lnc3b = getelementptr inbounds i64, i64* %lnc39, i32 -1
  store i64 %lnc3a, i64* %lnc3b, !tbaa !2
  %lnc3d = load i64, i64* %lsaGP
  %lnc3c = load i64*, i64** %Sp_Var
  %lnc3e = getelementptr inbounds i64, i64* %lnc3c, i32 0
  store i64 %lnc3d, i64* %lnc3e, !tbaa !2
  %lnc3g = load i64, i64* %lsaGO
  %lnc3f = load i64*, i64** %Sp_Var
  %lnc3h = getelementptr inbounds i64, i64* %lnc3f, i32 1
  store i64 %lnc3g, i64* %lnc3h, !tbaa !2
  %lnc3i = load i64*, i64** %Sp_Var
  %lnc3j = getelementptr inbounds i64, i64* %lnc3i, i32 -2
  %lnc3k = ptrtoint i64* %lnc3j to i64
  %lnc3l = inttoptr i64 %lnc3k to i64*
  store i64* %lnc3l, i64** %Sp_Var
  %lnc3m = load i64, i64* %R1_Var
  %lnc3n = and i64 %lnc3m, 7
  %lnc3o = icmp ne i64 %lnc3n, 0
  br i1 %lnc3o, label %ubjW, label %cbiZ
cbiZ:
  %lnc3q = load i64, i64* %R1_Var
  %lnc3r = inttoptr i64 %lnc3q to i64*
  %lnc3s = load i64, i64* %lnc3r, !tbaa !4
  %lnc3t = inttoptr i64 %lnc3s to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnc3u = load i64*, i64** %Sp_Var
  %lnc3v = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnc3t( i64* %Base_Arg, i64* %lnc3u, i64* %Hp_Arg, i64 %lnc3v, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ubjW:
  %lnc3w = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbiV_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnc3x = load i64*, i64** %Sp_Var
  %lnc3y = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnc3w( i64* %Base_Arg, i64* %lnc3x, i64* %Hp_Arg, i64 %lnc3y, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cbiV_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbiV_info$def to i8*)
define internal ghccc void @cbiV_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 387, i32 30, i32 0}>
{
cbiV:
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnc3A = add i64 %R1_Arg, 23
  %lnc3B = inttoptr i64 %lnc3A to i64*
  %lnc3C = load i64, i64* %lnc3B, !tbaa !4
  %lnc3z = load i64*, i64** %Sp_Var
  %lnc3D = getelementptr inbounds i64, i64* %lnc3z, i32 -5
  store i64 %lnc3C, i64* %lnc3D, !tbaa !2
  %lnc3F = add i64 %R1_Arg, 7
  %lnc3G = inttoptr i64 %lnc3F to i64*
  %lnc3H = load i64, i64* %lnc3G, !tbaa !4
  %lnc3E = load i64*, i64** %Sp_Var
  %lnc3I = getelementptr inbounds i64, i64* %lnc3E, i32 -4
  store i64 %lnc3H, i64* %lnc3I, !tbaa !2
  %lnc3J = load i64*, i64** %Sp_Var
  %lnc3K = getelementptr inbounds i64, i64* %lnc3J, i32 -3
  store i64 0, i64* %lnc3K, !tbaa !2
  %lnc3L = load i64*, i64** %Sp_Var
  %lnc3M = getelementptr inbounds i64, i64* %lnc3L, i32 -2
  store i64 0, i64* %lnc3M, !tbaa !2
  %lnc3N = load i64*, i64** %Sp_Var
  %lnc3O = getelementptr inbounds i64, i64* %lnc3N, i32 -1
  %lnc3P = bitcast i64* %lnc3O to double*
  store double 0x0000000000000000, double* %lnc3P, !tbaa !2
  %lnc3R = add i64 %R1_Arg, 15
  %lnc3S = inttoptr i64 %lnc3R to i64*
  %lnc3T = load i64, i64* %lnc3S, !tbaa !4
  %lnc3Q = load i64*, i64** %Sp_Var
  %lnc3U = getelementptr inbounds i64, i64* %lnc3Q, i32 0
  store i64 %lnc3T, i64* %lnc3U, !tbaa !2
  %lnc3V = load i64*, i64** %Sp_Var
  %lnc3W = getelementptr inbounds i64, i64* %lnc3V, i32 -6
  %lnc3X = ptrtoint i64* %lnc3W to i64
  %lnc3Y = inttoptr i64 %lnc3X to i64*
  store i64* %lnc3Y, i64** %Sp_Var
  %lnc3Z = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbj6_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnc40 = load i64*, i64** %Sp_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnc3Z( i64* %Base_Arg, i64* %lnc40, i64* %Hp_Arg, i64 %R1_Arg, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cbj6_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbj6_info$def to i8*)
define internal ghccc void @cbj6_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 28489, i32 30, i32 0}>
{
cbj6:
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %lsaGX = alloca i64, i32 1
  %lsaGY = alloca double, i32 1
  %lsaGW = alloca i64, i32 1
  %lsaH2 = alloca i64, i32 1
  %lsaH6 = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnc41 = load i64*, i64** %Hp_Var
  %lnc42 = getelementptr inbounds i64, i64* %lnc41, i32 2
  %lnc43 = ptrtoint i64* %lnc42 to i64
  %lnc44 = inttoptr i64 %lnc43 to i64*
  store i64* %lnc44, i64** %Hp_Var
  %lnc45 = load i64*, i64** %Hp_Var
  %lnc46 = ptrtoint i64* %lnc45 to i64
  %lnc47 = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lnc48 = bitcast i64* %lnc47 to i64*
  %lnc49 = load i64, i64* %lnc48, !tbaa !5
  %lnc4a = icmp ugt i64 %lnc46, %lnc49
  %lnc4b = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnc4a, i1 0 )
  br i1 %lnc4b, label %cbjb, label %cbja
cbja:
  %lnc4c = load i64*, i64** %Sp_Var
  %lnc4d = getelementptr inbounds i64, i64* %lnc4c, i32 4
  %lnc4e = bitcast i64* %lnc4d to i64*
  %lnc4f = load i64, i64* %lnc4e, !tbaa !2
  store i64 %lnc4f, i64* %lsaGX
  %lnc4g = load i64*, i64** %Sp_Var
  %lnc4h = getelementptr inbounds i64, i64* %lnc4g, i32 5
  %lnc4i = bitcast i64* %lnc4h to double*
  %lnc4j = load double, double* %lnc4i, !tbaa !2
  store double %lnc4j, double* %lsaGY
  %lnc4k = load i64, i64* %lsaGX
  %lnc4l = load i64*, i64** %Sp_Var
  %lnc4m = getelementptr inbounds i64, i64* %lnc4l, i32 8
  %lnc4n = bitcast i64* %lnc4m to i64*
  %lnc4o = load i64, i64* %lnc4n, !tbaa !2
  %lnc4p = icmp sge i64 %lnc4k, %lnc4o
  %lnc4q = zext i1 %lnc4p to i64
  switch i64 %lnc4q, label %cbjG [i64 1, label %cbjJ]
cbjG:
  %lnc4r = load i64*, i64** %Sp_Var
  %lnc4s = getelementptr inbounds i64, i64* %lnc4r, i32 3
  %lnc4t = bitcast i64* %lnc4s to i64*
  %lnc4u = load i64, i64* %lnc4t, !tbaa !2
  store i64 %lnc4u, i64* %lsaGW
  %lnc4v = load i64, i64* %lsaGW
  %lnc4w = load i64*, i64** %Sp_Var
  %lnc4x = getelementptr inbounds i64, i64* %lnc4w, i32 1
  %lnc4y = bitcast i64* %lnc4x to i64*
  %lnc4z = load i64, i64* %lnc4y, !tbaa !2
  %lnc4A = icmp sge i64 %lnc4v, %lnc4z
  %lnc4B = zext i1 %lnc4A to i64
  switch i64 %lnc4B, label %cbjv [i64 1, label %cbjE]
cbjv:
  %lnc4C = load i64*, i64** %Hp_Var
  %lnc4D = getelementptr inbounds i64, i64* %lnc4C, i32 -2
  %lnc4E = ptrtoint i64* %lnc4D to i64
  %lnc4F = inttoptr i64 %lnc4E to i64*
  store i64* %lnc4F, i64** %Hp_Var
  %lnc4G = load i64*, i64** %Sp_Var
  %lnc4H = getelementptr inbounds i64, i64* %lnc4G, i32 7
  %lnc4I = bitcast i64* %lnc4H to i64*
  %lnc4J = load i64, i64* %lnc4I, !tbaa !2
  %lnc4K = load i64*, i64** %Sp_Var
  %lnc4L = getelementptr inbounds i64, i64* %lnc4K, i32 9
  %lnc4M = bitcast i64* %lnc4L to i64*
  %lnc4N = load i64, i64* %lnc4M, !tbaa !2
  %lnc4O = load i64, i64* %lsaGX
  %lnc4P = add i64 %lnc4N, %lnc4O
  %lnc4Q = shl i64 %lnc4P, 3
  %lnc4R = add i64 %lnc4Q, 24
  %lnc4S = add i64 %lnc4J, %lnc4R
  %lnc4T = inttoptr i64 %lnc4S to i64*
  %lnc4U = load i64, i64* %lnc4T, !tbaa !1
  store i64 %lnc4U, i64* %lsaH2
  %lnc4V = load i64*, i64** %Sp_Var
  %lnc4W = getelementptr inbounds i64, i64* %lnc4V, i32 2
  %lnc4X = bitcast i64* %lnc4W to i64*
  %lnc4Y = load i64, i64* %lnc4X, !tbaa !2
  %lnc4Z = load i64*, i64** %Sp_Var
  %lnc50 = getelementptr inbounds i64, i64* %lnc4Z, i32 6
  %lnc51 = bitcast i64* %lnc50 to i64*
  %lnc52 = load i64, i64* %lnc51, !tbaa !2
  %lnc53 = load i64, i64* %lsaGW
  %lnc54 = add i64 %lnc52, %lnc53
  %lnc55 = shl i64 %lnc54, 3
  %lnc56 = add i64 %lnc55, 24
  %lnc57 = add i64 %lnc4Y, %lnc56
  %lnc58 = inttoptr i64 %lnc57 to i64*
  %lnc59 = load i64, i64* %lnc58, !tbaa !1
  store i64 %lnc59, i64* %lsaH6
  %lnc5b = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbjo_info$def to i64
  %lnc5a = load i64*, i64** %Sp_Var
  %lnc5c = getelementptr inbounds i64, i64* %lnc5a, i32 -1
  store i64 %lnc5b, i64* %lnc5c, !tbaa !2
  %lnc5d = load i64, i64* %lsaH2
  store i64 %lnc5d, i64* %R1_Var
  %lnc5f = load i64, i64* %lsaH6
  %lnc5e = load i64*, i64** %Sp_Var
  %lnc5g = getelementptr inbounds i64, i64* %lnc5e, i32 0
  store i64 %lnc5f, i64* %lnc5g, !tbaa !2
  %lnc5h = load i64*, i64** %Sp_Var
  %lnc5i = getelementptr inbounds i64, i64* %lnc5h, i32 -1
  %lnc5j = ptrtoint i64* %lnc5i to i64
  %lnc5k = inttoptr i64 %lnc5j to i64*
  store i64* %lnc5k, i64** %Sp_Var
  %lnc5l = load i64, i64* %R1_Var
  %lnc5m = and i64 %lnc5l, 7
  %lnc5n = icmp ne i64 %lnc5m, 0
  br i1 %lnc5n, label %ubjZ, label %cbjp
cbjp:
  %lnc5p = load i64, i64* %R1_Var
  %lnc5q = inttoptr i64 %lnc5p to i64*
  %lnc5r = load i64, i64* %lnc5q, !tbaa !4
  %lnc5s = inttoptr i64 %lnc5r to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnc5t = load i64*, i64** %Sp_Var
  %lnc5u = load i64*, i64** %Hp_Var
  %lnc5v = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnc5s( i64* %Base_Arg, i64* %lnc5t, i64* %lnc5u, i64 %lnc5v, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ubjZ:
  %lnc5w = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbjo_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnc5x = load i64*, i64** %Sp_Var
  %lnc5y = load i64*, i64** %Hp_Var
  %lnc5z = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnc5w( i64* %Base_Arg, i64* %lnc5x, i64* %lnc5y, i64 %lnc5z, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cbjE:
  %lnc5B = ptrtoint i8* @ghczmprim_GHCziTypes_Dzh_con_info to i64
  %lnc5A = load i64*, i64** %Hp_Var
  %lnc5C = getelementptr inbounds i64, i64* %lnc5A, i32 -1
  store i64 %lnc5B, i64* %lnc5C, !tbaa !3
  %lnc5E = load double, double* %lsaGY
  %lnc5D = load i64*, i64** %Hp_Var
  %lnc5F = getelementptr inbounds i64, i64* %lnc5D, i32 0
  %lnc5G = bitcast i64* %lnc5F to double*
  store double %lnc5E, double* %lnc5G, !tbaa !3
  %lnc5I = load i64*, i64** %Hp_Var
  %lnc5J = ptrtoint i64* %lnc5I to i64
  %lnc5K = add i64 %lnc5J, -7
  store i64 %lnc5K, i64* %R1_Var
  %lnc5L = load i64*, i64** %Sp_Var
  %lnc5M = getelementptr inbounds i64, i64* %lnc5L, i32 10
  %lnc5N = ptrtoint i64* %lnc5M to i64
  %lnc5O = inttoptr i64 %lnc5N to i64*
  store i64* %lnc5O, i64** %Sp_Var
  %lnc5P = load i64*, i64** %Sp_Var
  %lnc5Q = getelementptr inbounds i64, i64* %lnc5P, i32 0
  %lnc5R = bitcast i64* %lnc5Q to i64*
  %lnc5S = load i64, i64* %lnc5R, !tbaa !2
  %lnc5T = inttoptr i64 %lnc5S to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnc5U = load i64*, i64** %Sp_Var
  %lnc5V = load i64*, i64** %Hp_Var
  %lnc5W = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnc5T( i64* %Base_Arg, i64* %lnc5U, i64* %lnc5V, i64 %lnc5W, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cbjJ:
  %lnc5Y = ptrtoint i8* @ghczmprim_GHCziTypes_Dzh_con_info to i64
  %lnc5X = load i64*, i64** %Hp_Var
  %lnc5Z = getelementptr inbounds i64, i64* %lnc5X, i32 -1
  store i64 %lnc5Y, i64* %lnc5Z, !tbaa !3
  %lnc61 = load double, double* %lsaGY
  %lnc60 = load i64*, i64** %Hp_Var
  %lnc62 = getelementptr inbounds i64, i64* %lnc60, i32 0
  %lnc63 = bitcast i64* %lnc62 to double*
  store double %lnc61, double* %lnc63, !tbaa !3
  %lnc65 = load i64*, i64** %Hp_Var
  %lnc66 = ptrtoint i64* %lnc65 to i64
  %lnc67 = add i64 %lnc66, -7
  store i64 %lnc67, i64* %R1_Var
  %lnc68 = load i64*, i64** %Sp_Var
  %lnc69 = getelementptr inbounds i64, i64* %lnc68, i32 10
  %lnc6a = ptrtoint i64* %lnc69 to i64
  %lnc6b = inttoptr i64 %lnc6a to i64*
  store i64* %lnc6b, i64** %Sp_Var
  %lnc6c = load i64*, i64** %Sp_Var
  %lnc6d = getelementptr inbounds i64, i64* %lnc6c, i32 0
  %lnc6e = bitcast i64* %lnc6d to i64*
  %lnc6f = load i64, i64* %lnc6e, !tbaa !2
  %lnc6g = inttoptr i64 %lnc6f to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnc6h = load i64*, i64** %Sp_Var
  %lnc6i = load i64*, i64** %Hp_Var
  %lnc6j = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnc6g( i64* %Base_Arg, i64* %lnc6h, i64* %lnc6i, i64 %lnc6j, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cbjb:
  %lnc6k = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 16, i64* %lnc6k, !tbaa !5
  %lnc6m = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbj6_info$def to i64
  %lnc6l = load i64*, i64** %Sp_Var
  %lnc6n = getelementptr inbounds i64, i64* %lnc6l, i32 0
  store i64 %lnc6m, i64* %lnc6n, !tbaa !2
  %lnc6o = bitcast i8* @stg_gc_noregs to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnc6p = load i64*, i64** %Sp_Var
  %lnc6q = load i64*, i64** %Hp_Var
  %lnc6r = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnc6o( i64* %Base_Arg, i64* %lnc6p, i64* %lnc6q, i64 %lnc6r, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cbjo_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbjo_info$def to i8*)
define internal ghccc void @cbjo_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 56970, i32 30, i32 0}>
{
cbjo:
  %lsaH8 = alloca double, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lnc6s = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbjt_info$def to i64
  %lnc6t = getelementptr inbounds i64, i64* %Sp_Arg, i32 0
  store i64 %lnc6s, i64* %lnc6t, !tbaa !2
  %lnc6w = load i64, i64* %R1_Var
  %lnc6x = add i64 %lnc6w, 7
  %lnc6y = inttoptr i64 %lnc6x to double*
  %lnc6z = load double, double* %lnc6y, !tbaa !4
  store double %lnc6z, double* %lsaH8
  %lnc6A = getelementptr inbounds i64, i64* %Sp_Arg, i32 1
  %lnc6B = bitcast i64* %lnc6A to i64*
  %lnc6C = load i64, i64* %lnc6B, !tbaa !2
  store i64 %lnc6C, i64* %R1_Var
  %lnc6D = load double, double* %lsaH8
  %lnc6E = getelementptr inbounds i64, i64* %Sp_Arg, i32 1
  %lnc6F = bitcast i64* %lnc6E to double*
  store double %lnc6D, double* %lnc6F, !tbaa !2
  %lnc6G = load i64, i64* %R1_Var
  %lnc6H = and i64 %lnc6G, 7
  %lnc6I = icmp ne i64 %lnc6H, 0
  br i1 %lnc6I, label %ubk0, label %cbjx
cbjx:
  %lnc6K = load i64, i64* %R1_Var
  %lnc6L = inttoptr i64 %lnc6K to i64*
  %lnc6M = load i64, i64* %lnc6L, !tbaa !4
  %lnc6N = inttoptr i64 %lnc6M to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnc6O = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnc6N( i64* %Base_Arg, i64* %Sp_Arg, i64* %Hp_Arg, i64 %lnc6O, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ubk0:
  %lnc6P = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbjt_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnc6Q = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnc6P( i64* %Base_Arg, i64* %Sp_Arg, i64* %Hp_Arg, i64 %lnc6Q, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cbjt_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbjt_info$def to i8*)
define internal ghccc void @cbjt_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 57034, i32 30, i32 0}>
{
cbjt:
  %lsaGY = alloca double, i32 1
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnc6R = load i64*, i64** %Sp_Var
  %lnc6S = getelementptr inbounds i64, i64* %lnc6R, i32 6
  %lnc6T = bitcast i64* %lnc6S to double*
  %lnc6U = load double, double* %lnc6T, !tbaa !2
  %lnc6V = load i64*, i64** %Sp_Var
  %lnc6W = getelementptr inbounds i64, i64* %lnc6V, i32 1
  %lnc6X = bitcast i64* %lnc6W to double*
  %lnc6Y = load double, double* %lnc6X, !tbaa !2
  %lnc6Z = add i64 %R1_Arg, 7
  %lnc70 = inttoptr i64 %lnc6Z to double*
  %lnc71 = load double, double* %lnc70, !tbaa !4
  %lnc72 = fmul double %lnc6Y, %lnc71
  %lnc73 = fadd double %lnc6U, %lnc72
  store double %lnc73, double* %lsaGY
  %lnc75 = load i64*, i64** %Sp_Var
  %lnc76 = getelementptr inbounds i64, i64* %lnc75, i32 4
  %lnc77 = bitcast i64* %lnc76 to i64*
  %lnc78 = load i64, i64* %lnc77, !tbaa !2
  %lnc79 = add i64 %lnc78, 1
  %lnc74 = load i64*, i64** %Sp_Var
  %lnc7a = getelementptr inbounds i64, i64* %lnc74, i32 4
  store i64 %lnc79, i64* %lnc7a, !tbaa !2
  %lnc7c = load i64*, i64** %Sp_Var
  %lnc7d = getelementptr inbounds i64, i64* %lnc7c, i32 5
  %lnc7e = bitcast i64* %lnc7d to i64*
  %lnc7f = load i64, i64* %lnc7e, !tbaa !2
  %lnc7g = add i64 %lnc7f, 1
  %lnc7b = load i64*, i64** %Sp_Var
  %lnc7h = getelementptr inbounds i64, i64* %lnc7b, i32 5
  store i64 %lnc7g, i64* %lnc7h, !tbaa !2
  %lnc7j = load double, double* %lsaGY
  %lnc7i = load i64*, i64** %Sp_Var
  %lnc7k = getelementptr inbounds i64, i64* %lnc7i, i32 6
  %lnc7l = bitcast i64* %lnc7k to double*
  store double %lnc7j, double* %lnc7l, !tbaa !2
  %lnc7m = load i64*, i64** %Sp_Var
  %lnc7n = getelementptr inbounds i64, i64* %lnc7m, i32 1
  %lnc7o = ptrtoint i64* %lnc7n to i64
  %lnc7p = inttoptr i64 %lnc7o to i64*
  store i64* %lnc7p, i64** %Sp_Var
  %lnc7q = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbj6_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnc7r = load i64*, i64** %Sp_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnc7q( i64* %Base_Arg, i64* %lnc7r, i64* %Hp_Arg, i64 %R1_Arg, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saHf_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saHf_info$def to i8*)
define internal ghccc void @saHf_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 3, i32 15, i32 0}>
{
cbk7:
  %lsaFv = alloca i64, i32 1
  %lsaGM = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnc7s = load i64*, i64** %Sp_Var
  %lnc7t = getelementptr inbounds i64, i64* %lnc7s, i32 -14
  %lnc7u = ptrtoint i64* %lnc7t to i64
  %lnc7v = icmp ult i64 %lnc7u, %SpLim_Arg
  %lnc7w = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnc7v, i1 0 )
  br i1 %lnc7w, label %cbkb, label %cbkc
cbkc:
  %lnc7y = ptrtoint i8* @stg_upd_frame_info to i64
  %lnc7x = load i64*, i64** %Sp_Var
  %lnc7z = getelementptr inbounds i64, i64* %lnc7x, i32 -2
  store i64 %lnc7y, i64* %lnc7z, !tbaa !2
  %lnc7B = load i64, i64* %R1_Var
  %lnc7A = load i64*, i64** %Sp_Var
  %lnc7C = getelementptr inbounds i64, i64* %lnc7A, i32 -1
  store i64 %lnc7B, i64* %lnc7C, !tbaa !2
  %lnc7E = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbk4_info$def to i64
  %lnc7D = load i64*, i64** %Sp_Var
  %lnc7F = getelementptr inbounds i64, i64* %lnc7D, i32 -5
  store i64 %lnc7E, i64* %lnc7F, !tbaa !2
  %lnc7I = load i64, i64* %R1_Var
  %lnc7J = add i64 %lnc7I, 24
  %lnc7K = inttoptr i64 %lnc7J to i64*
  %lnc7L = load i64, i64* %lnc7K, !tbaa !4
  store i64 %lnc7L, i64* %lsaFv
  %lnc7O = load i64, i64* %R1_Var
  %lnc7P = add i64 %lnc7O, 32
  %lnc7Q = inttoptr i64 %lnc7P to i64*
  %lnc7R = load i64, i64* %lnc7Q, !tbaa !4
  store i64 %lnc7R, i64* %lsaGM
  %lnc7U = load i64, i64* %R1_Var
  %lnc7V = add i64 %lnc7U, 16
  %lnc7W = inttoptr i64 %lnc7V to i64*
  %lnc7X = load i64, i64* %lnc7W, !tbaa !4
  store i64 %lnc7X, i64* %R1_Var
  %lnc7Z = load i64, i64* %lsaFv
  %lnc7Y = load i64*, i64** %Sp_Var
  %lnc80 = getelementptr inbounds i64, i64* %lnc7Y, i32 -4
  store i64 %lnc7Z, i64* %lnc80, !tbaa !2
  %lnc82 = load i64, i64* %lsaGM
  %lnc81 = load i64*, i64** %Sp_Var
  %lnc83 = getelementptr inbounds i64, i64* %lnc81, i32 -3
  store i64 %lnc82, i64* %lnc83, !tbaa !2
  %lnc84 = load i64*, i64** %Sp_Var
  %lnc85 = getelementptr inbounds i64, i64* %lnc84, i32 -5
  %lnc86 = ptrtoint i64* %lnc85 to i64
  %lnc87 = inttoptr i64 %lnc86 to i64*
  store i64* %lnc87, i64** %Sp_Var
  %lnc88 = load i64, i64* %R1_Var
  %lnc89 = and i64 %lnc88, 7
  %lnc8a = icmp ne i64 %lnc89, 0
  br i1 %lnc8a, label %ublG, label %cbk5
cbk5:
  %lnc8c = load i64, i64* %R1_Var
  %lnc8d = inttoptr i64 %lnc8c to i64*
  %lnc8e = load i64, i64* %lnc8d, !tbaa !4
  %lnc8f = inttoptr i64 %lnc8e to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnc8g = load i64*, i64** %Sp_Var
  %lnc8h = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnc8f( i64* %Base_Arg, i64* %lnc8g, i64* %Hp_Arg, i64 %lnc8h, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ublG:
  %lnc8i = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbk4_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnc8j = load i64*, i64** %Sp_Var
  %lnc8k = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnc8i( i64* %Base_Arg, i64* %lnc8j, i64* %Hp_Arg, i64 %lnc8k, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cbkb:
  %lnc8l = load i64, i64* %R1_Var
  store i64 %lnc8l, i64* %R1_Var
  %lnc8m = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lnc8n = bitcast i64* %lnc8m to i64*
  %lnc8o = load i64, i64* %lnc8n, !tbaa !5
  %lnc8p = inttoptr i64 %lnc8o to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnc8q = load i64*, i64** %Sp_Var
  %lnc8r = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnc8p( i64* %Base_Arg, i64* %lnc8q, i64* %Hp_Arg, i64 %lnc8r, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cbk4_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbk4_info$def to i8*)
define internal ghccc void @cbk4_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 2, i32 30, i32 0}>
{
cbk4:
  %lsaHj = alloca i64, i32 1
  %lsaHh = alloca i64, i32 1
  %lsaHi = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnc8t = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbka_info$def to i64
  %lnc8s = load i64*, i64** %Sp_Var
  %lnc8u = getelementptr inbounds i64, i64* %lnc8s, i32 -2
  store i64 %lnc8t, i64* %lnc8u, !tbaa !2
  %lnc8x = load i64, i64* %R1_Var
  %lnc8y = add i64 %lnc8x, 7
  %lnc8z = inttoptr i64 %lnc8y to i64*
  %lnc8A = load i64, i64* %lnc8z, !tbaa !4
  store i64 %lnc8A, i64* %lsaHj
  %lnc8D = load i64, i64* %R1_Var
  %lnc8E = add i64 %lnc8D, 15
  %lnc8F = inttoptr i64 %lnc8E to i64*
  %lnc8G = load i64, i64* %lnc8F, !tbaa !4
  store i64 %lnc8G, i64* %lsaHh
  %lnc8J = load i64, i64* %R1_Var
  %lnc8K = add i64 %lnc8J, 23
  %lnc8L = inttoptr i64 %lnc8K to i64*
  %lnc8M = load i64, i64* %lnc8L, !tbaa !4
  store i64 %lnc8M, i64* %lsaHi
  %lnc8N = load i64*, i64** %Sp_Var
  %lnc8O = getelementptr inbounds i64, i64* %lnc8N, i32 1
  %lnc8P = bitcast i64* %lnc8O to i64*
  %lnc8Q = load i64, i64* %lnc8P, !tbaa !2
  store i64 %lnc8Q, i64* %R1_Var
  %lnc8S = load i64, i64* %lsaHj
  %lnc8R = load i64*, i64** %Sp_Var
  %lnc8T = getelementptr inbounds i64, i64* %lnc8R, i32 -1
  store i64 %lnc8S, i64* %lnc8T, !tbaa !2
  %lnc8V = load i64, i64* %lsaHi
  %lnc8U = load i64*, i64** %Sp_Var
  %lnc8W = getelementptr inbounds i64, i64* %lnc8U, i32 0
  store i64 %lnc8V, i64* %lnc8W, !tbaa !2
  %lnc8Y = load i64, i64* %lsaHh
  %lnc8X = load i64*, i64** %Sp_Var
  %lnc8Z = getelementptr inbounds i64, i64* %lnc8X, i32 1
  store i64 %lnc8Y, i64* %lnc8Z, !tbaa !2
  %lnc90 = load i64*, i64** %Sp_Var
  %lnc91 = getelementptr inbounds i64, i64* %lnc90, i32 -2
  %lnc92 = ptrtoint i64* %lnc91 to i64
  %lnc93 = inttoptr i64 %lnc92 to i64*
  store i64* %lnc93, i64** %Sp_Var
  %lnc94 = load i64, i64* %R1_Var
  %lnc95 = and i64 %lnc94, 7
  %lnc96 = icmp ne i64 %lnc95, 0
  br i1 %lnc96, label %ublF, label %cbke
cbke:
  %lnc98 = load i64, i64* %R1_Var
  %lnc99 = inttoptr i64 %lnc98 to i64*
  %lnc9a = load i64, i64* %lnc99, !tbaa !4
  %lnc9b = inttoptr i64 %lnc9a to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnc9c = load i64*, i64** %Sp_Var
  %lnc9d = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnc9b( i64* %Base_Arg, i64* %lnc9c, i64* %Hp_Arg, i64 %lnc9d, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ublF:
  %lnc9e = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbka_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnc9f = load i64*, i64** %Sp_Var
  %lnc9g = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnc9e( i64* %Base_Arg, i64* %lnc9f, i64* %Hp_Arg, i64 %lnc9g, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cbka_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbka_info$def to i8*)
define internal ghccc void @cbka_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 388, i32 30, i32 0}>
{
cbka:
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnc9i = add i64 %R1_Arg, 23
  %lnc9j = inttoptr i64 %lnc9i to i64*
  %lnc9k = load i64, i64* %lnc9j, !tbaa !4
  %lnc9h = load i64*, i64** %Sp_Var
  %lnc9l = getelementptr inbounds i64, i64* %lnc9h, i32 -5
  store i64 %lnc9k, i64* %lnc9l, !tbaa !2
  %lnc9n = add i64 %R1_Arg, 7
  %lnc9o = inttoptr i64 %lnc9n to i64*
  %lnc9p = load i64, i64* %lnc9o, !tbaa !4
  %lnc9m = load i64*, i64** %Sp_Var
  %lnc9q = getelementptr inbounds i64, i64* %lnc9m, i32 -4
  store i64 %lnc9p, i64* %lnc9q, !tbaa !2
  %lnc9r = load i64*, i64** %Sp_Var
  %lnc9s = getelementptr inbounds i64, i64* %lnc9r, i32 -3
  store i64 0, i64* %lnc9s, !tbaa !2
  %lnc9t = load i64*, i64** %Sp_Var
  %lnc9u = getelementptr inbounds i64, i64* %lnc9t, i32 -2
  store i64 0, i64* %lnc9u, !tbaa !2
  %lnc9v = load i64*, i64** %Sp_Var
  %lnc9w = getelementptr inbounds i64, i64* %lnc9v, i32 -1
  %lnc9x = bitcast i64* %lnc9w to double*
  store double 0x0000000000000000, double* %lnc9x, !tbaa !2
  %lnc9z = add i64 %R1_Arg, 15
  %lnc9A = inttoptr i64 %lnc9z to i64*
  %lnc9B = load i64, i64* %lnc9A, !tbaa !4
  %lnc9y = load i64*, i64** %Sp_Var
  %lnc9C = getelementptr inbounds i64, i64* %lnc9y, i32 0
  store i64 %lnc9B, i64* %lnc9C, !tbaa !2
  %lnc9D = load i64*, i64** %Sp_Var
  %lnc9E = getelementptr inbounds i64, i64* %lnc9D, i32 -5
  %lnc9F = ptrtoint i64* %lnc9E to i64
  %lnc9G = inttoptr i64 %lnc9F to i64*
  store i64* %lnc9G, i64** %Sp_Var
  %lnc9H = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @_cbkV$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnc9I = load i64*, i64** %Sp_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnc9H( i64* %Base_Arg, i64* %lnc9I, i64* %Hp_Arg, i64 %R1_Arg, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@_cbkV = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @_cbkV$def to i8*)
define internal ghccc void @_cbkV$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind
{
cbkV:
  %lsaGM = alloca i64, i32 1
  %lsaHA = alloca i64, i32 1
  %lsaHB = alloca double, i32 1
  %lsaHz = alloca i64, i32 1
  %lsaHF = alloca i64, i32 1
  %lsaHJ = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnc9J = load i64*, i64** %Sp_Var
  %lnc9K = getelementptr inbounds i64, i64* %lnc9J, i32 9
  %lnc9L = bitcast i64* %lnc9K to i64*
  %lnc9M = load i64, i64* %lnc9L, !tbaa !2
  store i64 %lnc9M, i64* %lsaGM
  %lnc9N = load i64*, i64** %Sp_Var
  %lnc9O = getelementptr inbounds i64, i64* %lnc9N, i32 3
  %lnc9P = bitcast i64* %lnc9O to i64*
  %lnc9Q = load i64, i64* %lnc9P, !tbaa !2
  store i64 %lnc9Q, i64* %lsaHA
  %lnc9R = load i64*, i64** %Sp_Var
  %lnc9S = getelementptr inbounds i64, i64* %lnc9R, i32 4
  %lnc9T = bitcast i64* %lnc9S to double*
  %lnc9U = load double, double* %lnc9T, !tbaa !2
  store double %lnc9U, double* %lsaHB
  %lnc9V = load i64, i64* %lsaHA
  %lnc9W = load i64*, i64** %Sp_Var
  %lnc9X = getelementptr inbounds i64, i64* %lnc9W, i32 7
  %lnc9Y = bitcast i64* %lnc9X to i64*
  %lnc9Z = load i64, i64* %lnc9Y, !tbaa !2
  %lnca0 = icmp sge i64 %lnc9V, %lnc9Z
  %lnca1 = zext i1 %lnca0 to i64
  switch i64 %lnca1, label %cblr [i64 1, label %cbls]
cblr:
  %lnca2 = load i64*, i64** %Sp_Var
  %lnca3 = getelementptr inbounds i64, i64* %lnca2, i32 2
  %lnca4 = bitcast i64* %lnca3 to i64*
  %lnca5 = load i64, i64* %lnca4, !tbaa !2
  store i64 %lnca5, i64* %lsaHz
  %lnca6 = load i64, i64* %lsaHz
  %lnca7 = load i64*, i64** %Sp_Var
  %lnca8 = getelementptr inbounds i64, i64* %lnca7, i32 0
  %lnca9 = bitcast i64* %lnca8 to i64*
  %lncaa = load i64, i64* %lnca9, !tbaa !2
  %lncab = icmp sge i64 %lnca6, %lncaa
  %lncac = zext i1 %lncab to i64
  switch i64 %lncac, label %cbli [i64 1, label %cblp]
cbli:
  %lncad = load i64*, i64** %Sp_Var
  %lncae = getelementptr inbounds i64, i64* %lncad, i32 6
  %lncaf = bitcast i64* %lncae to i64*
  %lncag = load i64, i64* %lncaf, !tbaa !2
  %lncah = load i64*, i64** %Sp_Var
  %lncai = getelementptr inbounds i64, i64* %lncah, i32 8
  %lncaj = bitcast i64* %lncai to i64*
  %lncak = load i64, i64* %lncaj, !tbaa !2
  %lncal = load i64, i64* %lsaHA
  %lncam = add i64 %lncak, %lncal
  %lncan = shl i64 %lncam, 3
  %lncao = add i64 %lncan, 24
  %lncap = add i64 %lncag, %lncao
  %lncaq = inttoptr i64 %lncap to i64*
  %lncar = load i64, i64* %lncaq, !tbaa !1
  store i64 %lncar, i64* %lsaHF
  %lncas = load i64*, i64** %Sp_Var
  %lncat = getelementptr inbounds i64, i64* %lncas, i32 1
  %lncau = bitcast i64* %lncat to i64*
  %lncav = load i64, i64* %lncau, !tbaa !2
  %lncaw = load i64*, i64** %Sp_Var
  %lncax = getelementptr inbounds i64, i64* %lncaw, i32 5
  %lncay = bitcast i64* %lncax to i64*
  %lncaz = load i64, i64* %lncay, !tbaa !2
  %lncaA = load i64, i64* %lsaHz
  %lncaB = add i64 %lncaz, %lncaA
  %lncaC = shl i64 %lncaB, 3
  %lncaD = add i64 %lncaC, 24
  %lncaE = add i64 %lncav, %lncaD
  %lncaF = inttoptr i64 %lncaE to i64*
  %lncaG = load i64, i64* %lncaF, !tbaa !1
  store i64 %lncaG, i64* %lsaHJ
  %lncaI = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cblb_info$def to i64
  %lncaH = load i64*, i64** %Sp_Var
  %lncaJ = getelementptr inbounds i64, i64* %lncaH, i32 -2
  store i64 %lncaI, i64* %lncaJ, !tbaa !2
  %lncaK = load i64, i64* %lsaHF
  store i64 %lncaK, i64* %R1_Var
  %lncaM = load i64, i64* %lsaHJ
  %lncaL = load i64*, i64** %Sp_Var
  %lncaN = getelementptr inbounds i64, i64* %lncaL, i32 -1
  store i64 %lncaM, i64* %lncaN, !tbaa !2
  %lncaO = load i64*, i64** %Sp_Var
  %lncaP = getelementptr inbounds i64, i64* %lncaO, i32 -2
  %lncaQ = ptrtoint i64* %lncaP to i64
  %lncaR = inttoptr i64 %lncaQ to i64*
  store i64* %lncaR, i64** %Sp_Var
  %lncaS = load i64, i64* %R1_Var
  %lncaT = and i64 %lncaS, 7
  %lncaU = icmp ne i64 %lncaT, 0
  br i1 %lncaU, label %ublI, label %cblc
cblc:
  %lncaW = load i64, i64* %R1_Var
  %lncaX = inttoptr i64 %lncaW to i64*
  %lncaY = load i64, i64* %lncaX, !tbaa !4
  %lncaZ = inttoptr i64 %lncaY to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncb0 = load i64*, i64** %Sp_Var
  %lncb1 = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncaZ( i64* %Base_Arg, i64* %lncb0, i64* %Hp_Arg, i64 %lncb1, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ublI:
  %lncb2 = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cblb_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncb3 = load i64*, i64** %Sp_Var
  %lncb4 = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncb2( i64* %Base_Arg, i64* %lncb3, i64* %Hp_Arg, i64 %lncb4, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cblp:
  %lncb6 = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbko_info$def to i64
  %lncb5 = load i64*, i64** %Sp_Var
  %lncb7 = getelementptr inbounds i64, i64* %lncb5, i32 8
  store i64 %lncb6, i64* %lncb7, !tbaa !2
  %lncb8 = load i64, i64* %lsaGM
  store i64 %lncb8, i64* %R1_Var
  %lncba = load double, double* %lsaHB
  %lncb9 = load i64*, i64** %Sp_Var
  %lncbb = getelementptr inbounds i64, i64* %lncb9, i32 9
  %lncbc = bitcast i64* %lncbb to double*
  store double %lncba, double* %lncbc, !tbaa !2
  %lncbd = load i64*, i64** %Sp_Var
  %lncbe = getelementptr inbounds i64, i64* %lncbd, i32 8
  %lncbf = ptrtoint i64* %lncbe to i64
  %lncbg = inttoptr i64 %lncbf to i64*
  store i64* %lncbg, i64** %Sp_Var
  %lncbh = load i64, i64* %R1_Var
  %lncbi = and i64 %lncbh, 7
  %lncbj = icmp ne i64 %lncbi, 0
  br i1 %lncbj, label %ublJ, label %cbkp
cbkp:
  %lncbl = load i64, i64* %R1_Var
  %lncbm = inttoptr i64 %lncbl to i64*
  %lncbn = load i64, i64* %lncbm, !tbaa !4
  %lncbo = inttoptr i64 %lncbn to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncbp = load i64*, i64** %Sp_Var
  %lncbq = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncbo( i64* %Base_Arg, i64* %lncbp, i64* %Hp_Arg, i64 %lncbq, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ublJ:
  %lncbr = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbko_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncbs = load i64*, i64** %Sp_Var
  %lncbt = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncbr( i64* %Base_Arg, i64* %lncbs, i64* %Hp_Arg, i64 %lncbt, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cbls:
  %lncbv = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbkG_info$def to i64
  %lncbu = load i64*, i64** %Sp_Var
  %lncbw = getelementptr inbounds i64, i64* %lncbu, i32 8
  store i64 %lncbv, i64* %lncbw, !tbaa !2
  %lncbx = load i64, i64* %lsaGM
  store i64 %lncbx, i64* %R1_Var
  %lncbz = load double, double* %lsaHB
  %lncby = load i64*, i64** %Sp_Var
  %lncbA = getelementptr inbounds i64, i64* %lncby, i32 9
  %lncbB = bitcast i64* %lncbA to double*
  store double %lncbz, double* %lncbB, !tbaa !2
  %lncbC = load i64*, i64** %Sp_Var
  %lncbD = getelementptr inbounds i64, i64* %lncbC, i32 8
  %lncbE = ptrtoint i64* %lncbD to i64
  %lncbF = inttoptr i64 %lncbE to i64*
  store i64* %lncbF, i64** %Sp_Var
  %lncbG = load i64, i64* %R1_Var
  %lncbH = and i64 %lncbG, 7
  %lncbI = icmp ne i64 %lncbH, 0
  br i1 %lncbI, label %ublK, label %cbkH
cbkH:
  %lncbK = load i64, i64* %R1_Var
  %lncbL = inttoptr i64 %lncbK to i64*
  %lncbM = load i64, i64* %lncbL, !tbaa !4
  %lncbN = inttoptr i64 %lncbM to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncbO = load i64*, i64** %Sp_Var
  %lncbP = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncbN( i64* %Base_Arg, i64* %lncbO, i64* %Hp_Arg, i64 %lncbP, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ublK:
  %lncbQ = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbkG_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncbR = load i64*, i64** %Sp_Var
  %lncbS = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncbQ( i64* %Base_Arg, i64* %lncbR, i64* %Hp_Arg, i64 %lncbS, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cbkG_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbkG_info$def to i8*)
define internal ghccc void @cbkG_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 65, i32 30, i32 0}>
{
cbkG:
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %lsaHx = alloca double, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lncbT = load i64*, i64** %Hp_Var
  %lncbU = getelementptr inbounds i64, i64* %lncbT, i32 2
  %lncbV = ptrtoint i64* %lncbU to i64
  %lncbW = inttoptr i64 %lncbV to i64*
  store i64* %lncbW, i64** %Hp_Var
  %lncbX = load i64*, i64** %Hp_Var
  %lncbY = ptrtoint i64* %lncbX to i64
  %lncbZ = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lncc0 = bitcast i64* %lncbZ to i64*
  %lncc1 = load i64, i64* %lncc0, !tbaa !5
  %lncc2 = icmp ugt i64 %lncbY, %lncc1
  %lncc3 = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lncc2, i1 0 )
  br i1 %lncc3, label %cbkS, label %cbkR
cbkR:
  %lncc4 = load i64*, i64** %Sp_Var
  %lncc5 = getelementptr inbounds i64, i64* %lncc4, i32 1
  %lncc6 = bitcast i64* %lncc5 to double*
  %lncc7 = load double, double* %lncc6, !tbaa !2
  %lncca = load i64, i64* %R1_Var
  %lnccb = add i64 %lncca, 7
  %lnccc = inttoptr i64 %lnccb to double*
  %lnccd = load double, double* %lnccc, !tbaa !4
  %lncce = fdiv double %lncc7, %lnccd
  store double %lncce, double* %lsaHx
  %lnccg = ptrtoint i8* @ghczmprim_GHCziTypes_Dzh_con_info to i64
  %lnccf = load i64*, i64** %Hp_Var
  %lncch = getelementptr inbounds i64, i64* %lnccf, i32 -1
  store i64 %lnccg, i64* %lncch, !tbaa !3
  %lnccj = load double, double* %lsaHx
  %lncci = load i64*, i64** %Hp_Var
  %lncck = getelementptr inbounds i64, i64* %lncci, i32 0
  %lnccl = bitcast i64* %lncck to double*
  store double %lnccj, double* %lnccl, !tbaa !3
  %lnccn = load i64*, i64** %Hp_Var
  %lncco = ptrtoint i64* %lnccn to i64
  %lnccp = add i64 %lncco, -7
  store i64 %lnccp, i64* %R1_Var
  %lnccq = load i64*, i64** %Sp_Var
  %lnccr = getelementptr inbounds i64, i64* %lnccq, i32 2
  %lnccs = ptrtoint i64* %lnccr to i64
  %lncct = inttoptr i64 %lnccs to i64*
  store i64* %lncct, i64** %Sp_Var
  %lnccu = load i64*, i64** %Sp_Var
  %lnccv = getelementptr inbounds i64, i64* %lnccu, i32 0
  %lnccw = bitcast i64* %lnccv to i64*
  %lnccx = load i64, i64* %lnccw, !tbaa !2
  %lnccy = inttoptr i64 %lnccx to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnccz = load i64*, i64** %Sp_Var
  %lnccA = load i64*, i64** %Hp_Var
  %lnccB = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnccy( i64* %Base_Arg, i64* %lnccz, i64* %lnccA, i64 %lnccB, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cbkS:
  %lnccC = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 16, i64* %lnccC, !tbaa !5
  %lnccD = load i64, i64* %R1_Var
  store i64 %lnccD, i64* %R1_Var
  %lnccE = bitcast i8* @stg_gc_unpt_r1 to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnccF = load i64*, i64** %Sp_Var
  %lnccG = load i64*, i64** %Hp_Var
  %lnccH = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnccE( i64* %Base_Arg, i64* %lnccF, i64* %lnccG, i64 %lnccH, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cbko_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cbko_info$def to i8*)
define internal ghccc void @cbko_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 65, i32 30, i32 0}>
{
cbko:
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %lsaHs = alloca double, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnccI = load i64*, i64** %Hp_Var
  %lnccJ = getelementptr inbounds i64, i64* %lnccI, i32 2
  %lnccK = ptrtoint i64* %lnccJ to i64
  %lnccL = inttoptr i64 %lnccK to i64*
  store i64* %lnccL, i64** %Hp_Var
  %lnccM = load i64*, i64** %Hp_Var
  %lnccN = ptrtoint i64* %lnccM to i64
  %lnccO = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lnccP = bitcast i64* %lnccO to i64*
  %lnccQ = load i64, i64* %lnccP, !tbaa !5
  %lnccR = icmp ugt i64 %lnccN, %lnccQ
  %lnccS = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnccR, i1 0 )
  br i1 %lnccS, label %cbkA, label %cbkz
cbkz:
  %lnccT = load i64*, i64** %Sp_Var
  %lnccU = getelementptr inbounds i64, i64* %lnccT, i32 1
  %lnccV = bitcast i64* %lnccU to double*
  %lnccW = load double, double* %lnccV, !tbaa !2
  %lnccZ = load i64, i64* %R1_Var
  %lncd0 = add i64 %lnccZ, 7
  %lncd1 = inttoptr i64 %lncd0 to double*
  %lncd2 = load double, double* %lncd1, !tbaa !4
  %lncd3 = fdiv double %lnccW, %lncd2
  store double %lncd3, double* %lsaHs
  %lncd5 = ptrtoint i8* @ghczmprim_GHCziTypes_Dzh_con_info to i64
  %lncd4 = load i64*, i64** %Hp_Var
  %lncd6 = getelementptr inbounds i64, i64* %lncd4, i32 -1
  store i64 %lncd5, i64* %lncd6, !tbaa !3
  %lncd8 = load double, double* %lsaHs
  %lncd7 = load i64*, i64** %Hp_Var
  %lncd9 = getelementptr inbounds i64, i64* %lncd7, i32 0
  %lncda = bitcast i64* %lncd9 to double*
  store double %lncd8, double* %lncda, !tbaa !3
  %lncdc = load i64*, i64** %Hp_Var
  %lncdd = ptrtoint i64* %lncdc to i64
  %lncde = add i64 %lncdd, -7
  store i64 %lncde, i64* %R1_Var
  %lncdf = load i64*, i64** %Sp_Var
  %lncdg = getelementptr inbounds i64, i64* %lncdf, i32 2
  %lncdh = ptrtoint i64* %lncdg to i64
  %lncdi = inttoptr i64 %lncdh to i64*
  store i64* %lncdi, i64** %Sp_Var
  %lncdj = load i64*, i64** %Sp_Var
  %lncdk = getelementptr inbounds i64, i64* %lncdj, i32 0
  %lncdl = bitcast i64* %lncdk to i64*
  %lncdm = load i64, i64* %lncdl, !tbaa !2
  %lncdn = inttoptr i64 %lncdm to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncdo = load i64*, i64** %Sp_Var
  %lncdp = load i64*, i64** %Hp_Var
  %lncdq = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncdn( i64* %Base_Arg, i64* %lncdo, i64* %lncdp, i64 %lncdq, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cbkA:
  %lncdr = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 16, i64* %lncdr, !tbaa !5
  %lncds = load i64, i64* %R1_Var
  store i64 %lncds, i64* %R1_Var
  %lncdt = bitcast i8* @stg_gc_unpt_r1 to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncdu = load i64*, i64** %Sp_Var
  %lncdv = load i64*, i64** %Hp_Var
  %lncdw = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncdt( i64* %Base_Arg, i64* %lncdu, i64* %lncdv, i64 %lncdw, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cblb_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cblb_info$def to i8*)
define internal ghccc void @cblb_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 56971, i32 30, i32 0}>
{
cblb:
  %lsaHL = alloca double, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lncdx = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cblg_info$def to i64
  %lncdy = getelementptr inbounds i64, i64* %Sp_Arg, i32 0
  store i64 %lncdx, i64* %lncdy, !tbaa !2
  %lncdB = load i64, i64* %R1_Var
  %lncdC = add i64 %lncdB, 7
  %lncdD = inttoptr i64 %lncdC to double*
  %lncdE = load double, double* %lncdD, !tbaa !4
  store double %lncdE, double* %lsaHL
  %lncdF = getelementptr inbounds i64, i64* %Sp_Arg, i32 1
  %lncdG = bitcast i64* %lncdF to i64*
  %lncdH = load i64, i64* %lncdG, !tbaa !2
  store i64 %lncdH, i64* %R1_Var
  %lncdI = load double, double* %lsaHL
  %lncdJ = getelementptr inbounds i64, i64* %Sp_Arg, i32 1
  %lncdK = bitcast i64* %lncdJ to double*
  store double %lncdI, double* %lncdK, !tbaa !2
  %lncdL = load i64, i64* %R1_Var
  %lncdM = and i64 %lncdL, 7
  %lncdN = icmp ne i64 %lncdM, 0
  br i1 %lncdN, label %ublL, label %cblk
cblk:
  %lncdP = load i64, i64* %R1_Var
  %lncdQ = inttoptr i64 %lncdP to i64*
  %lncdR = load i64, i64* %lncdQ, !tbaa !4
  %lncdS = inttoptr i64 %lncdR to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncdT = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncdS( i64* %Base_Arg, i64* %Sp_Arg, i64* %Hp_Arg, i64 %lncdT, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ublL:
  %lncdU = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cblg_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncdV = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncdU( i64* %Base_Arg, i64* %Sp_Arg, i64* %Hp_Arg, i64 %lncdV, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cblg_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cblg_info$def to i8*)
define internal ghccc void @cblg_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 57035, i32 30, i32 0}>
{
cblg:
  %lsaHB = alloca double, i32 1
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lncdW = load i64*, i64** %Sp_Var
  %lncdX = getelementptr inbounds i64, i64* %lncdW, i32 6
  %lncdY = bitcast i64* %lncdX to double*
  %lncdZ = load double, double* %lncdY, !tbaa !2
  %lnce0 = load i64*, i64** %Sp_Var
  %lnce1 = getelementptr inbounds i64, i64* %lnce0, i32 1
  %lnce2 = bitcast i64* %lnce1 to double*
  %lnce3 = load double, double* %lnce2, !tbaa !2
  %lnce4 = add i64 %R1_Arg, 7
  %lnce5 = inttoptr i64 %lnce4 to double*
  %lnce6 = load double, double* %lnce5, !tbaa !4
  %lnce7 = fmul double %lnce3, %lnce6
  %lnce8 = fadd double %lncdZ, %lnce7
  store double %lnce8, double* %lsaHB
  %lncea = load i64*, i64** %Sp_Var
  %lnceb = getelementptr inbounds i64, i64* %lncea, i32 4
  %lncec = bitcast i64* %lnceb to i64*
  %lnced = load i64, i64* %lncec, !tbaa !2
  %lncee = add i64 %lnced, 1
  %lnce9 = load i64*, i64** %Sp_Var
  %lncef = getelementptr inbounds i64, i64* %lnce9, i32 4
  store i64 %lncee, i64* %lncef, !tbaa !2
  %lnceh = load i64*, i64** %Sp_Var
  %lncei = getelementptr inbounds i64, i64* %lnceh, i32 5
  %lncej = bitcast i64* %lncei to i64*
  %lncek = load i64, i64* %lncej, !tbaa !2
  %lncel = add i64 %lncek, 1
  %lnceg = load i64*, i64** %Sp_Var
  %lncem = getelementptr inbounds i64, i64* %lnceg, i32 5
  store i64 %lncel, i64* %lncem, !tbaa !2
  %lnceo = load double, double* %lsaHB
  %lncen = load i64*, i64** %Sp_Var
  %lncep = getelementptr inbounds i64, i64* %lncen, i32 6
  %lnceq = bitcast i64* %lncep to double*
  store double %lnceo, double* %lnceq, !tbaa !2
  %lncer = load i64*, i64** %Sp_Var
  %lnces = getelementptr inbounds i64, i64* %lncer, i32 2
  %lncet = ptrtoint i64* %lnces to i64
  %lnceu = inttoptr i64 %lncet to i64*
  store i64* %lnceu, i64** %Sp_Var
  %lncev = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @_cbkV$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncew = load i64*, i64** %Sp_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncev( i64* %Base_Arg, i64* %lncew, i64* %Hp_Arg, i64 %R1_Arg, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saHT_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saHT_info$def to i8*)
define internal ghccc void @saHT_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 4, i32 15, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%ubmj_srt_struct* @ubmj_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saHT_info$def to i64)) to i32),i32 0)}>
{
cblQ:
  %R6_Var = alloca i64, i32 1
  store i64 undef, i64* %R6_Var
  %R5_Var = alloca i64, i32 1
  store i64 undef, i64* %R5_Var
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %lncex = add i64 %R1_Arg, 16
  %lncey = inttoptr i64 %lncex to i64*
  %lncez = load i64, i64* %lncey, !tbaa !4
  store i64 %lncez, i64* %R6_Var
  %lnceA = add i64 %R1_Arg, 24
  %lnceB = inttoptr i64 %lnceA to i64*
  %lnceC = load i64, i64* %lnceB, !tbaa !4
  store i64 %lnceC, i64* %R5_Var
  %lnceD = add i64 %R1_Arg, 32
  %lnceE = inttoptr i64 %lnceD to i64*
  %lnceF = load i64, i64* %lnceE, !tbaa !4
  store i64 %lnceF, i64* %R4_Var
  %lnceG = add i64 %R1_Arg, 40
  %lnceH = inttoptr i64 %lnceG to i64*
  %lnceI = load i64, i64* %lnceH, !tbaa !4
  store i64 %lnceI, i64* %R3_Var
  %lnceJ = ptrtoint i8* @base_GHCziFloat_zdfNumDouble_closure to i64
  store i64 %lnceJ, i64* %R2_Var
  %lnceK = bitcast i8* @hblaszm0zi0zi0zi0zminplace_HBLASziLevel1_axpyzq_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnceL = load i64, i64* %R2_Var
  %lnceM = load i64, i64* %R3_Var
  %lnceN = load i64, i64* %R4_Var
  %lnceO = load i64, i64* %R5_Var
  %lnceP = load i64, i64* %R6_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnceK( i64* %Base_Arg, i64* %Sp_Arg, i64* %Hp_Arg, i64 %R1_Arg, i64 %lnceL, i64 %lnceM, i64 %lnceN, i64 %lnceO, i64 %lnceP, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@Main_zdwzdsconjugateGradient_info = alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_zdwzdsconjugateGradient_info$def to i8*)
define ghccc void @Main_zdwzdsconjugateGradient_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i64, i64, i64, i32, i32}><{i64 add (i64 sub (i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_zdwzdsconjugateGradient_slow$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_zdwzdsconjugateGradient_info$def to i64)),i64 0), i64 389, i64 21474836480, i64 3, i32 14, i32 0}>
{
cblT:
  %lsaDl = alloca i64, i32 1
  %lsaDk = alloca i64, i32 1
  %lsaDj = alloca i64, i32 1
  %lsaDi = alloca i64, i32 1
  %lsaDh = alloca i64, i32 1
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %lcb9t = alloca i64, i32 1
  %lcb9u = alloca i64, i32 1
  %lcb9w = alloca i64, i32 1
  %lcb9y = alloca i64, i32 1
  %lcb9A = alloca i64, i32 1
  %lcb9C = alloca i64, i32 1
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  store i64 %R6_Arg, i64* %lsaDl
  store i64 %R5_Arg, i64* %lsaDk
  store i64 %R4_Arg, i64* %lsaDj
  store i64 %R3_Arg, i64* %lsaDi
  store i64 %R2_Arg, i64* %lsaDh
  %lnceQ = load i64*, i64** %Sp_Var
  %lnceR = getelementptr inbounds i64, i64* %lnceQ, i32 -13
  %lnceS = ptrtoint i64* %lnceR to i64
  %lnceT = icmp ult i64 %lnceS, %SpLim_Arg
  %lnceU = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnceT, i1 0 )
  br i1 %lnceU, label %cblU, label %cblV
cblV:
  %lnceV = load i64*, i64** %Hp_Var
  %lnceW = getelementptr inbounds i64, i64* %lnceV, i32 31
  %lnceX = ptrtoint i64* %lnceW to i64
  %lnceY = inttoptr i64 %lnceX to i64*
  store i64* %lnceY, i64** %Hp_Var
  %lnceZ = load i64*, i64** %Hp_Var
  %lncf0 = ptrtoint i64* %lnceZ to i64
  %lncf1 = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lncf2 = bitcast i64* %lncf1 to i64*
  %lncf3 = load i64, i64* %lncf2, !tbaa !5
  %lncf4 = icmp ugt i64 %lncf0, %lncf3
  %lncf5 = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lncf4, i1 0 )
  br i1 %lncf5, label %cblX, label %cblW
cblW:
  %lncf7 = ptrtoint i8* @vctrzm0zi12zi0zi2zm9a8f7398_DataziVector_Vector_con_info to i64
  %lncf6 = load i64*, i64** %Hp_Var
  %lncf8 = getelementptr inbounds i64, i64* %lncf6, i32 -30
  store i64 %lncf7, i64* %lncf8, !tbaa !3
  %lncfa = load i64, i64* %lsaDk
  %lncf9 = load i64*, i64** %Hp_Var
  %lncfb = getelementptr inbounds i64, i64* %lncf9, i32 -29
  store i64 %lncfa, i64* %lncfb, !tbaa !3
  %lncfd = load i64, i64* %lsaDi
  %lncfc = load i64*, i64** %Hp_Var
  %lncfe = getelementptr inbounds i64, i64* %lncfc, i32 -28
  store i64 %lncfd, i64* %lncfe, !tbaa !3
  %lncfg = load i64, i64* %lsaDj
  %lncff = load i64*, i64** %Hp_Var
  %lncfh = getelementptr inbounds i64, i64* %lncff, i32 -27
  store i64 %lncfg, i64* %lncfh, !tbaa !3
  %lncfj = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saDn_info$def to i64
  %lncfi = load i64*, i64** %Hp_Var
  %lncfk = getelementptr inbounds i64, i64* %lncfi, i32 -26
  store i64 %lncfj, i64* %lncfk, !tbaa !3
  %lncfm = load i64, i64* %lsaDh
  %lncfl = load i64*, i64** %Hp_Var
  %lncfn = getelementptr inbounds i64, i64* %lncfl, i32 -24
  store i64 %lncfm, i64* %lncfn, !tbaa !3
  %lncfp = load i64, i64* %lsaDl
  %lncfo = load i64*, i64** %Hp_Var
  %lncfq = getelementptr inbounds i64, i64* %lncfo, i32 -23
  store i64 %lncfp, i64* %lncfq, !tbaa !3
  %lncfs = load i64*, i64** %Hp_Var
  %lncft = ptrtoint i64* %lncfs to i64
  %lncfu = add i64 %lncft, -239
  store i64 %lncfu, i64* %lcb9t
  %lncfw = load i64, i64* %lcb9t
  %lncfv = load i64*, i64** %Hp_Var
  %lncfx = getelementptr inbounds i64, i64* %lncfv, i32 -22
  store i64 %lncfw, i64* %lncfx, !tbaa !3
  %lncfz = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saDt_info$def to i64
  %lncfy = load i64*, i64** %Hp_Var
  %lncfA = getelementptr inbounds i64, i64* %lncfy, i32 -21
  store i64 %lncfz, i64* %lncfA, !tbaa !3
  %lncfB = load i64*, i64** %Hp_Var
  %lncfC = getelementptr inbounds i64, i64* %lncfB, i32 -26
  %lncfD = ptrtoint i64* %lncfC to i64
  store i64 %lncfD, i64* %lcb9u
  %lncfF = load i64, i64* %lcb9u
  %lncfE = load i64*, i64** %Hp_Var
  %lncfG = getelementptr inbounds i64, i64* %lncfE, i32 -19
  store i64 %lncfF, i64* %lncfG, !tbaa !3
  %lncfI = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saE0_info$def to i64
  %lncfH = load i64*, i64** %Hp_Var
  %lncfJ = getelementptr inbounds i64, i64* %lncfH, i32 -18
  store i64 %lncfI, i64* %lncfJ, !tbaa !3
  %lncfL = load i64, i64* %lsaDh
  %lncfK = load i64*, i64** %Hp_Var
  %lncfM = getelementptr inbounds i64, i64* %lncfK, i32 -16
  store i64 %lncfL, i64* %lncfM, !tbaa !3
  %lncfN = load i64*, i64** %Hp_Var
  %lncfO = getelementptr inbounds i64, i64* %lncfN, i32 -21
  %lncfP = ptrtoint i64* %lncfO to i64
  store i64 %lncfP, i64* %lcb9w
  %lncfR = load i64, i64* %lcb9w
  %lncfQ = load i64*, i64** %Hp_Var
  %lncfS = getelementptr inbounds i64, i64* %lncfQ, i32 -15
  store i64 %lncfR, i64* %lncfS, !tbaa !3
  %lncfU = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saE5_info$def to i64
  %lncfT = load i64*, i64** %Hp_Var
  %lncfV = getelementptr inbounds i64, i64* %lncfT, i32 -14
  store i64 %lncfU, i64* %lncfV, !tbaa !3
  %lncfX = load i64, i64* %lcb9w
  %lncfW = load i64*, i64** %Hp_Var
  %lncfY = getelementptr inbounds i64, i64* %lncfW, i32 -12
  store i64 %lncfX, i64* %lncfY, !tbaa !3
  %lncfZ = load i64*, i64** %Hp_Var
  %lncg0 = getelementptr inbounds i64, i64* %lncfZ, i32 -18
  %lncg1 = ptrtoint i64* %lncg0 to i64
  store i64 %lncg1, i64* %lcb9y
  %lncg3 = load i64, i64* %lcb9y
  %lncg2 = load i64*, i64** %Hp_Var
  %lncg4 = getelementptr inbounds i64, i64* %lncg2, i32 -11
  store i64 %lncg3, i64* %lncg4, !tbaa !3
  %lncg6 = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saEy_info$def to i64
  %lncg5 = load i64*, i64** %Hp_Var
  %lncg7 = getelementptr inbounds i64, i64* %lncg5, i32 -10
  store i64 %lncg6, i64* %lncg7, !tbaa !3
  %lncg9 = load i64, i64* %lcb9u
  %lncg8 = load i64*, i64** %Hp_Var
  %lncga = getelementptr inbounds i64, i64* %lncg8, i32 -8
  store i64 %lncg9, i64* %lncga, !tbaa !3
  %lncgc = load i64, i64* %lcb9w
  %lncgb = load i64*, i64** %Hp_Var
  %lncgd = getelementptr inbounds i64, i64* %lncgb, i32 -7
  store i64 %lncgc, i64* %lncgd, !tbaa !3
  %lncge = load i64*, i64** %Hp_Var
  %lncgf = getelementptr inbounds i64, i64* %lncge, i32 -14
  %lncgg = ptrtoint i64* %lncgf to i64
  store i64 %lncgg, i64* %lcb9A
  %lncgi = load i64, i64* %lcb9A
  %lncgh = load i64*, i64** %Hp_Var
  %lncgj = getelementptr inbounds i64, i64* %lncgh, i32 -6
  store i64 %lncgi, i64* %lncgj, !tbaa !3
  %lncgl = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saHU_info$def to i64
  %lncgk = load i64*, i64** %Hp_Var
  %lncgm = getelementptr inbounds i64, i64* %lncgk, i32 -5
  store i64 %lncgl, i64* %lncgm, !tbaa !3
  %lncgo = load i64, i64* %lsaDl
  %lncgn = load i64*, i64** %Hp_Var
  %lncgp = getelementptr inbounds i64, i64* %lncgn, i32 -3
  store i64 %lncgo, i64* %lncgp, !tbaa !3
  %lncgr = load i64, i64* %lcb9t
  %lncgq = load i64*, i64** %Hp_Var
  %lncgs = getelementptr inbounds i64, i64* %lncgq, i32 -2
  store i64 %lncgr, i64* %lncgs, !tbaa !3
  %lncgu = load i64, i64* %lcb9w
  %lncgt = load i64*, i64** %Hp_Var
  %lncgv = getelementptr inbounds i64, i64* %lncgt, i32 -1
  store i64 %lncgu, i64* %lncgv, !tbaa !3
  %lncgw = load i64*, i64** %Hp_Var
  %lncgx = getelementptr inbounds i64, i64* %lncgw, i32 -10
  %lncgy = ptrtoint i64* %lncgx to i64
  store i64 %lncgy, i64* %lcb9C
  %lncgA = load i64, i64* %lcb9C
  %lncgz = load i64*, i64** %Hp_Var
  %lncgB = getelementptr inbounds i64, i64* %lncgz, i32 0
  store i64 %lncgA, i64* %lncgB, !tbaa !3
  %lncgD = load i64, i64* %lcb9t
  %lncgC = load i64*, i64** %Sp_Var
  %lncgE = getelementptr inbounds i64, i64* %lncgC, i32 -10
  store i64 %lncgD, i64* %lncgE, !tbaa !2
  %lncgG = load i64, i64* %lsaDh
  %lncgF = load i64*, i64** %Sp_Var
  %lncgH = getelementptr inbounds i64, i64* %lncgF, i32 -9
  store i64 %lncgG, i64* %lncgH, !tbaa !2
  %lncgJ = load i64, i64* %lsaDl
  %lncgI = load i64*, i64** %Sp_Var
  %lncgK = getelementptr inbounds i64, i64* %lncgI, i32 -8
  store i64 %lncgJ, i64* %lncgK, !tbaa !2
  %lncgM = load i64, i64* %lsaDj
  %lncgL = load i64*, i64** %Sp_Var
  %lncgN = getelementptr inbounds i64, i64* %lncgL, i32 -7
  store i64 %lncgM, i64* %lncgN, !tbaa !2
  %lncgP = load i64, i64* %lcb9u
  %lncgO = load i64*, i64** %Sp_Var
  %lncgQ = getelementptr inbounds i64, i64* %lncgO, i32 -6
  store i64 %lncgP, i64* %lncgQ, !tbaa !2
  %lncgS = load i64, i64* %lcb9w
  %lncgR = load i64*, i64** %Sp_Var
  %lncgT = getelementptr inbounds i64, i64* %lncgR, i32 -5
  store i64 %lncgS, i64* %lncgT, !tbaa !2
  %lncgV = load i64, i64* %lcb9y
  %lncgU = load i64*, i64** %Sp_Var
  %lncgW = getelementptr inbounds i64, i64* %lncgU, i32 -4
  store i64 %lncgV, i64* %lncgW, !tbaa !2
  %lncgY = load i64, i64* %lcb9A
  %lncgX = load i64*, i64** %Sp_Var
  %lncgZ = getelementptr inbounds i64, i64* %lncgX, i32 -3
  store i64 %lncgY, i64* %lncgZ, !tbaa !2
  %lnch1 = load i64, i64* %lcb9C
  %lnch0 = load i64*, i64** %Sp_Var
  %lnch2 = getelementptr inbounds i64, i64* %lnch0, i32 -2
  store i64 %lnch1, i64* %lnch2, !tbaa !2
  %lnch4 = load i64*, i64** %Hp_Var
  %lnch5 = getelementptr inbounds i64, i64* %lnch4, i32 -5
  %lnch6 = ptrtoint i64* %lnch5 to i64
  %lnch3 = load i64*, i64** %Sp_Var
  %lnch7 = getelementptr inbounds i64, i64* %lnch3, i32 -1
  store i64 %lnch6, i64* %lnch7, !tbaa !2
  %lnch8 = load i64*, i64** %Sp_Var
  %lnch9 = getelementptr inbounds i64, i64* %lnch8, i32 -10
  %lncha = ptrtoint i64* %lnch9 to i64
  %lnchb = inttoptr i64 %lncha to i64*
  store i64* %lnchb, i64** %Sp_Var
  %lnchc = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @_cb9I$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnchd = load i64*, i64** %Sp_Var
  %lnche = load i64*, i64** %Hp_Var
  %lnchf = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnchc( i64* %Base_Arg, i64* %lnchd, i64* %lnche, i64 %lnchf, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cblX:
  %lnchg = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 248, i64* %lnchg, !tbaa !5
  br label %cblU
cblU:
  %lnchh = ptrtoint %Main_zdwzdsconjugateGradient_closure_struct* @Main_zdwzdsconjugateGradient_closure$def to i64
  store i64 %lnchh, i64* %R1_Var
  %lnchj = load i64, i64* %lsaDh
  %lnchi = load i64*, i64** %Sp_Var
  %lnchk = getelementptr inbounds i64, i64* %lnchi, i32 -5
  store i64 %lnchj, i64* %lnchk, !tbaa !2
  %lnchm = load i64, i64* %lsaDi
  %lnchl = load i64*, i64** %Sp_Var
  %lnchn = getelementptr inbounds i64, i64* %lnchl, i32 -4
  store i64 %lnchm, i64* %lnchn, !tbaa !2
  %lnchp = load i64, i64* %lsaDj
  %lncho = load i64*, i64** %Sp_Var
  %lnchq = getelementptr inbounds i64, i64* %lncho, i32 -3
  store i64 %lnchp, i64* %lnchq, !tbaa !2
  %lnchs = load i64, i64* %lsaDk
  %lnchr = load i64*, i64** %Sp_Var
  %lncht = getelementptr inbounds i64, i64* %lnchr, i32 -2
  store i64 %lnchs, i64* %lncht, !tbaa !2
  %lnchv = load i64, i64* %lsaDl
  %lnchu = load i64*, i64** %Sp_Var
  %lnchw = getelementptr inbounds i64, i64* %lnchu, i32 -1
  store i64 %lnchv, i64* %lnchw, !tbaa !2
  %lnchx = load i64*, i64** %Sp_Var
  %lnchy = getelementptr inbounds i64, i64* %lnchx, i32 -5
  %lnchz = ptrtoint i64* %lnchy to i64
  %lnchA = inttoptr i64 %lnchz to i64*
  store i64* %lnchA, i64** %Sp_Var
  %lnchB = getelementptr inbounds i64, i64* %Base_Arg, i32 -1
  %lnchC = bitcast i64* %lnchB to i64*
  %lnchD = load i64, i64* %lnchC, !tbaa !5
  %lnchE = inttoptr i64 %lnchD to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnchF = load i64*, i64** %Sp_Var
  %lnchG = load i64*, i64** %Hp_Var
  %lnchH = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnchE( i64* %Base_Arg, i64* %lnchF, i64* %lnchG, i64 %lnchH, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@_cb9I = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @_cb9I$def to i8*)
define internal ghccc void @_cb9I$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind
{
cb9I:
  %lsaFj = alloca i64, i32 1
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lnchI = load i64*, i64** %Sp_Var
  %lnchJ = getelementptr inbounds i64, i64* %lnchI, i32 3
  %lnchK = bitcast i64* %lnchJ to i64*
  %lnchL = load i64, i64* %lnchK, !tbaa !2
  store i64 %lnchL, i64* %lsaFj
  %lnchM = load i64, i64* %lsaFj
  switch i64 %lnchM, label %cbm0 [i64 0, label %cbmd]
cbm0:
  %lnchO = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cb9N_info$def to i64
  %lnchN = load i64*, i64** %Sp_Var
  %lnchP = getelementptr inbounds i64, i64* %lnchN, i32 -1
  store i64 %lnchO, i64* %lnchP, !tbaa !2
  %lnchQ = ptrtoint i8* @base_GHCziFloat_zdfFloatingDouble_closure to i64
  store i64 %lnchQ, i64* %R2_Var
  %lnchS = ptrtoint i8* @stg_ap_p_info to i64
  %lnchR = load i64*, i64** %Sp_Var
  %lnchT = getelementptr inbounds i64, i64* %lnchR, i32 -3
  store i64 %lnchS, i64* %lnchT, !tbaa !2
  %lnchV = load i64*, i64** %Sp_Var
  %lnchW = getelementptr inbounds i64, i64* %lnchV, i32 4
  %lnchX = bitcast i64* %lnchW to i64*
  %lnchY = load i64, i64* %lnchX, !tbaa !2
  %lnchU = load i64*, i64** %Sp_Var
  %lnchZ = getelementptr inbounds i64, i64* %lnchU, i32 -2
  store i64 %lnchY, i64* %lnchZ, !tbaa !2
  %lnci1 = load i64, i64* %lsaFj
  %lnci0 = load i64*, i64** %Sp_Var
  %lnci2 = getelementptr inbounds i64, i64* %lnci0, i32 3
  store i64 %lnci1, i64* %lnci2, !tbaa !2
  %lnci3 = load i64*, i64** %Sp_Var
  %lnci4 = getelementptr inbounds i64, i64* %lnci3, i32 -3
  %lnci5 = ptrtoint i64* %lnci4 to i64
  %lnci6 = inttoptr i64 %lnci5 to i64*
  store i64* %lnci6, i64** %Sp_Var
  %lnci7 = bitcast i8* @hblaszm0zi0zi0zi0zminplace_HBLASziLevel1_zdwnrm2_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnci8 = load i64*, i64** %Sp_Var
  %lnci9 = load i64, i64* %R1_Var
  %lncia = load i64, i64* %R2_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnci7( i64* %Base_Arg, i64* %lnci8, i64* %Hp_Arg, i64 %lnci9, i64 %lncia, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cbmd:
  %lncib = load i64*, i64** %Sp_Var
  %lncic = getelementptr inbounds i64, i64* %lncib, i32 9
  %lncid = bitcast i64* %lncic to i64*
  %lncie = load i64, i64* %lncid, !tbaa !2
  %lncif = and i64 %lncie, -8
  store i64 %lncif, i64* %R1_Var
  %lncig = load i64*, i64** %Sp_Var
  %lncih = getelementptr inbounds i64, i64* %lncig, i32 10
  %lncii = ptrtoint i64* %lncih to i64
  %lncij = inttoptr i64 %lncii to i64*
  store i64* %lncij, i64** %Sp_Var
  %lncil = load i64, i64* %R1_Var
  %lncim = inttoptr i64 %lncil to i64*
  %lncin = load i64, i64* %lncim, !tbaa !4
  %lncio = inttoptr i64 %lncin to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncip = load i64*, i64** %Sp_Var
  %lnciq = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncio( i64* %Base_Arg, i64* %lncip, i64* %Hp_Arg, i64 %lnciq, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cb9N_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cb9N_info$def to i8*)
define internal ghccc void @cb9N_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 522, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%ubmq_srt_struct* @ubmq_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cb9N_info$def to i64)) to i32),i32 0)}>
{
cb9N:
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %lcb9U = alloca i64, i32 1
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lncir = load i64*, i64** %Hp_Var
  %lncis = getelementptr inbounds i64, i64* %lncir, i32 6
  %lncit = ptrtoint i64* %lncis to i64
  %lnciu = inttoptr i64 %lncit to i64*
  store i64* %lnciu, i64** %Hp_Var
  %lnciv = load i64*, i64** %Hp_Var
  %lnciw = ptrtoint i64* %lnciv to i64
  %lncix = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lnciy = bitcast i64* %lncix to i64*
  %lnciz = load i64, i64* %lnciy, !tbaa !5
  %lnciA = icmp ugt i64 %lnciw, %lnciz
  %lnciB = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnciA, i1 0 )
  br i1 %lnciB, label %cbm3, label %cbm2
cbm2:
  %lnciE = load i64, i64* %R1_Var
  %lnciF = add i64 %lnciE, 7
  %lnciG = inttoptr i64 %lnciF to double*
  %lnciH = load double, double* %lnciG, !tbaa !4
  %lnciI = fcmp olt double %lnciH, 0x3DDB7CDFD9D7BDBB
  %lnciJ = zext i1 %lnciI to i64
  switch i64 %lnciJ, label %cbm5 [i64 1, label %cbmc]
cbm5:
  %lnciL = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saFn_info$def to i64
  %lnciK = load i64*, i64** %Hp_Var
  %lnciM = getelementptr inbounds i64, i64* %lnciK, i32 -5
  store i64 %lnciL, i64* %lnciM, !tbaa !3
  %lnciO = load i64*, i64** %Sp_Var
  %lnciP = getelementptr inbounds i64, i64* %lnciO, i32 3
  %lnciQ = bitcast i64* %lnciP to i64*
  %lnciR = load i64, i64* %lnciQ, !tbaa !2
  %lnciN = load i64*, i64** %Hp_Var
  %lnciS = getelementptr inbounds i64, i64* %lnciN, i32 -3
  store i64 %lnciR, i64* %lnciS, !tbaa !3
  %lnciU = load i64*, i64** %Sp_Var
  %lnciV = getelementptr inbounds i64, i64* %lnciU, i32 5
  %lnciW = bitcast i64* %lnciV to i64*
  %lnciX = load i64, i64* %lnciW, !tbaa !2
  %lnciT = load i64*, i64** %Hp_Var
  %lnciY = getelementptr inbounds i64, i64* %lnciT, i32 -2
  store i64 %lnciX, i64* %lnciY, !tbaa !3
  %lncj0 = load i64*, i64** %Sp_Var
  %lncj1 = getelementptr inbounds i64, i64* %lncj0, i32 7
  %lncj2 = bitcast i64* %lncj1 to i64*
  %lncj3 = load i64, i64* %lncj2, !tbaa !2
  %lnciZ = load i64*, i64** %Hp_Var
  %lncj4 = getelementptr inbounds i64, i64* %lnciZ, i32 -1
  store i64 %lncj3, i64* %lncj4, !tbaa !3
  %lncj6 = load i64*, i64** %Sp_Var
  %lncj7 = getelementptr inbounds i64, i64* %lncj6, i32 9
  %lncj8 = bitcast i64* %lncj7 to i64*
  %lncj9 = load i64, i64* %lncj8, !tbaa !2
  %lncj5 = load i64*, i64** %Hp_Var
  %lncja = getelementptr inbounds i64, i64* %lncj5, i32 0
  store i64 %lncj9, i64* %lncja, !tbaa !3
  %lncjc = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cb9W_info$def to i64
  %lncjb = load i64*, i64** %Sp_Var
  %lncjd = getelementptr inbounds i64, i64* %lncjb, i32 0
  store i64 %lncjc, i64* %lncjd, !tbaa !2
  %lncje = ptrtoint i8* @base_GHCziFloat_zdfFloatingDouble_closure to i64
  store i64 %lncje, i64* %R2_Var
  %lncjg = ptrtoint i8* @stg_ap_p_info to i64
  %lncjf = load i64*, i64** %Sp_Var
  %lncjh = getelementptr inbounds i64, i64* %lncjf, i32 -2
  store i64 %lncjg, i64* %lncjh, !tbaa !2
  %lncji = load i64*, i64** %Hp_Var
  %lncjj = getelementptr inbounds i64, i64* %lncji, i32 -5
  %lncjk = ptrtoint i64* %lncjj to i64
  store i64 %lncjk, i64* %lcb9U
  %lncjm = load i64, i64* %lcb9U
  %lncjl = load i64*, i64** %Sp_Var
  %lncjn = getelementptr inbounds i64, i64* %lncjl, i32 -1
  store i64 %lncjm, i64* %lncjn, !tbaa !2
  %lncjp = load i64, i64* %lcb9U
  %lncjo = load i64*, i64** %Sp_Var
  %lncjq = getelementptr inbounds i64, i64* %lncjo, i32 9
  store i64 %lncjp, i64* %lncjq, !tbaa !2
  %lncjr = load i64*, i64** %Sp_Var
  %lncjs = getelementptr inbounds i64, i64* %lncjr, i32 -2
  %lncjt = ptrtoint i64* %lncjs to i64
  %lncju = inttoptr i64 %lncjt to i64*
  store i64* %lncju, i64** %Sp_Var
  %lncjv = bitcast i8* @hblaszm0zi0zi0zi0zminplace_HBLASziLevel1_zdwnrm2_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncjw = load i64*, i64** %Sp_Var
  %lncjx = load i64*, i64** %Hp_Var
  %lncjy = load i64, i64* %R1_Var
  %lncjz = load i64, i64* %R2_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncjv( i64* %Base_Arg, i64* %lncjw, i64* %lncjx, i64 %lncjy, i64 %lncjz, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cbmc:
  %lncjA = load i64*, i64** %Hp_Var
  %lncjB = getelementptr inbounds i64, i64* %lncjA, i32 -6
  %lncjC = ptrtoint i64* %lncjB to i64
  %lncjD = inttoptr i64 %lncjC to i64*
  store i64* %lncjD, i64** %Hp_Var
  %lncjE = load i64*, i64** %Sp_Var
  %lncjF = getelementptr inbounds i64, i64* %lncjE, i32 1
  %lncjG = bitcast i64* %lncjF to i64*
  %lncjH = load i64, i64* %lncjG, !tbaa !2
  store i64 %lncjH, i64* %R1_Var
  %lncjI = load i64*, i64** %Sp_Var
  %lncjJ = getelementptr inbounds i64, i64* %lncjI, i32 11
  %lncjK = ptrtoint i64* %lncjJ to i64
  %lncjL = inttoptr i64 %lncjK to i64*
  store i64* %lncjL, i64** %Sp_Var
  %lncjM = load i64*, i64** %Sp_Var
  %lncjN = getelementptr inbounds i64, i64* %lncjM, i32 0
  %lncjO = bitcast i64* %lncjN to i64*
  %lncjP = load i64, i64* %lncjO, !tbaa !2
  %lncjQ = inttoptr i64 %lncjP to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncjR = load i64*, i64** %Sp_Var
  %lncjS = load i64*, i64** %Hp_Var
  %lncjT = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncjQ( i64* %Base_Arg, i64* %lncjR, i64* %lncjS, i64 %lncjT, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cbm3:
  %lncjU = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 48, i64* %lncjU, !tbaa !5
  %lncjV = load i64, i64* %R1_Var
  store i64 %lncjV, i64* %R1_Var
  %lncjW = bitcast i8* @stg_gc_unpt_r1 to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncjX = load i64*, i64** %Sp_Var
  %lncjY = load i64*, i64** %Hp_Var
  %lncjZ = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncjW( i64* %Base_Arg, i64* %lncjX, i64* %lncjY, i64 %lncjZ, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cb9W_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cb9W_info$def to i8*)
define internal ghccc void @cb9W_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 1546, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%ubmq_srt_struct* @ubmq_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cb9W_info$def to i64)) to i32),i32 0)}>
{
cb9W:
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %lsaFi = alloca i64, i32 1
  %lsaDl = alloca i64, i32 1
  %lcb9U = alloca i64, i32 1
  %lcba3 = alloca i64, i32 1
  %lcba5 = alloca i64, i32 1
  %lcba7 = alloca i64, i32 1
  %lcba9 = alloca i64, i32 1
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lnck0 = load i64*, i64** %Hp_Var
  %lnck1 = getelementptr inbounds i64, i64* %lnck0, i32 26
  %lnck2 = ptrtoint i64* %lnck1 to i64
  %lnck3 = inttoptr i64 %lnck2 to i64*
  store i64* %lnck3, i64** %Hp_Var
  %lnck4 = load i64*, i64** %Hp_Var
  %lnck5 = ptrtoint i64* %lnck4 to i64
  %lnck6 = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lnck7 = bitcast i64* %lnck6 to i64*
  %lnck8 = load i64, i64* %lnck7, !tbaa !5
  %lnck9 = icmp ugt i64 %lnck5, %lnck8
  %lncka = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnck9, i1 0 )
  br i1 %lncka, label %cbm8, label %cbm7
cbm7:
  %lnckb = load i64*, i64** %Sp_Var
  %lnckc = getelementptr inbounds i64, i64* %lnckb, i32 10
  %lnckd = bitcast i64* %lnckc to i64*
  %lncke = load i64, i64* %lnckd, !tbaa !2
  store i64 %lncke, i64* %lsaFi
  %lnckh = load i64, i64* %R1_Var
  %lncki = add i64 %lnckh, 7
  %lnckj = inttoptr i64 %lncki to double*
  %lnckk = load double, double* %lnckj, !tbaa !4
  %lnckl = fcmp olt double %lnckk, 0x3DDB7CDFD9D7BDBB
  %lnckm = zext i1 %lnckl to i64
  switch i64 %lnckm, label %cbma [i64 1, label %cbmb]
cbma:
  %lncko = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saFv_info$def to i64
  %lnckn = load i64*, i64** %Hp_Var
  %lnckp = getelementptr inbounds i64, i64* %lnckn, i32 -25
  store i64 %lncko, i64* %lnckp, !tbaa !3
  %lnckq = load i64*, i64** %Sp_Var
  %lnckr = getelementptr inbounds i64, i64* %lnckq, i32 3
  %lncks = bitcast i64* %lnckr to i64*
  %lnckt = load i64, i64* %lncks, !tbaa !2
  store i64 %lnckt, i64* %lsaDl
  %lnckv = load i64, i64* %lsaDl
  %lncku = load i64*, i64** %Hp_Var
  %lnckw = getelementptr inbounds i64, i64* %lncku, i32 -23
  store i64 %lnckv, i64* %lnckw, !tbaa !3
  %lncky = load i64*, i64** %Sp_Var
  %lnckz = getelementptr inbounds i64, i64* %lncky, i32 6
  %lnckA = bitcast i64* %lnckz to i64*
  %lnckB = load i64, i64* %lnckA, !tbaa !2
  %lnckx = load i64*, i64** %Hp_Var
  %lnckC = getelementptr inbounds i64, i64* %lnckx, i32 -22
  store i64 %lnckB, i64* %lnckC, !tbaa !3
  %lnckE = load i64*, i64** %Sp_Var
  %lnckF = getelementptr inbounds i64, i64* %lnckE, i32 7
  %lnckG = bitcast i64* %lnckF to i64*
  %lnckH = load i64, i64* %lnckG, !tbaa !2
  %lnckD = load i64*, i64** %Hp_Var
  %lnckI = getelementptr inbounds i64, i64* %lnckD, i32 -21
  store i64 %lnckH, i64* %lnckI, !tbaa !3
  %lnckK = load i64*, i64** %Sp_Var
  %lnckL = getelementptr inbounds i64, i64* %lnckK, i32 8
  %lnckM = bitcast i64* %lnckL to i64*
  %lnckN = load i64, i64* %lnckM, !tbaa !2
  %lnckJ = load i64*, i64** %Hp_Var
  %lnckO = getelementptr inbounds i64, i64* %lnckJ, i32 -20
  store i64 %lnckN, i64* %lnckO, !tbaa !3
  %lnckP = load i64*, i64** %Sp_Var
  %lnckQ = getelementptr inbounds i64, i64* %lnckP, i32 9
  %lnckR = bitcast i64* %lnckQ to i64*
  %lnckS = load i64, i64* %lnckR, !tbaa !2
  store i64 %lnckS, i64* %lcb9U
  %lnckU = load i64, i64* %lcb9U
  %lnckT = load i64*, i64** %Hp_Var
  %lnckV = getelementptr inbounds i64, i64* %lnckT, i32 -19
  store i64 %lnckU, i64* %lnckV, !tbaa !3
  %lnckX = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saGH_info$def to i64
  %lnckW = load i64*, i64** %Hp_Var
  %lnckY = getelementptr inbounds i64, i64* %lnckW, i32 -18
  store i64 %lnckX, i64* %lnckY, !tbaa !3
  %lncl0 = load i64*, i64** %Sp_Var
  %lncl1 = getelementptr inbounds i64, i64* %lncl0, i32 2
  %lncl2 = bitcast i64* %lncl1 to i64*
  %lncl3 = load i64, i64* %lncl2, !tbaa !2
  %lnckZ = load i64*, i64** %Hp_Var
  %lncl4 = getelementptr inbounds i64, i64* %lnckZ, i32 -16
  store i64 %lncl3, i64* %lncl4, !tbaa !3
  %lncl5 = load i64*, i64** %Hp_Var
  %lncl6 = getelementptr inbounds i64, i64* %lncl5, i32 -25
  %lncl7 = ptrtoint i64* %lncl6 to i64
  store i64 %lncl7, i64* %lcba3
  %lncl9 = load i64, i64* %lcba3
  %lncl8 = load i64*, i64** %Hp_Var
  %lncla = getelementptr inbounds i64, i64* %lncl8, i32 -15
  store i64 %lncl9, i64* %lncla, !tbaa !3
  %lnclc = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saGM_info$def to i64
  %lnclb = load i64*, i64** %Hp_Var
  %lncld = getelementptr inbounds i64, i64* %lnclb, i32 -14
  store i64 %lnclc, i64* %lncld, !tbaa !3
  %lnclf = load i64, i64* %lcba3
  %lncle = load i64*, i64** %Hp_Var
  %lnclg = getelementptr inbounds i64, i64* %lncle, i32 -12
  store i64 %lnclf, i64* %lnclg, !tbaa !3
  %lnclh = load i64*, i64** %Hp_Var
  %lncli = getelementptr inbounds i64, i64* %lnclh, i32 -18
  %lnclj = ptrtoint i64* %lncli to i64
  store i64 %lnclj, i64* %lcba5
  %lncll = load i64, i64* %lcba5
  %lnclk = load i64*, i64** %Hp_Var
  %lnclm = getelementptr inbounds i64, i64* %lnclk, i32 -11
  store i64 %lncll, i64* %lnclm, !tbaa !3
  %lnclo = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saHf_info$def to i64
  %lncln = load i64*, i64** %Hp_Var
  %lnclp = getelementptr inbounds i64, i64* %lncln, i32 -10
  store i64 %lnclo, i64* %lnclp, !tbaa !3
  %lnclr = load i64, i64* %lcb9U
  %lnclq = load i64*, i64** %Hp_Var
  %lncls = getelementptr inbounds i64, i64* %lnclq, i32 -8
  store i64 %lnclr, i64* %lncls, !tbaa !3
  %lnclu = load i64, i64* %lcba3
  %lnclt = load i64*, i64** %Hp_Var
  %lnclv = getelementptr inbounds i64, i64* %lnclt, i32 -7
  store i64 %lnclu, i64* %lnclv, !tbaa !3
  %lnclw = load i64*, i64** %Hp_Var
  %lnclx = getelementptr inbounds i64, i64* %lnclw, i32 -14
  %lncly = ptrtoint i64* %lnclx to i64
  store i64 %lncly, i64* %lcba7
  %lnclA = load i64, i64* %lcba7
  %lnclz = load i64*, i64** %Hp_Var
  %lnclB = getelementptr inbounds i64, i64* %lnclz, i32 -6
  store i64 %lnclA, i64* %lnclB, !tbaa !3
  %lnclD = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saHT_info$def to i64
  %lnclC = load i64*, i64** %Hp_Var
  %lnclE = getelementptr inbounds i64, i64* %lnclC, i32 -5
  store i64 %lnclD, i64* %lnclE, !tbaa !3
  %lnclG = load i64, i64* %lsaDl
  %lnclF = load i64*, i64** %Hp_Var
  %lnclH = getelementptr inbounds i64, i64* %lnclF, i32 -3
  store i64 %lnclG, i64* %lnclH, !tbaa !3
  %lnclJ = load i64, i64* %lsaFi
  %lnclI = load i64*, i64** %Hp_Var
  %lnclK = getelementptr inbounds i64, i64* %lnclI, i32 -2
  store i64 %lnclJ, i64* %lnclK, !tbaa !3
  %lnclM = load i64, i64* %lcba3
  %lnclL = load i64*, i64** %Hp_Var
  %lnclN = getelementptr inbounds i64, i64* %lnclL, i32 -1
  store i64 %lnclM, i64* %lnclN, !tbaa !3
  %lnclO = load i64*, i64** %Hp_Var
  %lnclP = getelementptr inbounds i64, i64* %lnclO, i32 -10
  %lnclQ = ptrtoint i64* %lnclP to i64
  store i64 %lnclQ, i64* %lcba9
  %lnclS = load i64, i64* %lcba9
  %lnclR = load i64*, i64** %Hp_Var
  %lnclT = getelementptr inbounds i64, i64* %lnclR, i32 0
  store i64 %lnclS, i64* %lnclT, !tbaa !3
  %lnclV = load i64*, i64** %Sp_Var
  %lnclW = getelementptr inbounds i64, i64* %lnclV, i32 4
  %lnclX = bitcast i64* %lnclW to i64*
  %lnclY = load i64, i64* %lnclX, !tbaa !2
  %lnclZ = add i64 %lnclY, -1
  %lnclU = load i64*, i64** %Sp_Var
  %lncm0 = getelementptr inbounds i64, i64* %lnclU, i32 4
  store i64 %lnclZ, i64* %lncm0, !tbaa !2
  %lncm2 = load i64, i64* %lcb9U
  %lncm1 = load i64*, i64** %Sp_Var
  %lncm3 = getelementptr inbounds i64, i64* %lncm1, i32 5
  store i64 %lncm2, i64* %lncm3, !tbaa !2
  %lncm5 = load i64, i64* %lcba3
  %lncm4 = load i64*, i64** %Sp_Var
  %lncm6 = getelementptr inbounds i64, i64* %lncm4, i32 6
  store i64 %lncm5, i64* %lncm6, !tbaa !2
  %lncm8 = load i64, i64* %lcba5
  %lncm7 = load i64*, i64** %Sp_Var
  %lncm9 = getelementptr inbounds i64, i64* %lncm7, i32 7
  store i64 %lncm8, i64* %lncm9, !tbaa !2
  %lncmb = load i64, i64* %lcba7
  %lncma = load i64*, i64** %Sp_Var
  %lncmc = getelementptr inbounds i64, i64* %lncma, i32 8
  store i64 %lncmb, i64* %lncmc, !tbaa !2
  %lncme = load i64, i64* %lcba9
  %lncmd = load i64*, i64** %Sp_Var
  %lncmf = getelementptr inbounds i64, i64* %lncmd, i32 9
  store i64 %lncme, i64* %lncmf, !tbaa !2
  %lncmh = load i64*, i64** %Hp_Var
  %lncmi = getelementptr inbounds i64, i64* %lncmh, i32 -5
  %lncmj = ptrtoint i64* %lncmi to i64
  %lncmg = load i64*, i64** %Sp_Var
  %lncmk = getelementptr inbounds i64, i64* %lncmg, i32 10
  store i64 %lncmj, i64* %lncmk, !tbaa !2
  %lncml = load i64*, i64** %Sp_Var
  %lncmm = getelementptr inbounds i64, i64* %lncml, i32 1
  %lncmn = ptrtoint i64* %lncmm to i64
  %lncmo = inttoptr i64 %lncmn to i64*
  store i64* %lncmo, i64** %Sp_Var
  %lncmp = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @_cb9I$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncmq = load i64*, i64** %Sp_Var
  %lncmr = load i64*, i64** %Hp_Var
  %lncms = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncmp( i64* %Base_Arg, i64* %lncmq, i64* %lncmr, i64 %lncms, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cbmb:
  %lncmt = load i64*, i64** %Hp_Var
  %lncmu = getelementptr inbounds i64, i64* %lncmt, i32 -26
  %lncmv = ptrtoint i64* %lncmu to i64
  %lncmw = inttoptr i64 %lncmv to i64*
  store i64* %lncmw, i64** %Hp_Var
  %lncmx = load i64, i64* %lsaFi
  %lncmy = and i64 %lncmx, -8
  store i64 %lncmy, i64* %R1_Var
  %lncmz = load i64*, i64** %Sp_Var
  %lncmA = getelementptr inbounds i64, i64* %lncmz, i32 11
  %lncmB = ptrtoint i64* %lncmA to i64
  %lncmC = inttoptr i64 %lncmB to i64*
  store i64* %lncmC, i64** %Sp_Var
  %lncmE = load i64, i64* %R1_Var
  %lncmF = inttoptr i64 %lncmE to i64*
  %lncmG = load i64, i64* %lncmF, !tbaa !4
  %lncmH = inttoptr i64 %lncmG to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncmI = load i64*, i64** %Sp_Var
  %lncmJ = load i64*, i64** %Hp_Var
  %lncmK = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncmH( i64* %Base_Arg, i64* %lncmI, i64* %lncmJ, i64 %lncmK, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cbm8:
  %lncmL = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 208, i64* %lncmL, !tbaa !5
  %lncmM = load i64, i64* %R1_Var
  store i64 %lncmM, i64* %R1_Var
  %lncmN = bitcast i8* @stg_gc_unpt_r1 to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncmO = load i64*, i64** %Sp_Var
  %lncmP = load i64*, i64** %Hp_Var
  %lncmQ = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncmN( i64* %Base_Arg, i64* %lncmO, i64* %lncmP, i64 %lncmQ, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
%raBP_closure_struct = type <{i64, i64}>
@raBP_closure$def = internal global %raBP_closure_struct<{i64 ptrtoint (i8* @integerzmgmp_GHCziIntegerziType_Szh_con_info to i64), i64 10000000000}>
@raBP_closure = internal alias i8, bitcast (%raBP_closure_struct* @raBP_closure$def to i8*)



==================== LLVM Code ====================
%raBQ_closure_struct = type <{i64, i64, i64, i64}>
@raBQ_closure$def = internal global %raBQ_closure_struct<{i64 ptrtoint (i8* @base_GHCziReal_ZCzv_con_info to i64), i64 add (i64 ptrtoint (%Main_repeatNTimes2_closure_struct* @Main_repeatNTimes2_closure$def to i64),i64 1), i64 add (i64 ptrtoint (%raBP_closure_struct* @raBP_closure$def to i64),i64 1), i64 3}>
@raBQ_closure = internal alias i8, bitcast (%raBQ_closure_struct* @raBQ_closure$def to i8*)



==================== LLVM Code ====================
%ucuI_srt_struct = type <{i64, i64, i64}>
%ucuJ_srt_struct = type <{i64, i64, i64}>
%ucuK_srt_struct = type <{i64, i64, i64}>
%ucuL_srt_struct = type <{i64, i64, i64}>
%ucuM_srt_struct = type <{i64, i64, i64}>
%ucuN_srt_struct = type <{i64, i64, i64, i64}>
%ucuO_srt_struct = type <{i64, i64, i64}>
%ucuP_srt_struct = type <{i64, i64, i64, i64}>
%ucuQ_srt_struct = type <{i64, i64, i64}>
%ucuR_srt_struct = type <{i64, i64, i64}>
%ucuS_srt_struct = type <{i64, i64, i64, i64}>
%ucuT_srt_struct = type <{i64, i64, i64}>
%Main_zdwconjugateGradient_closure_struct = type <{i64, i64, i64, i64, i64}>
@ucuI_srt$def = internal global %ucuI_srt_struct<{i64 ptrtoint (i8* @stg_SRT_1_info to i64), i64 ptrtoint (i8* @hblaszm0zi0zi0zi0zminplace_HBLASziLevel1_axpyzq_closure to i64), i64 0}>
@ucuI_srt = internal alias i8, bitcast (%ucuI_srt_struct* @ucuI_srt$def to i8*)
@ucuJ_srt$def = internal global %ucuJ_srt_struct<{i64 ptrtoint (i8* @stg_SRT_1_info to i64), i64 ptrtoint (i8* @hblaszm0zi0zi0zi0zminplace_HBLASziLevel2_zdwgemvzq_closure to i64), i64 0}>
@ucuJ_srt = internal alias i8, bitcast (%ucuJ_srt_struct* @ucuJ_srt$def to i8*)
@ucuK_srt$def = internal global %ucuK_srt_struct<{i64 ptrtoint (i8* @stg_SRT_1_info to i64), i64 ptrtoint (i8* @ucuJ_srt to i64), i64 0}>
@ucuK_srt = internal alias i8, bitcast (%ucuK_srt_struct* @ucuK_srt$def to i8*)
@ucuL_srt$def = internal global %ucuL_srt_struct<{i64 ptrtoint (i8* @stg_SRT_1_info to i64), i64 ptrtoint (i8* @ucuI_srt to i64), i64 0}>
@ucuL_srt = internal alias i8, bitcast (%ucuL_srt_struct* @ucuL_srt$def to i8*)
@ucuM_srt$def = internal global %ucuM_srt_struct<{i64 ptrtoint (i8* @stg_SRT_1_info to i64), i64 ptrtoint (i8* @ucuL_srt to i64), i64 0}>
@ucuM_srt = internal alias i8, bitcast (%ucuM_srt_struct* @ucuM_srt$def to i8*)
@ucuN_srt$def = internal global %ucuN_srt_struct<{i64 ptrtoint (i8* @stg_SRT_2_info to i64), i64 ptrtoint (i8* @vctrzm0zi12zi0zi2zm9a8f7398_DataziVectorziMutable_uninitialised_closure to i64), i64 ptrtoint (i8* @ucuM_srt to i64), i64 0}>
@ucuN_srt = internal alias i8, bitcast (%ucuN_srt_struct* @ucuN_srt$def to i8*)
@ucuO_srt$def = internal global %ucuO_srt_struct<{i64 ptrtoint (i8* @stg_SRT_1_info to i64), i64 ptrtoint (i8* @ucuN_srt to i64), i64 0}>
@ucuO_srt = internal alias i8, bitcast (%ucuO_srt_struct* @ucuO_srt$def to i8*)
@ucuP_srt$def = internal global %ucuP_srt_struct<{i64 ptrtoint (i8* @stg_SRT_2_info to i64), i64 ptrtoint (i8* @ucuK_srt to i64), i64 ptrtoint (i8* @ucuO_srt to i64), i64 0}>
@ucuP_srt = internal alias i8, bitcast (%ucuP_srt_struct* @ucuP_srt$def to i8*)
@ucuQ_srt$def = internal global %ucuQ_srt_struct<{i64 ptrtoint (i8* @stg_SRT_1_info to i64), i64 ptrtoint (i8* @vctrzm0zi12zi0zi2zm9a8f7398_DataziVectorziMutable_uninitialised_closure to i64), i64 0}>
@ucuQ_srt = internal alias i8, bitcast (%ucuQ_srt_struct* @ucuQ_srt$def to i8*)
@ucuR_srt$def = internal global %ucuR_srt_struct<{i64 ptrtoint (i8* @stg_SRT_1_info to i64), i64 ptrtoint (i8* @ucuQ_srt to i64), i64 0}>
@ucuR_srt = internal alias i8, bitcast (%ucuR_srt_struct* @ucuR_srt$def to i8*)
@ucuS_srt$def = internal global %ucuS_srt_struct<{i64 ptrtoint (i8* @stg_SRT_2_info to i64), i64 ptrtoint (i8* @hblaszm0zi0zi0zi0zminplace_HBLASziLevel2_zdwgemvzq_closure to i64), i64 ptrtoint (i8* @ucuI_srt to i64), i64 0}>
@ucuS_srt = internal alias i8, bitcast (%ucuS_srt_struct* @ucuS_srt$def to i8*)
@ucuT_srt$def = internal global %ucuT_srt_struct<{i64 ptrtoint (i8* @stg_SRT_1_info to i64), i64 ptrtoint (i8* @ucuS_srt to i64), i64 0}>
@ucuT_srt = internal alias i8, bitcast (%ucuT_srt_struct* @ucuT_srt$def to i8*)
@Main_zdwconjugateGradient_closure$def = internal global %Main_zdwconjugateGradient_closure_struct<{i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_zdwconjugateGradient_info$def to i64), i64 ptrtoint (i8* @ucuP_srt to i64), i64 ptrtoint (i8* @ucuR_srt to i64), i64 ptrtoint (i8* @ucuT_srt to i64), i64 0}>
@Main_zdwconjugateGradient_closure = alias i8, bitcast (%Main_zdwconjugateGradient_closure_struct* @Main_zdwconjugateGradient_closure$def to i8*)



==================== LLVM Code ====================
@Main_zdwconjugateGradient_slow = alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_zdwconjugateGradient_slow$def to i8*)
define ghccc void @Main_zdwconjugateGradient_slow$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind
{
ccmS:
  %R6_Var = alloca i64, i32 1
  store i64 undef, i64* %R6_Var
  %R5_Var = alloca i64, i32 1
  store i64 undef, i64* %R5_Var
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lncuU = load i64*, i64** %Sp_Var
  %lncuV = getelementptr inbounds i64, i64* %lncuU, i32 4
  %lncuW = bitcast i64* %lncuV to i64*
  %lncuX = load i64, i64* %lncuW, !tbaa !2
  store i64 %lncuX, i64* %R6_Var
  %lncuY = load i64*, i64** %Sp_Var
  %lncuZ = getelementptr inbounds i64, i64* %lncuY, i32 3
  %lncv0 = bitcast i64* %lncuZ to i64*
  %lncv1 = load i64, i64* %lncv0, !tbaa !2
  store i64 %lncv1, i64* %R5_Var
  %lncv2 = load i64*, i64** %Sp_Var
  %lncv3 = getelementptr inbounds i64, i64* %lncv2, i32 2
  %lncv4 = bitcast i64* %lncv3 to i64*
  %lncv5 = load i64, i64* %lncv4, !tbaa !2
  store i64 %lncv5, i64* %R4_Var
  %lncv6 = load i64*, i64** %Sp_Var
  %lncv7 = getelementptr inbounds i64, i64* %lncv6, i32 1
  %lncv8 = bitcast i64* %lncv7 to i64*
  %lncv9 = load i64, i64* %lncv8, !tbaa !2
  store i64 %lncv9, i64* %R3_Var
  %lncva = load i64*, i64** %Sp_Var
  %lncvb = getelementptr inbounds i64, i64* %lncva, i32 0
  %lncvc = bitcast i64* %lncvb to i64*
  %lncvd = load i64, i64* %lncvc, !tbaa !2
  store i64 %lncvd, i64* %R2_Var
  %lncve = load i64, i64* %R1_Var
  store i64 %lncve, i64* %R1_Var
  %lncvf = load i64*, i64** %Sp_Var
  %lncvg = getelementptr inbounds i64, i64* %lncvf, i32 5
  %lncvh = ptrtoint i64* %lncvg to i64
  %lncvi = inttoptr i64 %lncvh to i64*
  store i64* %lncvi, i64** %Sp_Var
  %lncvj = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_zdwconjugateGradient_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncvk = load i64*, i64** %Sp_Var
  %lncvl = load i64, i64* %R1_Var
  %lncvm = load i64, i64* %R2_Var
  %lncvn = load i64, i64* %R3_Var
  %lncvo = load i64, i64* %R4_Var
  %lncvp = load i64, i64* %R5_Var
  %lncvq = load i64, i64* %R6_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncvj( i64* %Base_Arg, i64* %lncvk, i64* %Hp_Arg, i64 %lncvl, i64 %lncvm, i64 %lncvn, i64 %lncvo, i64 %lncvp, i64 %lncvq, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saI4_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saI4_info$def to i8*)
define internal ghccc void @saI4_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 1, i32 16, i32 0}>
{
ccnN:
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lncvr = load i64*, i64** %Sp_Var
  %lncvs = getelementptr inbounds i64, i64* %lncvr, i32 -2
  %lncvt = ptrtoint i64* %lncvs to i64
  %lncvu = icmp ult i64 %lncvt, %SpLim_Arg
  %lncvv = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lncvu, i1 0 )
  br i1 %lncvv, label %ccnO, label %ccnP
ccnP:
  %lncvx = ptrtoint i8* @stg_upd_frame_info to i64
  %lncvw = load i64*, i64** %Sp_Var
  %lncvy = getelementptr inbounds i64, i64* %lncvw, i32 -2
  store i64 %lncvx, i64* %lncvy, !tbaa !2
  %lncvA = load i64, i64* %R1_Var
  %lncvz = load i64*, i64** %Sp_Var
  %lncvB = getelementptr inbounds i64, i64* %lncvz, i32 -1
  store i64 %lncvA, i64* %lncvB, !tbaa !2
  %lncvE = load i64, i64* %R1_Var
  %lncvF = add i64 %lncvE, 16
  %lncvG = inttoptr i64 %lncvF to i64*
  %lncvH = load i64, i64* %lncvG, !tbaa !4
  store i64 %lncvH, i64* %R2_Var
  %lncvI = load i64*, i64** %Sp_Var
  %lncvJ = getelementptr inbounds i64, i64* %lncvI, i32 -2
  %lncvK = ptrtoint i64* %lncvJ to i64
  %lncvL = inttoptr i64 %lncvK to i64*
  store i64* %lncvL, i64** %Sp_Var
  %lncvM = bitcast i8* @base_GHCziReal_zdp1Fractional_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncvN = load i64*, i64** %Sp_Var
  %lncvO = load i64, i64* %R1_Var
  %lncvP = load i64, i64* %R2_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncvM( i64* %Base_Arg, i64* %lncvN, i64* %Hp_Arg, i64 %lncvO, i64 %lncvP, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ccnO:
  %lncvQ = load i64, i64* %R1_Var
  store i64 %lncvQ, i64* %R1_Var
  %lncvR = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lncvS = bitcast i64* %lncvR to i64*
  %lncvT = load i64, i64* %lncvS, !tbaa !5
  %lncvU = inttoptr i64 %lncvT to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncvV = load i64*, i64** %Sp_Var
  %lncvW = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncvU( i64* %Base_Arg, i64* %lncvV, i64* %Hp_Arg, i64 %lncvW, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saI6_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saI6_info$def to i8*)
define internal ghccc void @saI6_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 1, i32 16, i32 0}>
{
ccnW:
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lncvX = load i64*, i64** %Sp_Var
  %lncvY = getelementptr inbounds i64, i64* %lncvX, i32 -4
  %lncvZ = ptrtoint i64* %lncvY to i64
  %lncw0 = icmp ult i64 %lncvZ, %SpLim_Arg
  %lncw1 = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lncw0, i1 0 )
  br i1 %lncw1, label %ccnX, label %ccnY
ccnY:
  %lncw3 = ptrtoint i8* @stg_upd_frame_info to i64
  %lncw2 = load i64*, i64** %Sp_Var
  %lncw4 = getelementptr inbounds i64, i64* %lncw2, i32 -2
  store i64 %lncw3, i64* %lncw4, !tbaa !2
  %lncw6 = load i64, i64* %R1_Var
  %lncw5 = load i64*, i64** %Sp_Var
  %lncw7 = getelementptr inbounds i64, i64* %lncw5, i32 -1
  store i64 %lncw6, i64* %lncw7, !tbaa !2
  %lncwa = load i64, i64* %R1_Var
  %lncwb = add i64 %lncwa, 16
  %lncwc = inttoptr i64 %lncwb to i64*
  %lncwd = load i64, i64* %lncwc, !tbaa !4
  store i64 %lncwd, i64* %R2_Var
  %lncwf = ptrtoint i8* @stg_ap_p_info to i64
  %lncwe = load i64*, i64** %Sp_Var
  %lncwg = getelementptr inbounds i64, i64* %lncwe, i32 -4
  store i64 %lncwf, i64* %lncwg, !tbaa !2
  %lncwi = ptrtoint %Main_repeatNTimes2_closure_struct* @Main_repeatNTimes2_closure$def to i64
  %lncwj = add i64 %lncwi, 1
  %lncwh = load i64*, i64** %Sp_Var
  %lncwk = getelementptr inbounds i64, i64* %lncwh, i32 -3
  store i64 %lncwj, i64* %lncwk, !tbaa !2
  %lncwl = load i64*, i64** %Sp_Var
  %lncwm = getelementptr inbounds i64, i64* %lncwl, i32 -4
  %lncwn = ptrtoint i64* %lncwm to i64
  %lncwo = inttoptr i64 %lncwn to i64*
  store i64* %lncwo, i64** %Sp_Var
  %lncwp = bitcast i8* @base_GHCziNum_fromInteger_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncwq = load i64*, i64** %Sp_Var
  %lncwr = load i64, i64* %R1_Var
  %lncws = load i64, i64* %R2_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncwp( i64* %Base_Arg, i64* %lncwq, i64* %Hp_Arg, i64 %lncwr, i64 %lncws, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ccnX:
  %lncwt = load i64, i64* %R1_Var
  store i64 %lncwt, i64* %R1_Var
  %lncwu = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lncwv = bitcast i64* %lncwu to i64*
  %lncww = load i64, i64* %lncwv, !tbaa !5
  %lncwx = inttoptr i64 %lncww to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncwy = load i64*, i64** %Sp_Var
  %lncwz = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncwx( i64* %Base_Arg, i64* %lncwy, i64* %Hp_Arg, i64 %lncwz, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saI5_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saI5_info$def to i8*)
define internal ghccc void @saI5_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 1, i32 16, i32 0}>
{
ccnZ:
  %lsaI5 = alloca i64, i32 1
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %lsaI4 = alloca i64, i32 1
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lncwA = load i64, i64* %R1_Var
  store i64 %lncwA, i64* %lsaI5
  %lncwB = load i64*, i64** %Sp_Var
  %lncwC = getelementptr inbounds i64, i64* %lncwB, i32 -4
  %lncwD = ptrtoint i64* %lncwC to i64
  %lncwE = icmp ult i64 %lncwD, %SpLim_Arg
  %lncwF = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lncwE, i1 0 )
  br i1 %lncwF, label %cco0, label %cco1
cco1:
  %lncwG = load i64*, i64** %Hp_Var
  %lncwH = getelementptr inbounds i64, i64* %lncwG, i32 3
  %lncwI = ptrtoint i64* %lncwH to i64
  %lncwJ = inttoptr i64 %lncwI to i64*
  store i64* %lncwJ, i64** %Hp_Var
  %lncwK = load i64*, i64** %Hp_Var
  %lncwL = ptrtoint i64* %lncwK to i64
  %lncwM = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lncwN = bitcast i64* %lncwM to i64*
  %lncwO = load i64, i64* %lncwN, !tbaa !5
  %lncwP = icmp ugt i64 %lncwL, %lncwO
  %lncwQ = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lncwP, i1 0 )
  br i1 %lncwQ, label %cco3, label %cco2
cco2:
  %lncwS = ptrtoint i8* @stg_upd_frame_info to i64
  %lncwR = load i64*, i64** %Sp_Var
  %lncwT = getelementptr inbounds i64, i64* %lncwR, i32 -2
  store i64 %lncwS, i64* %lncwT, !tbaa !2
  %lncwV = load i64, i64* %lsaI5
  %lncwU = load i64*, i64** %Sp_Var
  %lncwW = getelementptr inbounds i64, i64* %lncwU, i32 -1
  store i64 %lncwV, i64* %lncwW, !tbaa !2
  %lncwX = load i64, i64* %lsaI5
  %lncwY = add i64 %lncwX, 16
  %lncwZ = inttoptr i64 %lncwY to i64*
  %lncx0 = load i64, i64* %lncwZ, !tbaa !1
  store i64 %lncx0, i64* %lsaI4
  %lncx2 = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saI6_info$def to i64
  %lncx1 = load i64*, i64** %Hp_Var
  %lncx3 = getelementptr inbounds i64, i64* %lncx1, i32 -2
  store i64 %lncx2, i64* %lncx3, !tbaa !3
  %lncx5 = load i64, i64* %lsaI4
  %lncx4 = load i64*, i64** %Hp_Var
  %lncx6 = getelementptr inbounds i64, i64* %lncx4, i32 0
  store i64 %lncx5, i64* %lncx6, !tbaa !3
  %lncx7 = load i64, i64* %lsaI4
  store i64 %lncx7, i64* %R2_Var
  %lncx9 = ptrtoint i8* @stg_ap_p_info to i64
  %lncx8 = load i64*, i64** %Sp_Var
  %lncxa = getelementptr inbounds i64, i64* %lncx8, i32 -4
  store i64 %lncx9, i64* %lncxa, !tbaa !2
  %lncxc = load i64*, i64** %Hp_Var
  %lncxd = getelementptr inbounds i64, i64* %lncxc, i32 -2
  %lncxe = ptrtoint i64* %lncxd to i64
  %lncxb = load i64*, i64** %Sp_Var
  %lncxf = getelementptr inbounds i64, i64* %lncxb, i32 -3
  store i64 %lncxe, i64* %lncxf, !tbaa !2
  %lncxg = load i64*, i64** %Sp_Var
  %lncxh = getelementptr inbounds i64, i64* %lncxg, i32 -4
  %lncxi = ptrtoint i64* %lncxh to i64
  %lncxj = inttoptr i64 %lncxi to i64*
  store i64* %lncxj, i64** %Sp_Var
  %lncxk = bitcast i8* @base_GHCziNum_negate_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncxl = load i64*, i64** %Sp_Var
  %lncxm = load i64*, i64** %Hp_Var
  %lncxn = load i64, i64* %R1_Var
  %lncxo = load i64, i64* %R2_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncxk( i64* %Base_Arg, i64* %lncxl, i64* %lncxm, i64 %lncxn, i64 %lncxo, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cco3:
  %lncxp = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 24, i64* %lncxp, !tbaa !5
  br label %cco0
cco0:
  %lncxq = load i64, i64* %lsaI5
  store i64 %lncxq, i64* %R1_Var
  %lncxr = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lncxs = bitcast i64* %lncxr to i64*
  %lncxt = load i64, i64* %lncxs, !tbaa !5
  %lncxu = inttoptr i64 %lncxt to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncxv = load i64*, i64** %Sp_Var
  %lncxw = load i64*, i64** %Hp_Var
  %lncxx = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncxu( i64* %Base_Arg, i64* %lncxv, i64* %lncxw, i64 %lncxx, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saI7_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saI7_info$def to i8*)
define internal ghccc void @saI7_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 1, i32 16, i32 0}>
{
cco6:
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lncxy = load i64*, i64** %Sp_Var
  %lncxz = getelementptr inbounds i64, i64* %lncxy, i32 -2
  %lncxA = ptrtoint i64* %lncxz to i64
  %lncxB = icmp ult i64 %lncxA, %SpLim_Arg
  %lncxC = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lncxB, i1 0 )
  br i1 %lncxC, label %cco7, label %cco8
cco8:
  %lncxE = ptrtoint i8* @stg_upd_frame_info to i64
  %lncxD = load i64*, i64** %Sp_Var
  %lncxF = getelementptr inbounds i64, i64* %lncxD, i32 -2
  store i64 %lncxE, i64* %lncxF, !tbaa !2
  %lncxH = load i64, i64* %R1_Var
  %lncxG = load i64*, i64** %Sp_Var
  %lncxI = getelementptr inbounds i64, i64* %lncxG, i32 -1
  store i64 %lncxH, i64* %lncxI, !tbaa !2
  %lncxL = load i64, i64* %R1_Var
  %lncxM = add i64 %lncxL, 16
  %lncxN = inttoptr i64 %lncxM to i64*
  %lncxO = load i64, i64* %lncxN, !tbaa !4
  store i64 %lncxO, i64* %R2_Var
  %lncxP = load i64*, i64** %Sp_Var
  %lncxQ = getelementptr inbounds i64, i64* %lncxP, i32 -2
  %lncxR = ptrtoint i64* %lncxQ to i64
  %lncxS = inttoptr i64 %lncxR to i64*
  store i64* %lncxS, i64** %Sp_Var
  %lncxT = bitcast i8* @base_GHCziFloat_zdp1Floating_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncxU = load i64*, i64** %Sp_Var
  %lncxV = load i64, i64* %R1_Var
  %lncxW = load i64, i64* %R2_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncxT( i64* %Base_Arg, i64* %lncxU, i64* %Hp_Arg, i64 %lncxV, i64 %lncxW, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cco7:
  %lncxX = load i64, i64* %R1_Var
  store i64 %lncxX, i64* %R1_Var
  %lncxY = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lncxZ = bitcast i64* %lncxY to i64*
  %lncy0 = load i64, i64* %lncxZ, !tbaa !5
  %lncy1 = inttoptr i64 %lncy0 to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncy2 = load i64*, i64** %Sp_Var
  %lncy3 = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncy1( i64* %Base_Arg, i64* %lncy2, i64* %Hp_Arg, i64 %lncy3, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saI8_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saI8_info$def to i8*)
define internal ghccc void @saI8_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 1, i32 16, i32 0}>
{
ccob:
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lncy4 = load i64*, i64** %Sp_Var
  %lncy5 = getelementptr inbounds i64, i64* %lncy4, i32 -4
  %lncy6 = ptrtoint i64* %lncy5 to i64
  %lncy7 = icmp ult i64 %lncy6, %SpLim_Arg
  %lncy8 = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lncy7, i1 0 )
  br i1 %lncy8, label %ccoc, label %ccod
ccod:
  %lncya = ptrtoint i8* @stg_upd_frame_info to i64
  %lncy9 = load i64*, i64** %Sp_Var
  %lncyb = getelementptr inbounds i64, i64* %lncy9, i32 -2
  store i64 %lncya, i64* %lncyb, !tbaa !2
  %lncyd = load i64, i64* %R1_Var
  %lncyc = load i64*, i64** %Sp_Var
  %lncye = getelementptr inbounds i64, i64* %lncyc, i32 -1
  store i64 %lncyd, i64* %lncye, !tbaa !2
  %lncyh = load i64, i64* %R1_Var
  %lncyi = add i64 %lncyh, 16
  %lncyj = inttoptr i64 %lncyi to i64*
  %lncyk = load i64, i64* %lncyj, !tbaa !4
  store i64 %lncyk, i64* %R2_Var
  %lncym = ptrtoint i8* @stg_ap_p_info to i64
  %lncyl = load i64*, i64** %Sp_Var
  %lncyn = getelementptr inbounds i64, i64* %lncyl, i32 -4
  store i64 %lncym, i64* %lncyn, !tbaa !2
  %lncyp = ptrtoint %raBQ_closure_struct* @raBQ_closure$def to i64
  %lncyq = add i64 %lncyp, 1
  %lncyo = load i64*, i64** %Sp_Var
  %lncyr = getelementptr inbounds i64, i64* %lncyo, i32 -3
  store i64 %lncyq, i64* %lncyr, !tbaa !2
  %lncys = load i64*, i64** %Sp_Var
  %lncyt = getelementptr inbounds i64, i64* %lncys, i32 -4
  %lncyu = ptrtoint i64* %lncyt to i64
  %lncyv = inttoptr i64 %lncyu to i64*
  store i64* %lncyv, i64** %Sp_Var
  %lncyw = bitcast i8* @base_GHCziReal_fromRational_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncyx = load i64*, i64** %Sp_Var
  %lncyy = load i64, i64* %R1_Var
  %lncyz = load i64, i64* %R2_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncyw( i64* %Base_Arg, i64* %lncyx, i64* %Hp_Arg, i64 %lncyy, i64 %lncyz, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ccoc:
  %lncyA = load i64, i64* %R1_Var
  store i64 %lncyA, i64* %R1_Var
  %lncyB = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lncyC = bitcast i64* %lncyB to i64*
  %lncyD = load i64, i64* %lncyC, !tbaa !5
  %lncyE = inttoptr i64 %lncyD to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncyF = load i64*, i64** %Sp_Var
  %lncyG = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncyE( i64* %Base_Arg, i64* %lncyF, i64* %Hp_Arg, i64 %lncyG, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saI9_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saI9_info$def to i8*)
define internal ghccc void @saI9_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 1, i32 16, i32 0}>
{
ccog:
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lncyH = load i64*, i64** %Sp_Var
  %lncyI = getelementptr inbounds i64, i64* %lncyH, i32 -2
  %lncyJ = ptrtoint i64* %lncyI to i64
  %lncyK = icmp ult i64 %lncyJ, %SpLim_Arg
  %lncyL = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lncyK, i1 0 )
  br i1 %lncyL, label %ccoh, label %ccoi
ccoi:
  %lncyN = ptrtoint i8* @stg_upd_frame_info to i64
  %lncyM = load i64*, i64** %Sp_Var
  %lncyO = getelementptr inbounds i64, i64* %lncyM, i32 -2
  store i64 %lncyN, i64* %lncyO, !tbaa !2
  %lncyQ = load i64, i64* %R1_Var
  %lncyP = load i64*, i64** %Sp_Var
  %lncyR = getelementptr inbounds i64, i64* %lncyP, i32 -1
  store i64 %lncyQ, i64* %lncyR, !tbaa !2
  %lncyU = load i64, i64* %R1_Var
  %lncyV = add i64 %lncyU, 16
  %lncyW = inttoptr i64 %lncyV to i64*
  %lncyX = load i64, i64* %lncyW, !tbaa !4
  store i64 %lncyX, i64* %R2_Var
  %lncyY = load i64*, i64** %Sp_Var
  %lncyZ = getelementptr inbounds i64, i64* %lncyY, i32 -2
  %lncz0 = ptrtoint i64* %lncyZ to i64
  %lncz1 = inttoptr i64 %lncz0 to i64*
  store i64* %lncz1, i64** %Sp_Var
  %lncz2 = bitcast i8* @hblaszm0zi0zi0zi0zminplace_HBLASziLevel1_zdwnrm2_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncz3 = load i64*, i64** %Sp_Var
  %lncz4 = load i64, i64* %R1_Var
  %lncz5 = load i64, i64* %R2_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncz2( i64* %Base_Arg, i64* %lncz3, i64* %Hp_Arg, i64 %lncz4, i64 %lncz5, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ccoh:
  %lncz6 = load i64, i64* %R1_Var
  store i64 %lncz6, i64* %R1_Var
  %lncz7 = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lncz8 = bitcast i64* %lncz7 to i64*
  %lncz9 = load i64, i64* %lncz8, !tbaa !5
  %lncza = inttoptr i64 %lncz9 to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnczb = load i64*, i64** %Sp_Var
  %lnczc = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncza( i64* %Base_Arg, i64* %lnczb, i64* %Hp_Arg, i64 %lnczc, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saIa_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saIa_info$def to i8*)
define internal ghccc void @saIa_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 5, i32 15, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%ucuT_srt_struct* @ucuT_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saIa_info$def to i64)) to i32),i32 0)}>
{
ccoo:
  %lsaI2 = alloca i64, i32 1
  %lsaI3 = alloca i64, i32 1
  %lsaI4 = alloca i64, i32 1
  %lsaI5 = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnczd = load i64*, i64** %Sp_Var
  %lncze = getelementptr inbounds i64, i64* %lnczd, i32 -7
  %lnczf = ptrtoint i64* %lncze to i64
  %lnczg = icmp ult i64 %lnczf, %SpLim_Arg
  %lnczh = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnczg, i1 0 )
  br i1 %lnczh, label %ccos, label %ccot
ccot:
  %lnczj = ptrtoint i8* @stg_upd_frame_info to i64
  %lnczi = load i64*, i64** %Sp_Var
  %lnczk = getelementptr inbounds i64, i64* %lnczi, i32 -2
  store i64 %lnczj, i64* %lnczk, !tbaa !2
  %lnczm = load i64, i64* %R1_Var
  %lnczl = load i64*, i64** %Sp_Var
  %lnczn = getelementptr inbounds i64, i64* %lnczl, i32 -1
  store i64 %lnczm, i64* %lnczn, !tbaa !2
  %lnczp = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccol_info$def to i64
  %lnczo = load i64*, i64** %Sp_Var
  %lnczq = getelementptr inbounds i64, i64* %lnczo, i32 -7
  store i64 %lnczp, i64* %lnczq, !tbaa !2
  %lnczt = load i64, i64* %R1_Var
  %lnczu = add i64 %lnczt, 24
  %lnczv = inttoptr i64 %lnczu to i64*
  %lnczw = load i64, i64* %lnczv, !tbaa !4
  store i64 %lnczw, i64* %lsaI2
  %lnczz = load i64, i64* %R1_Var
  %lnczA = add i64 %lnczz, 32
  %lnczB = inttoptr i64 %lnczA to i64*
  %lnczC = load i64, i64* %lnczB, !tbaa !4
  store i64 %lnczC, i64* %lsaI3
  %lnczF = load i64, i64* %R1_Var
  %lnczG = add i64 %lnczF, 40
  %lnczH = inttoptr i64 %lnczG to i64*
  %lnczI = load i64, i64* %lnczH, !tbaa !4
  store i64 %lnczI, i64* %lsaI4
  %lnczL = load i64, i64* %R1_Var
  %lnczM = add i64 %lnczL, 48
  %lnczN = inttoptr i64 %lnczM to i64*
  %lnczO = load i64, i64* %lnczN, !tbaa !4
  store i64 %lnczO, i64* %lsaI5
  %lnczR = load i64, i64* %R1_Var
  %lnczS = add i64 %lnczR, 16
  %lnczT = inttoptr i64 %lnczS to i64*
  %lnczU = load i64, i64* %lnczT, !tbaa !4
  store i64 %lnczU, i64* %R1_Var
  %lnczW = load i64, i64* %lsaI2
  %lnczV = load i64*, i64** %Sp_Var
  %lnczX = getelementptr inbounds i64, i64* %lnczV, i32 -6
  store i64 %lnczW, i64* %lnczX, !tbaa !2
  %lnczZ = load i64, i64* %lsaI3
  %lnczY = load i64*, i64** %Sp_Var
  %lncA0 = getelementptr inbounds i64, i64* %lnczY, i32 -5
  store i64 %lnczZ, i64* %lncA0, !tbaa !2
  %lncA2 = load i64, i64* %lsaI4
  %lncA1 = load i64*, i64** %Sp_Var
  %lncA3 = getelementptr inbounds i64, i64* %lncA1, i32 -4
  store i64 %lncA2, i64* %lncA3, !tbaa !2
  %lncA5 = load i64, i64* %lsaI5
  %lncA4 = load i64*, i64** %Sp_Var
  %lncA6 = getelementptr inbounds i64, i64* %lncA4, i32 -3
  store i64 %lncA5, i64* %lncA6, !tbaa !2
  %lncA7 = load i64*, i64** %Sp_Var
  %lncA8 = getelementptr inbounds i64, i64* %lncA7, i32 -7
  %lncA9 = ptrtoint i64* %lncA8 to i64
  %lncAa = inttoptr i64 %lncA9 to i64*
  store i64* %lncAa, i64** %Sp_Var
  %lncAb = load i64, i64* %R1_Var
  %lncAc = and i64 %lncAb, 7
  %lncAd = icmp ne i64 %lncAc, 0
  br i1 %lncAd, label %ucoz, label %ccom
ccom:
  %lncAf = load i64, i64* %R1_Var
  %lncAg = inttoptr i64 %lncAf to i64*
  %lncAh = load i64, i64* %lncAg, !tbaa !4
  %lncAi = inttoptr i64 %lncAh to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncAj = load i64*, i64** %Sp_Var
  %lncAk = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncAi( i64* %Base_Arg, i64* %lncAj, i64* %Hp_Arg, i64 %lncAk, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ucoz:
  %lncAl = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccol_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncAm = load i64*, i64** %Sp_Var
  %lncAn = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncAl( i64* %Base_Arg, i64* %lncAm, i64* %Hp_Arg, i64 %lncAn, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ccos:
  %lncAo = load i64, i64* %R1_Var
  store i64 %lncAo, i64* %R1_Var
  %lncAp = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lncAq = bitcast i64* %lncAp to i64*
  %lncAr = load i64, i64* %lncAq, !tbaa !5
  %lncAs = inttoptr i64 %lncAr to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncAt = load i64*, i64** %Sp_Var
  %lncAu = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncAs( i64* %Base_Arg, i64* %lncAt, i64* %Hp_Arg, i64 %lncAu, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@ccol_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccol_info$def to i8*)
define internal ghccc void @ccol_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 4, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%ucuS_srt_struct* @ucuS_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccol_info$def to i64)) to i32),i32 0)}>
{
ccol:
  %R6_Var = alloca i64, i32 1
  store i64 undef, i64* %R6_Var
  %R5_Var = alloca i64, i32 1
  store i64 undef, i64* %R5_Var
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %lncAv = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccor_info$def to i64
  %lncAw = getelementptr inbounds i64, i64* %Sp_Arg, i32 0
  store i64 %lncAv, i64* %lncAw, !tbaa !2
  %lncAx = getelementptr inbounds i64, i64* %Sp_Arg, i32 2
  %lncAy = bitcast i64* %lncAx to i64*
  %lncAz = load i64, i64* %lncAy, !tbaa !2
  store i64 %lncAz, i64* %R6_Var
  %lncAA = add i64 %R1_Arg, 7
  %lncAB = inttoptr i64 %lncAA to i64*
  %lncAC = load i64, i64* %lncAB, !tbaa !4
  store i64 %lncAC, i64* %R5_Var
  %lncAD = add i64 %R1_Arg, 23
  %lncAE = inttoptr i64 %lncAD to i64*
  %lncAF = load i64, i64* %lncAE, !tbaa !4
  store i64 %lncAF, i64* %R4_Var
  %lncAG = add i64 %R1_Arg, 15
  %lncAH = inttoptr i64 %lncAG to i64*
  %lncAI = load i64, i64* %lncAH, !tbaa !4
  store i64 %lncAI, i64* %R3_Var
  %lncAJ = getelementptr inbounds i64, i64* %Sp_Arg, i32 3
  %lncAK = bitcast i64* %lncAJ to i64*
  %lncAL = load i64, i64* %lncAK, !tbaa !2
  store i64 %lncAL, i64* %R2_Var
  %lncAM = bitcast i8* @hblaszm0zi0zi0zi0zminplace_HBLASziLevel2_zdwgemvzq_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncAN = load i64, i64* %R2_Var
  %lncAO = load i64, i64* %R3_Var
  %lncAP = load i64, i64* %R4_Var
  %lncAQ = load i64, i64* %R5_Var
  %lncAR = load i64, i64* %R6_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncAM( i64* %Base_Arg, i64* %Sp_Arg, i64* %Hp_Arg, i64 %R1_Arg, i64 %lncAN, i64 %lncAO, i64 %lncAP, i64 %lncAQ, i64 %lncAR, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@ccor_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccor_info$def to i8*)
define internal ghccc void @ccor_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 4, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%ucuI_srt_struct* @ucuI_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccor_info$def to i64)) to i32),i32 0)}>
{
ccor:
  %R6_Var = alloca i64, i32 1
  store i64 undef, i64* %R6_Var
  %R5_Var = alloca i64, i32 1
  store i64 undef, i64* %R5_Var
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lncAS = load i64*, i64** %Sp_Var
  %lncAT = getelementptr inbounds i64, i64* %lncAS, i32 1
  %lncAU = bitcast i64* %lncAT to i64*
  %lncAV = load i64, i64* %lncAU, !tbaa !2
  store i64 %lncAV, i64* %R6_Var
  %lncAW = load i64*, i64** %Sp_Var
  %lncAX = getelementptr inbounds i64, i64* %lncAW, i32 2
  %lncAY = bitcast i64* %lncAX to i64*
  %lncAZ = load i64, i64* %lncAY, !tbaa !2
  store i64 %lncAZ, i64* %R5_Var
  store i64 %R1_Arg, i64* %R4_Var
  %lncB0 = load i64*, i64** %Sp_Var
  %lncB1 = getelementptr inbounds i64, i64* %lncB0, i32 4
  %lncB2 = bitcast i64* %lncB1 to i64*
  %lncB3 = load i64, i64* %lncB2, !tbaa !2
  store i64 %lncB3, i64* %R3_Var
  %lncB4 = load i64*, i64** %Sp_Var
  %lncB5 = getelementptr inbounds i64, i64* %lncB4, i32 3
  %lncB6 = bitcast i64* %lncB5 to i64*
  %lncB7 = load i64, i64* %lncB6, !tbaa !2
  store i64 %lncB7, i64* %R2_Var
  %lncB8 = load i64*, i64** %Sp_Var
  %lncB9 = getelementptr inbounds i64, i64* %lncB8, i32 5
  %lncBa = ptrtoint i64* %lncB9 to i64
  %lncBb = inttoptr i64 %lncBa to i64*
  store i64* %lncBb, i64** %Sp_Var
  %lncBc = bitcast i8* @hblaszm0zi0zi0zi0zminplace_HBLASziLevel1_axpyzq_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncBd = load i64*, i64** %Sp_Var
  %lncBe = load i64, i64* %R2_Var
  %lncBf = load i64, i64* %R3_Var
  %lncBg = load i64, i64* %R4_Var
  %lncBh = load i64, i64* %R5_Var
  %lncBi = load i64, i64* %R6_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncBc( i64* %Base_Arg, i64* %lncBd, i64* %Hp_Arg, i64 %R1_Arg, i64 %lncBe, i64 %lncBf, i64 %lncBg, i64 %lncBh, i64 %lncBi, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saIo_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saIo_info$def to i8*)
define internal ghccc void @saIo_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 2, i32 18, i32 0}>
{
ccoN:
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lncBj = load i64*, i64** %Sp_Var
  %lncBk = getelementptr inbounds i64, i64* %lncBj, i32 -4
  %lncBl = ptrtoint i64* %lncBk to i64
  %lncBm = icmp ult i64 %lncBl, %SpLim_Arg
  %lncBn = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lncBm, i1 0 )
  br i1 %lncBn, label %ccoO, label %ccoP
ccoP:
  %lncBp = ptrtoint i8* @stg_upd_frame_info to i64
  %lncBo = load i64*, i64** %Sp_Var
  %lncBq = getelementptr inbounds i64, i64* %lncBo, i32 -2
  store i64 %lncBp, i64* %lncBq, !tbaa !2
  %lncBs = load i64, i64* %R1_Var
  %lncBr = load i64*, i64** %Sp_Var
  %lncBt = getelementptr inbounds i64, i64* %lncBr, i32 -1
  store i64 %lncBs, i64* %lncBt, !tbaa !2
  %lncBw = load i64, i64* %R1_Var
  %lncBx = add i64 %lncBw, 16
  %lncBy = inttoptr i64 %lncBx to i64*
  %lncBz = load i64, i64* %lncBy, !tbaa !4
  store i64 %lncBz, i64* %R2_Var
  %lncBB = ptrtoint i8* @stg_ap_p_info to i64
  %lncBA = load i64*, i64** %Sp_Var
  %lncBC = getelementptr inbounds i64, i64* %lncBA, i32 -4
  store i64 %lncBB, i64* %lncBC, !tbaa !2
  %lncBG = load i64, i64* %R1_Var
  %lncBH = add i64 %lncBG, 24
  %lncBI = inttoptr i64 %lncBH to i64*
  %lncBJ = load i64, i64* %lncBI, !tbaa !4
  %lncBD = load i64*, i64** %Sp_Var
  %lncBK = getelementptr inbounds i64, i64* %lncBD, i32 -3
  store i64 %lncBJ, i64* %lncBK, !tbaa !2
  %lncBL = load i64*, i64** %Sp_Var
  %lncBM = getelementptr inbounds i64, i64* %lncBL, i32 -4
  %lncBN = ptrtoint i64* %lncBM to i64
  %lncBO = inttoptr i64 %lncBN to i64*
  store i64* %lncBO, i64** %Sp_Var
  %lncBP = bitcast i8* @base_GHCziNum_zt_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncBQ = load i64*, i64** %Sp_Var
  %lncBR = load i64, i64* %R1_Var
  %lncBS = load i64, i64* %R2_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncBP( i64* %Base_Arg, i64* %lncBQ, i64* %Hp_Arg, i64 %lncBR, i64 %lncBS, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ccoO:
  %lncBT = load i64, i64* %R1_Var
  store i64 %lncBT, i64* %R1_Var
  %lncBU = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lncBV = bitcast i64* %lncBU to i64*
  %lncBW = load i64, i64* %lncBV, !tbaa !5
  %lncBX = inttoptr i64 %lncBW to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncBY = load i64*, i64** %Sp_Var
  %lncBZ = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncBX( i64* %Base_Arg, i64* %lncBY, i64* %Hp_Arg, i64 %lncBZ, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saIg_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saIg_info$def to i8*)
define internal ghccc void @saIg_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 3, i32 15, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%ucuR_srt_struct* @ucuR_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saIg_info$def to i64)) to i32),i32 0)}>
{
ccoQ:
  %lsaI4 = alloca i64, i32 1
  %lsaI5 = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lncC0 = load i64*, i64** %Sp_Var
  %lncC1 = getelementptr inbounds i64, i64* %lncC0, i32 -10
  %lncC2 = ptrtoint i64* %lncC1 to i64
  %lncC3 = icmp ult i64 %lncC2, %SpLim_Arg
  %lncC4 = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lncC3, i1 0 )
  br i1 %lncC4, label %ccoR, label %ccoS
ccoS:
  %lncC6 = ptrtoint i8* @stg_upd_frame_info to i64
  %lncC5 = load i64*, i64** %Sp_Var
  %lncC7 = getelementptr inbounds i64, i64* %lncC5, i32 -2
  store i64 %lncC6, i64* %lncC7, !tbaa !2
  %lncC9 = load i64, i64* %R1_Var
  %lncC8 = load i64*, i64** %Sp_Var
  %lncCa = getelementptr inbounds i64, i64* %lncC8, i32 -1
  store i64 %lncC9, i64* %lncCa, !tbaa !2
  %lncCc = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccoC_info$def to i64
  %lncCb = load i64*, i64** %Sp_Var
  %lncCd = getelementptr inbounds i64, i64* %lncCb, i32 -5
  store i64 %lncCc, i64* %lncCd, !tbaa !2
  %lncCg = load i64, i64* %R1_Var
  %lncCh = add i64 %lncCg, 16
  %lncCi = inttoptr i64 %lncCh to i64*
  %lncCj = load i64, i64* %lncCi, !tbaa !4
  store i64 %lncCj, i64* %lsaI4
  %lncCm = load i64, i64* %R1_Var
  %lncCn = add i64 %lncCm, 24
  %lncCo = inttoptr i64 %lncCn to i64*
  %lncCp = load i64, i64* %lncCo, !tbaa !4
  store i64 %lncCp, i64* %lsaI5
  %lncCs = load i64, i64* %R1_Var
  %lncCt = add i64 %lncCs, 32
  %lncCu = inttoptr i64 %lncCt to i64*
  %lncCv = load i64, i64* %lncCu, !tbaa !4
  store i64 %lncCv, i64* %R1_Var
  %lncCx = load i64, i64* %lsaI4
  %lncCw = load i64*, i64** %Sp_Var
  %lncCy = getelementptr inbounds i64, i64* %lncCw, i32 -4
  store i64 %lncCx, i64* %lncCy, !tbaa !2
  %lncCA = load i64, i64* %lsaI5
  %lncCz = load i64*, i64** %Sp_Var
  %lncCB = getelementptr inbounds i64, i64* %lncCz, i32 -3
  store i64 %lncCA, i64* %lncCB, !tbaa !2
  %lncCC = load i64*, i64** %Sp_Var
  %lncCD = getelementptr inbounds i64, i64* %lncCC, i32 -5
  %lncCE = ptrtoint i64* %lncCD to i64
  %lncCF = inttoptr i64 %lncCE to i64*
  store i64* %lncCF, i64** %Sp_Var
  %lncCG = load i64, i64* %R1_Var
  %lncCH = and i64 %lncCG, 7
  %lncCI = icmp ne i64 %lncCH, 0
  br i1 %lncCI, label %ucpB, label %ccoD
ccoD:
  %lncCK = load i64, i64* %R1_Var
  %lncCL = inttoptr i64 %lncCK to i64*
  %lncCM = load i64, i64* %lncCL, !tbaa !4
  %lncCN = inttoptr i64 %lncCM to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncCO = load i64*, i64** %Sp_Var
  %lncCP = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncCN( i64* %Base_Arg, i64* %lncCO, i64* %Hp_Arg, i64 %lncCP, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ucpB:
  %lncCQ = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccoC_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncCR = load i64*, i64** %Sp_Var
  %lncCS = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncCQ( i64* %Base_Arg, i64* %lncCR, i64* %Hp_Arg, i64 %lncCS, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ccoR:
  %lncCT = load i64, i64* %R1_Var
  store i64 %lncCT, i64* %R1_Var
  %lncCU = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lncCV = bitcast i64* %lncCU to i64*
  %lncCW = load i64, i64* %lncCV, !tbaa !5
  %lncCX = inttoptr i64 %lncCW to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncCY = load i64*, i64** %Sp_Var
  %lncCZ = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncCX( i64* %Base_Arg, i64* %lncCY, i64* %Hp_Arg, i64 %lncCZ, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@ccoC_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccoC_info$def to i8*)
define internal ghccc void @ccoC_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 2, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%ucuQ_srt_struct* @ucuQ_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccoC_info$def to i64)) to i32),i32 0)}>
{
ccoC:
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %lsaIk = alloca i64, i32 1
  %lsaIi = alloca i64, i32 1
  %lsaIj = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lncD1 = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccoH_info$def to i64
  %lncD0 = load i64*, i64** %Sp_Var
  %lncD2 = getelementptr inbounds i64, i64* %lncD0, i32 -3
  store i64 %lncD1, i64* %lncD2, !tbaa !2
  %lncD3 = ptrtoint i8* @vctrzm0zi12zi0zi2zm9a8f7398_DataziVectorziMutable_uninitialised_closure to i64
  store i64 %lncD3, i64* %R2_Var
  %lncD6 = load i64, i64* %R1_Var
  %lncD7 = add i64 %lncD6, 7
  %lncD8 = inttoptr i64 %lncD7 to i64*
  %lncD9 = load i64, i64* %lncD8, !tbaa !4
  store i64 %lncD9, i64* %lsaIk
  %lncDc = load i64, i64* %R1_Var
  %lncDd = add i64 %lncDc, 15
  %lncDe = inttoptr i64 %lncDd to i64*
  %lncDf = load i64, i64* %lncDe, !tbaa !4
  store i64 %lncDf, i64* %lsaIi
  %lncDi = load i64, i64* %R1_Var
  %lncDj = add i64 %lncDi, 23
  %lncDk = inttoptr i64 %lncDj to i64*
  %lncDl = load i64, i64* %lncDk, !tbaa !4
  store i64 %lncDl, i64* %lsaIj
  %lncDm = load i64, i64* %lsaIj
  store i64 %lncDm, i64* %R1_Var
  %lncDo = load i64, i64* %lsaIj
  %lncDn = load i64*, i64** %Sp_Var
  %lncDp = getelementptr inbounds i64, i64* %lncDn, i32 -2
  store i64 %lncDo, i64* %lncDp, !tbaa !2
  %lncDr = load i64, i64* %lsaIk
  %lncDq = load i64*, i64** %Sp_Var
  %lncDs = getelementptr inbounds i64, i64* %lncDq, i32 -1
  store i64 %lncDr, i64* %lncDs, !tbaa !2
  %lncDu = load i64, i64* %lsaIi
  %lncDt = load i64*, i64** %Sp_Var
  %lncDv = getelementptr inbounds i64, i64* %lncDt, i32 0
  store i64 %lncDu, i64* %lncDv, !tbaa !2
  %lncDw = load i64*, i64** %Sp_Var
  %lncDx = getelementptr inbounds i64, i64* %lncDw, i32 -3
  %lncDy = ptrtoint i64* %lncDx to i64
  %lncDz = inttoptr i64 %lncDy to i64*
  store i64* %lncDz, i64** %Sp_Var
  %lncDA = bitcast i8* @stg_newArrayzh to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncDB = load i64*, i64** %Sp_Var
  %lncDC = load i64, i64* %R1_Var
  %lncDD = load i64, i64* %R2_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncDA( i64* %Base_Arg, i64* %lncDB, i64* %Hp_Arg, i64 %lncDC, i64 %lncDD, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@ccoH_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccoH_info$def to i8*)
define internal ghccc void @ccoH_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 325, i32 30, i32 0}>
{
ccoH:
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lncDE = load i64*, i64** %Hp_Var
  %lncDF = getelementptr inbounds i64, i64* %lncDE, i32 4
  %lncDG = ptrtoint i64* %lncDF to i64
  %lncDH = inttoptr i64 %lncDG to i64*
  store i64* %lncDH, i64** %Hp_Var
  %lncDI = load i64*, i64** %Hp_Var
  %lncDJ = ptrtoint i64* %lncDI to i64
  %lncDK = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lncDL = bitcast i64* %lncDK to i64*
  %lncDM = load i64, i64* %lncDL, !tbaa !5
  %lncDN = icmp ugt i64 %lncDJ, %lncDM
  %lncDO = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lncDN, i1 0 )
  br i1 %lncDO, label %ccoW, label %ccoV
ccoV:
  %lncDQ = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saIo_info$def to i64
  %lncDP = load i64*, i64** %Hp_Var
  %lncDR = getelementptr inbounds i64, i64* %lncDP, i32 -3
  store i64 %lncDQ, i64* %lncDR, !tbaa !3
  %lncDT = load i64*, i64** %Sp_Var
  %lncDU = getelementptr inbounds i64, i64* %lncDT, i32 4
  %lncDV = bitcast i64* %lncDU to i64*
  %lncDW = load i64, i64* %lncDV, !tbaa !2
  %lncDS = load i64*, i64** %Hp_Var
  %lncDX = getelementptr inbounds i64, i64* %lncDS, i32 -1
  store i64 %lncDW, i64* %lncDX, !tbaa !3
  %lncDZ = load i64*, i64** %Sp_Var
  %lncE0 = getelementptr inbounds i64, i64* %lncDZ, i32 5
  %lncE1 = bitcast i64* %lncE0 to i64*
  %lncE2 = load i64, i64* %lncE1, !tbaa !2
  %lncDY = load i64*, i64** %Hp_Var
  %lncE3 = getelementptr inbounds i64, i64* %lncDY, i32 0
  store i64 %lncE2, i64* %lncE3, !tbaa !3
  %lncE4 = load i64*, i64** %Sp_Var
  %lncE5 = getelementptr inbounds i64, i64* %lncE4, i32 -1
  store i64 0, i64* %lncE5, !tbaa !2
  %lncE6 = load i64*, i64** %Sp_Var
  %lncE7 = getelementptr inbounds i64, i64* %lncE6, i32 0
  store i64 0, i64* %lncE7, !tbaa !2
  %lncE9 = load i64, i64* %R1_Var
  %lncE8 = load i64*, i64** %Sp_Var
  %lncEa = getelementptr inbounds i64, i64* %lncE8, i32 4
  store i64 %lncE9, i64* %lncEa, !tbaa !2
  %lncEc = load i64*, i64** %Hp_Var
  %lncEd = getelementptr inbounds i64, i64* %lncEc, i32 -3
  %lncEe = ptrtoint i64* %lncEd to i64
  %lncEb = load i64*, i64** %Sp_Var
  %lncEf = getelementptr inbounds i64, i64* %lncEb, i32 5
  store i64 %lncEe, i64* %lncEf, !tbaa !2
  %lncEg = load i64*, i64** %Sp_Var
  %lncEh = getelementptr inbounds i64, i64* %lncEg, i32 -2
  %lncEi = ptrtoint i64* %lncEh to i64
  %lncEj = inttoptr i64 %lncEi to i64*
  store i64* %lncEj, i64** %Sp_Var
  %lncEk = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccp7_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncEl = load i64*, i64** %Sp_Var
  %lncEm = load i64*, i64** %Hp_Var
  %lncEn = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncEk( i64* %Base_Arg, i64* %lncEl, i64* %lncEm, i64 %lncEn, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ccoW:
  %lncEo = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 32, i64* %lncEo, !tbaa !5
  %lncEp = load i64, i64* %R1_Var
  store i64 %lncEp, i64* %R1_Var
  %lncEq = bitcast i8* @stg_gc_unpt_r1 to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncEr = load i64*, i64** %Sp_Var
  %lncEs = load i64*, i64** %Hp_Var
  %lncEt = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncEq( i64* %Base_Arg, i64* %lncEr, i64* %lncEs, i64 %lncEt, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@ccp7_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccp7_info$def to i8*)
define internal ghccc void @ccp7_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 1479, i32 30, i32 0}>
{
ccp7:
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %lsaIy = alloca i64, i32 1
  %lsaIz = alloca i64, i32 1
  %lsaIn = alloca i64, i32 1
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R5_Var = alloca i64, i32 1
  store i64 undef, i64* %R5_Var
  %R6_Var = alloca i64, i32 1
  store i64 undef, i64* %R6_Var
  %F1_Var = alloca float, i32 1
  store float undef, float* %F1_Var
  %D1_Var = alloca double, i32 1
  store double undef, double* %D1_Var
  %F2_Var = alloca float, i32 1
  store float undef, float* %F2_Var
  %D2_Var = alloca double, i32 1
  store double undef, double* %D2_Var
  %F3_Var = alloca float, i32 1
  store float undef, float* %F3_Var
  %D3_Var = alloca double, i32 1
  store double undef, double* %D3_Var
  %F4_Var = alloca float, i32 1
  store float undef, float* %F4_Var
  %D4_Var = alloca double, i32 1
  store double undef, double* %D4_Var
  %F5_Var = alloca float, i32 1
  store float undef, float* %F5_Var
  %D5_Var = alloca double, i32 1
  store double undef, double* %D5_Var
  %F6_Var = alloca float, i32 1
  store float undef, float* %F6_Var
  %D6_Var = alloca double, i32 1
  store double undef, double* %D6_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lncEu = load i64*, i64** %Hp_Var
  %lncEv = getelementptr inbounds i64, i64* %lncEu, i32 4
  %lncEw = ptrtoint i64* %lncEv to i64
  %lncEx = inttoptr i64 %lncEw to i64*
  store i64* %lncEx, i64** %Hp_Var
  %lncEy = load i64*, i64** %Hp_Var
  %lncEz = ptrtoint i64* %lncEy to i64
  %lncEA = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lncEB = bitcast i64* %lncEA to i64*
  %lncEC = load i64, i64* %lncEB, !tbaa !5
  %lncED = icmp ugt i64 %lncEz, %lncEC
  %lncEE = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lncED, i1 0 )
  br i1 %lncEE, label %ccpc, label %ccpb
ccpb:
  %lncEF = load i64*, i64** %Sp_Var
  %lncEG = getelementptr inbounds i64, i64* %lncEF, i32 2
  %lncEH = bitcast i64* %lncEG to i64*
  %lncEI = load i64, i64* %lncEH, !tbaa !2
  store i64 %lncEI, i64* %lsaIy
  %lncEJ = load i64*, i64** %Sp_Var
  %lncEK = getelementptr inbounds i64, i64* %lncEJ, i32 1
  %lncEL = bitcast i64* %lncEK to i64*
  %lncEM = load i64, i64* %lncEL, !tbaa !2
  store i64 %lncEM, i64* %lsaIz
  %lncEN = load i64, i64* %lsaIy
  %lncEO = load i64*, i64** %Sp_Var
  %lncEP = getelementptr inbounds i64, i64* %lncEO, i32 3
  %lncEQ = bitcast i64* %lncEP to i64*
  %lncER = load i64, i64* %lncEQ, !tbaa !2
  %lncES = icmp sge i64 %lncEN, %lncER
  %lncET = zext i1 %lncES to i64
  switch i64 %lncET, label %ccpg [i64 1, label %ccph]
ccpg:
  %lncEV = ptrtoint i8* @stg_ap_2_upd_info to i64
  %lncEU = load i64*, i64** %Hp_Var
  %lncEW = getelementptr inbounds i64, i64* %lncEU, i32 -3
  store i64 %lncEV, i64* %lncEW, !tbaa !3
  %lncEY = load i64*, i64** %Sp_Var
  %lncEZ = getelementptr inbounds i64, i64* %lncEY, i32 7
  %lncF0 = bitcast i64* %lncEZ to i64*
  %lncF1 = load i64, i64* %lncF0, !tbaa !2
  %lncEX = load i64*, i64** %Hp_Var
  %lncF2 = getelementptr inbounds i64, i64* %lncEX, i32 -1
  store i64 %lncF1, i64* %lncF2, !tbaa !3
  %lncF4 = load i64*, i64** %Sp_Var
  %lncF5 = getelementptr inbounds i64, i64* %lncF4, i32 4
  %lncF6 = bitcast i64* %lncF5 to i64*
  %lncF7 = load i64, i64* %lncF6, !tbaa !2
  %lncF8 = load i64*, i64** %Sp_Var
  %lncF9 = getelementptr inbounds i64, i64* %lncF8, i32 5
  %lncFa = bitcast i64* %lncF9 to i64*
  %lncFb = load i64, i64* %lncFa, !tbaa !2
  %lncFc = load i64, i64* %lsaIy
  %lncFd = add i64 %lncFb, %lncFc
  %lncFe = shl i64 %lncFd, 3
  %lncFf = add i64 %lncFe, 24
  %lncFg = add i64 %lncF7, %lncFf
  %lncFh = inttoptr i64 %lncFg to i64*
  %lncFi = load i64, i64* %lncFh, !tbaa !1
  %lncF3 = load i64*, i64** %Hp_Var
  %lncFj = getelementptr inbounds i64, i64* %lncF3, i32 0
  store i64 %lncFi, i64* %lncFj, !tbaa !3
  %lncFk = load i64*, i64** %Sp_Var
  %lncFl = getelementptr inbounds i64, i64* %lncFk, i32 6
  %lncFm = bitcast i64* %lncFl to i64*
  %lncFn = load i64, i64* %lncFm, !tbaa !2
  store i64 %lncFn, i64* %lsaIn
  %lncFo = load i64, i64* %lsaIn
  %lncFp = add i64 %lncFo, 24
  %lncFq = load i64, i64* %lsaIz
  %lncFr = shl i64 %lncFq, 3
  %lncFs = add i64 %lncFp, %lncFr
  %lncFt = load i64*, i64** %Hp_Var
  %lncFu = getelementptr inbounds i64, i64* %lncFt, i32 -3
  %lncFv = ptrtoint i64* %lncFu to i64
  %lncFw = inttoptr i64 %lncFs to i64*
  store i64 %lncFv, i64* %lncFw, !tbaa !1
  %lncFx = load i64, i64* %lsaIn
  %lncFy = ptrtoint i8* @stg_MUT_ARR_PTRS_DIRTY_info to i64
  %lncFz = inttoptr i64 %lncFx to i64*
  store i64 %lncFy, i64* %lncFz, !tbaa !1
  %lncFA = load i64, i64* %lsaIn
  %lncFB = add i64 %lncFA, 24
  %lncFC = load i64, i64* %lsaIn
  %lncFD = add i64 %lncFC, 8
  %lncFE = inttoptr i64 %lncFD to i64*
  %lncFF = load i64, i64* %lncFE, !tbaa !1
  %lncFG = shl i64 %lncFF, 3
  %lncFH = load i64, i64* %lsaIz
  %lncFI = lshr i64 %lncFH, 7
  %lncFJ = add i64 %lncFG, %lncFI
  %lncFK = add i64 %lncFB, %lncFJ
  %lncFL = inttoptr i64 %lncFK to i8*
  store i8 1, i8* %lncFL, !tbaa !1
  %lncFN = load i64, i64* %lsaIy
  %lncFO = add i64 %lncFN, 1
  %lncFM = load i64*, i64** %Sp_Var
  %lncFP = getelementptr inbounds i64, i64* %lncFM, i32 2
  store i64 %lncFO, i64* %lncFP, !tbaa !2
  %lncFR = load i64, i64* %lsaIz
  %lncFS = add i64 %lncFR, 1
  %lncFQ = load i64*, i64** %Sp_Var
  %lncFT = getelementptr inbounds i64, i64* %lncFQ, i32 1
  store i64 %lncFS, i64* %lncFT, !tbaa !2
  %lncFU = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccp7_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncFV = load i64*, i64** %Sp_Var
  %lncFW = load i64*, i64** %Hp_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncFU( i64* %Base_Arg, i64* %lncFV, i64* %lncFW, i64 %R1_Arg, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ccph:
  %lncFX = load i64*, i64** %Hp_Var
  %lncFY = getelementptr inbounds i64, i64* %lncFX, i32 -4
  %lncFZ = ptrtoint i64* %lncFY to i64
  %lncG0 = inttoptr i64 %lncFZ to i64*
  store i64* %lncG0, i64** %Hp_Var
  %lncG2 = load i64, i64* %lsaIz
  %lncG1 = load i64*, i64** %Sp_Var
  %lncG3 = getelementptr inbounds i64, i64* %lncG1, i32 7
  store i64 %lncG2, i64* %lncG3, !tbaa !2
  %lncG4 = load i64*, i64** %Sp_Var
  %lncG5 = getelementptr inbounds i64, i64* %lncG4, i32 6
  %lncG6 = ptrtoint i64* %lncG5 to i64
  %lncG7 = inttoptr i64 %lncG6 to i64*
  store i64* %lncG7, i64** %Sp_Var
  %lncG8 = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @_ccp0$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncG9 = load i64*, i64** %Sp_Var
  %lncGa = load i64*, i64** %Hp_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncG8( i64* %Base_Arg, i64* %lncG9, i64* %lncGa, i64 %R1_Arg, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ccpc:
  %lncGb = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 32, i64* %lncGb, !tbaa !5
  %lncGd = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccp7_info$def to i64
  %lncGc = load i64*, i64** %Sp_Var
  %lncGe = getelementptr inbounds i64, i64* %lncGc, i32 0
  store i64 %lncGd, i64* %lncGe, !tbaa !2
  %lncGf = bitcast i8* @stg_gc_noregs to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncGg = load i64*, i64** %Sp_Var
  %lncGh = load i64*, i64** %Hp_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncGf( i64* %Base_Arg, i64* %lncGg, i64* %lncGh, i64 %R1_Arg, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@_ccp0 = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @_ccp0$def to i8*)
define internal ghccc void @_ccp0$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind
{
ccp0:
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %lsaIr = alloca i64, i32 1
  %lsaIn = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lncGi = load i64*, i64** %Hp_Var
  %lncGj = getelementptr inbounds i64, i64* %lncGi, i32 4
  %lncGk = ptrtoint i64* %lncGj to i64
  %lncGl = inttoptr i64 %lncGk to i64*
  store i64* %lncGl, i64** %Hp_Var
  %lncGm = load i64*, i64** %Sp_Var
  %lncGn = getelementptr inbounds i64, i64* %lncGm, i32 1
  %lncGo = bitcast i64* %lncGn to i64*
  %lncGp = load i64, i64* %lncGo, !tbaa !2
  store i64 %lncGp, i64* %lsaIr
  %lncGq = load i64*, i64** %Hp_Var
  %lncGr = ptrtoint i64* %lncGq to i64
  %lncGs = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lncGt = bitcast i64* %lncGs to i64*
  %lncGu = load i64, i64* %lncGt, !tbaa !5
  %lncGv = icmp ugt i64 %lncGr, %lncGu
  %lncGw = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lncGv, i1 0 )
  br i1 %lncGw, label %ccp4, label %ccp3
ccp3:
  %lncGx = load i64*, i64** %Sp_Var
  %lncGy = getelementptr inbounds i64, i64* %lncGx, i32 0
  %lncGz = bitcast i64* %lncGy to i64*
  %lncGA = load i64, i64* %lncGz, !tbaa !2
  store i64 %lncGA, i64* %lsaIn
  %lncGB = load i64, i64* %lsaIn
  %lncGC = ptrtoint i8* @stg_MUT_ARR_PTRS_FROZEN_DIRTY_info to i64
  %lncGD = inttoptr i64 %lncGB to i64*
  store i64 %lncGC, i64* %lncGD, !tbaa !1
  %lncGF = ptrtoint i8* @vctrzm0zi12zi0zi2zm9a8f7398_DataziVector_Vector_con_info to i64
  %lncGE = load i64*, i64** %Hp_Var
  %lncGG = getelementptr inbounds i64, i64* %lncGE, i32 -3
  store i64 %lncGF, i64* %lncGG, !tbaa !3
  %lncGI = load i64, i64* %lsaIn
  %lncGH = load i64*, i64** %Hp_Var
  %lncGJ = getelementptr inbounds i64, i64* %lncGH, i32 -2
  store i64 %lncGI, i64* %lncGJ, !tbaa !3
  %lncGK = load i64*, i64** %Hp_Var
  %lncGL = getelementptr inbounds i64, i64* %lncGK, i32 -1
  store i64 0, i64* %lncGL, !tbaa !3
  %lncGN = load i64, i64* %lsaIr
  %lncGM = load i64*, i64** %Hp_Var
  %lncGO = getelementptr inbounds i64, i64* %lncGM, i32 0
  store i64 %lncGN, i64* %lncGO, !tbaa !3
  %lncGQ = load i64*, i64** %Hp_Var
  %lncGR = ptrtoint i64* %lncGQ to i64
  %lncGS = add i64 %lncGR, -23
  %lncGT = and i64 %lncGS, -8
  store i64 %lncGT, i64* %R1_Var
  %lncGU = load i64*, i64** %Sp_Var
  %lncGV = getelementptr inbounds i64, i64* %lncGU, i32 2
  %lncGW = ptrtoint i64* %lncGV to i64
  %lncGX = inttoptr i64 %lncGW to i64*
  store i64* %lncGX, i64** %Sp_Var
  %lncGZ = load i64, i64* %R1_Var
  %lncH0 = inttoptr i64 %lncGZ to i64*
  %lncH1 = load i64, i64* %lncH0, !tbaa !4
  %lncH2 = inttoptr i64 %lncH1 to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncH3 = load i64*, i64** %Sp_Var
  %lncH4 = load i64*, i64** %Hp_Var
  %lncH5 = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncH2( i64* %Base_Arg, i64* %lncH3, i64* %lncH4, i64 %lncH5, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ccp4:
  %lncH6 = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 32, i64* %lncH6, !tbaa !5
  %lncH8 = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccoZ_info$def to i64
  %lncH7 = load i64*, i64** %Sp_Var
  %lncH9 = getelementptr inbounds i64, i64* %lncH7, i32 -1
  store i64 %lncH8, i64* %lncH9, !tbaa !2
  %lncHa = load i64, i64* %lsaIr
  store i64 %lncHa, i64* %R1_Var
  %lncHb = load i64*, i64** %Sp_Var
  %lncHc = getelementptr inbounds i64, i64* %lncHb, i32 -1
  %lncHd = ptrtoint i64* %lncHc to i64
  %lncHe = inttoptr i64 %lncHd to i64*
  store i64* %lncHe, i64** %Sp_Var
  %lncHf = bitcast i8* @stg_gc_unbx_r1 to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncHg = load i64*, i64** %Sp_Var
  %lncHh = load i64*, i64** %Hp_Var
  %lncHi = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncHf( i64* %Base_Arg, i64* %lncHg, i64* %lncHh, i64 %lncHi, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@ccoZ_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccoZ_info$def to i8*)
define internal ghccc void @ccoZ_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 130, i32 30, i32 0}>
{
ccoZ:
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lncHj = load i64*, i64** %Sp_Var
  %lncHk = getelementptr inbounds i64, i64* %lncHj, i32 2
  store i64 %R1_Arg, i64* %lncHk, !tbaa !2
  %lncHl = load i64*, i64** %Sp_Var
  %lncHm = getelementptr inbounds i64, i64* %lncHl, i32 1
  %lncHn = ptrtoint i64* %lncHm to i64
  %lncHo = inttoptr i64 %lncHn to i64*
  store i64* %lncHo, i64** %Sp_Var
  %lncHp = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @_ccp0$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncHq = load i64*, i64** %Sp_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncHp( i64* %Base_Arg, i64* %lncHq, i64* %Hp_Arg, i64 %R1_Arg, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saIL_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saIL_info$def to i8*)
define internal ghccc void @saIL_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 3, i32 15, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%ucuK_srt_struct* @ucuK_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saIL_info$def to i64)) to i32),i32 0)}>
{
ccpK:
  %lsaI4 = alloca i64, i32 1
  %lsaIg = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lncHr = load i64*, i64** %Sp_Var
  %lncHs = getelementptr inbounds i64, i64* %lncHr, i32 -5
  %lncHt = ptrtoint i64* %lncHs to i64
  %lncHu = icmp ult i64 %lncHt, %SpLim_Arg
  %lncHv = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lncHu, i1 0 )
  br i1 %lncHv, label %ccpL, label %ccpM
ccpM:
  %lncHx = ptrtoint i8* @stg_upd_frame_info to i64
  %lncHw = load i64*, i64** %Sp_Var
  %lncHy = getelementptr inbounds i64, i64* %lncHw, i32 -2
  store i64 %lncHx, i64* %lncHy, !tbaa !2
  %lncHA = load i64, i64* %R1_Var
  %lncHz = load i64*, i64** %Sp_Var
  %lncHB = getelementptr inbounds i64, i64* %lncHz, i32 -1
  store i64 %lncHA, i64* %lncHB, !tbaa !2
  %lncHD = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccpH_info$def to i64
  %lncHC = load i64*, i64** %Sp_Var
  %lncHE = getelementptr inbounds i64, i64* %lncHC, i32 -5
  store i64 %lncHD, i64* %lncHE, !tbaa !2
  %lncHH = load i64, i64* %R1_Var
  %lncHI = add i64 %lncHH, 24
  %lncHJ = inttoptr i64 %lncHI to i64*
  %lncHK = load i64, i64* %lncHJ, !tbaa !4
  store i64 %lncHK, i64* %lsaI4
  %lncHN = load i64, i64* %R1_Var
  %lncHO = add i64 %lncHN, 32
  %lncHP = inttoptr i64 %lncHO to i64*
  %lncHQ = load i64, i64* %lncHP, !tbaa !4
  store i64 %lncHQ, i64* %lsaIg
  %lncHT = load i64, i64* %R1_Var
  %lncHU = add i64 %lncHT, 16
  %lncHV = inttoptr i64 %lncHU to i64*
  %lncHW = load i64, i64* %lncHV, !tbaa !4
  store i64 %lncHW, i64* %R1_Var
  %lncHY = load i64, i64* %lsaI4
  %lncHX = load i64*, i64** %Sp_Var
  %lncHZ = getelementptr inbounds i64, i64* %lncHX, i32 -4
  store i64 %lncHY, i64* %lncHZ, !tbaa !2
  %lncI1 = load i64, i64* %lsaIg
  %lncI0 = load i64*, i64** %Sp_Var
  %lncI2 = getelementptr inbounds i64, i64* %lncI0, i32 -3
  store i64 %lncI1, i64* %lncI2, !tbaa !2
  %lncI3 = load i64*, i64** %Sp_Var
  %lncI4 = getelementptr inbounds i64, i64* %lncI3, i32 -5
  %lncI5 = ptrtoint i64* %lncI4 to i64
  %lncI6 = inttoptr i64 %lncI5 to i64*
  store i64* %lncI6, i64** %Sp_Var
  %lncI7 = load i64, i64* %R1_Var
  %lncI8 = and i64 %lncI7, 7
  %lncI9 = icmp ne i64 %lncI8, 0
  br i1 %lncI9, label %ucpQ, label %ccpI
ccpI:
  %lncIb = load i64, i64* %R1_Var
  %lncIc = inttoptr i64 %lncIb to i64*
  %lncId = load i64, i64* %lncIc, !tbaa !4
  %lncIe = inttoptr i64 %lncId to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncIf = load i64*, i64** %Sp_Var
  %lncIg = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncIe( i64* %Base_Arg, i64* %lncIf, i64* %Hp_Arg, i64 %lncIg, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ucpQ:
  %lncIh = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccpH_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncIi = load i64*, i64** %Sp_Var
  %lncIj = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncIh( i64* %Base_Arg, i64* %lncIi, i64* %Hp_Arg, i64 %lncIj, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ccpL:
  %lncIk = load i64, i64* %R1_Var
  store i64 %lncIk, i64* %R1_Var
  %lncIl = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lncIm = bitcast i64* %lncIl to i64*
  %lncIn = load i64, i64* %lncIm, !tbaa !5
  %lncIo = inttoptr i64 %lncIn to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncIp = load i64*, i64** %Sp_Var
  %lncIq = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncIo( i64* %Base_Arg, i64* %lncIp, i64* %Hp_Arg, i64 %lncIq, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@ccpH_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccpH_info$def to i8*)
define internal ghccc void @ccpH_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 2, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%ucuJ_srt_struct* @ucuJ_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccpH_info$def to i64)) to i32),i32 0)}>
{
ccpH:
  %R6_Var = alloca i64, i32 1
  store i64 undef, i64* %R6_Var
  %R5_Var = alloca i64, i32 1
  store i64 undef, i64* %R5_Var
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lncIr = load i64*, i64** %Sp_Var
  %lncIs = getelementptr inbounds i64, i64* %lncIr, i32 2
  %lncIt = bitcast i64* %lncIs to i64*
  %lncIu = load i64, i64* %lncIt, !tbaa !2
  store i64 %lncIu, i64* %R6_Var
  %lncIv = add i64 %R1_Arg, 7
  %lncIw = inttoptr i64 %lncIv to i64*
  %lncIx = load i64, i64* %lncIw, !tbaa !4
  store i64 %lncIx, i64* %R5_Var
  %lncIy = add i64 %R1_Arg, 23
  %lncIz = inttoptr i64 %lncIy to i64*
  %lncIA = load i64, i64* %lncIz, !tbaa !4
  store i64 %lncIA, i64* %R4_Var
  %lncIB = add i64 %R1_Arg, 15
  %lncIC = inttoptr i64 %lncIB to i64*
  %lncID = load i64, i64* %lncIC, !tbaa !4
  store i64 %lncID, i64* %R3_Var
  %lncIE = load i64*, i64** %Sp_Var
  %lncIF = getelementptr inbounds i64, i64* %lncIE, i32 1
  %lncIG = bitcast i64* %lncIF to i64*
  %lncIH = load i64, i64* %lncIG, !tbaa !2
  store i64 %lncIH, i64* %R2_Var
  %lncII = load i64*, i64** %Sp_Var
  %lncIJ = getelementptr inbounds i64, i64* %lncII, i32 3
  %lncIK = ptrtoint i64* %lncIJ to i64
  %lncIL = inttoptr i64 %lncIK to i64*
  store i64* %lncIL, i64** %Sp_Var
  %lncIM = bitcast i8* @hblaszm0zi0zi0zi0zminplace_HBLASziLevel2_zdwgemvzq_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncIN = load i64*, i64** %Sp_Var
  %lncIO = load i64, i64* %R2_Var
  %lncIP = load i64, i64* %R3_Var
  %lncIQ = load i64, i64* %R4_Var
  %lncIR = load i64, i64* %R5_Var
  %lncIS = load i64, i64* %R6_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncIM( i64* %Base_Arg, i64* %lncIN, i64* %Hp_Arg, i64 %R1_Arg, i64 %lncIO, i64 %lncIP, i64 %lncIQ, i64 %lncIR, i64 %lncIS, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saIQ_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saIQ_info$def to i8*)
define internal ghccc void @saIQ_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 3, i32 15, i32 0}>
{
ccpW:
  %lsaIg = alloca i64, i32 1
  %lsaIL = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lncIT = load i64*, i64** %Sp_Var
  %lncIU = getelementptr inbounds i64, i64* %lncIT, i32 -9
  %lncIV = ptrtoint i64* %lncIU to i64
  %lncIW = icmp ult i64 %lncIV, %SpLim_Arg
  %lncIX = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lncIW, i1 0 )
  br i1 %lncIX, label %ccq5, label %ccq6
ccq6:
  %lncIZ = ptrtoint i8* @stg_upd_frame_info to i64
  %lncIY = load i64*, i64** %Sp_Var
  %lncJ0 = getelementptr inbounds i64, i64* %lncIY, i32 -2
  store i64 %lncIZ, i64* %lncJ0, !tbaa !2
  %lncJ2 = load i64, i64* %R1_Var
  %lncJ1 = load i64*, i64** %Sp_Var
  %lncJ3 = getelementptr inbounds i64, i64* %lncJ1, i32 -1
  store i64 %lncJ2, i64* %lncJ3, !tbaa !2
  %lncJ5 = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccpT_info$def to i64
  %lncJ4 = load i64*, i64** %Sp_Var
  %lncJ6 = getelementptr inbounds i64, i64* %lncJ4, i32 -5
  store i64 %lncJ5, i64* %lncJ6, !tbaa !2
  %lncJ9 = load i64, i64* %R1_Var
  %lncJa = add i64 %lncJ9, 24
  %lncJb = inttoptr i64 %lncJa to i64*
  %lncJc = load i64, i64* %lncJb, !tbaa !4
  store i64 %lncJc, i64* %lsaIg
  %lncJf = load i64, i64* %R1_Var
  %lncJg = add i64 %lncJf, 32
  %lncJh = inttoptr i64 %lncJg to i64*
  %lncJi = load i64, i64* %lncJh, !tbaa !4
  store i64 %lncJi, i64* %lsaIL
  %lncJl = load i64, i64* %R1_Var
  %lncJm = add i64 %lncJl, 16
  %lncJn = inttoptr i64 %lncJm to i64*
  %lncJo = load i64, i64* %lncJn, !tbaa !4
  store i64 %lncJo, i64* %R1_Var
  %lncJq = load i64, i64* %lsaIg
  %lncJp = load i64*, i64** %Sp_Var
  %lncJr = getelementptr inbounds i64, i64* %lncJp, i32 -4
  store i64 %lncJq, i64* %lncJr, !tbaa !2
  %lncJt = load i64, i64* %lsaIL
  %lncJs = load i64*, i64** %Sp_Var
  %lncJu = getelementptr inbounds i64, i64* %lncJs, i32 -3
  store i64 %lncJt, i64* %lncJu, !tbaa !2
  %lncJv = load i64*, i64** %Sp_Var
  %lncJw = getelementptr inbounds i64, i64* %lncJv, i32 -5
  %lncJx = ptrtoint i64* %lncJw to i64
  %lncJy = inttoptr i64 %lncJx to i64*
  store i64* %lncJy, i64** %Sp_Var
  %lncJz = load i64, i64* %R1_Var
  %lncJA = and i64 %lncJz, 7
  %lncJB = icmp ne i64 %lncJA, 0
  br i1 %lncJB, label %ucqf, label %ccpU
ccpU:
  %lncJD = load i64, i64* %R1_Var
  %lncJE = inttoptr i64 %lncJD to i64*
  %lncJF = load i64, i64* %lncJE, !tbaa !4
  %lncJG = inttoptr i64 %lncJF to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncJH = load i64*, i64** %Sp_Var
  %lncJI = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncJG( i64* %Base_Arg, i64* %lncJH, i64* %Hp_Arg, i64 %lncJI, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ucqf:
  %lncJJ = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccpT_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncJK = load i64*, i64** %Sp_Var
  %lncJL = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncJJ( i64* %Base_Arg, i64* %lncJK, i64* %Hp_Arg, i64 %lncJL, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ccq5:
  %lncJM = load i64, i64* %R1_Var
  store i64 %lncJM, i64* %R1_Var
  %lncJN = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lncJO = bitcast i64* %lncJN to i64*
  %lncJP = load i64, i64* %lncJO, !tbaa !5
  %lncJQ = inttoptr i64 %lncJP to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncJR = load i64*, i64** %Sp_Var
  %lncJS = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncJQ( i64* %Base_Arg, i64* %lncJR, i64* %Hp_Arg, i64 %lncJS, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@ccpT_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccpT_info$def to i8*)
define internal ghccc void @ccpT_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 2, i32 30, i32 0}>
{
ccpT:
  %lsaIS = alloca i64, i32 1
  %lsaIU = alloca i64, i32 1
  %lsaIY = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lncJU = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccpZ_info$def to i64
  %lncJT = load i64*, i64** %Sp_Var
  %lncJV = getelementptr inbounds i64, i64* %lncJT, i32 -2
  store i64 %lncJU, i64* %lncJV, !tbaa !2
  %lncJY = load i64, i64* %R1_Var
  %lncJZ = add i64 %lncJY, 7
  %lncK0 = inttoptr i64 %lncJZ to i64*
  %lncK1 = load i64, i64* %lncK0, !tbaa !4
  store i64 %lncK1, i64* %lsaIS
  %lncK4 = load i64, i64* %R1_Var
  %lncK5 = add i64 %lncK4, 23
  %lncK6 = inttoptr i64 %lncK5 to i64*
  %lncK7 = load i64, i64* %lncK6, !tbaa !4
  store i64 %lncK7, i64* %lsaIU
  %lncKa = load i64, i64* %R1_Var
  %lncKb = add i64 %lncKa, 55
  %lncKc = inttoptr i64 %lncKb to i64*
  %lncKd = load i64, i64* %lncKc, !tbaa !4
  store i64 %lncKd, i64* %lsaIY
  %lncKe = load i64*, i64** %Sp_Var
  %lncKf = getelementptr inbounds i64, i64* %lncKe, i32 1
  %lncKg = bitcast i64* %lncKf to i64*
  %lncKh = load i64, i64* %lncKg, !tbaa !2
  store i64 %lncKh, i64* %R1_Var
  %lncKj = load i64, i64* %lsaIY
  %lncKi = load i64*, i64** %Sp_Var
  %lncKk = getelementptr inbounds i64, i64* %lncKi, i32 -1
  store i64 %lncKj, i64* %lncKk, !tbaa !2
  %lncKm = load i64, i64* %lsaIU
  %lncKl = load i64*, i64** %Sp_Var
  %lncKn = getelementptr inbounds i64, i64* %lncKl, i32 0
  store i64 %lncKm, i64* %lncKn, !tbaa !2
  %lncKp = load i64, i64* %lsaIS
  %lncKo = load i64*, i64** %Sp_Var
  %lncKq = getelementptr inbounds i64, i64* %lncKo, i32 1
  store i64 %lncKp, i64* %lncKq, !tbaa !2
  %lncKr = load i64*, i64** %Sp_Var
  %lncKs = getelementptr inbounds i64, i64* %lncKr, i32 -2
  %lncKt = ptrtoint i64* %lncKs to i64
  %lncKu = inttoptr i64 %lncKt to i64*
  store i64* %lncKu, i64** %Sp_Var
  %lncKv = load i64, i64* %R1_Var
  %lncKw = and i64 %lncKv, 7
  %lncKx = icmp ne i64 %lncKw, 0
  br i1 %lncKx, label %ucqe, label %ccq0
ccq0:
  %lncKz = load i64, i64* %R1_Var
  %lncKA = inttoptr i64 %lncKz to i64*
  %lncKB = load i64, i64* %lncKA, !tbaa !4
  %lncKC = inttoptr i64 %lncKB to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncKD = load i64*, i64** %Sp_Var
  %lncKE = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncKC( i64* %Base_Arg, i64* %lncKD, i64* %Hp_Arg, i64 %lncKE, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ucqe:
  %lncKF = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccpZ_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncKG = load i64*, i64** %Sp_Var
  %lncKH = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncKF( i64* %Base_Arg, i64* %lncKG, i64* %Hp_Arg, i64 %lncKH, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@ccpZ_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccpZ_info$def to i8*)
define internal ghccc void @ccpZ_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 4, i32 30, i32 0}>
{
ccpZ:
  %lsaJ2 = alloca i64, i32 1
  %lsaJ0 = alloca i64, i32 1
  %lsaJ1 = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lncKJ = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccq4_info$def to i64
  %lncKI = load i64*, i64** %Sp_Var
  %lncKK = getelementptr inbounds i64, i64* %lncKI, i32 -2
  store i64 %lncKJ, i64* %lncKK, !tbaa !2
  %lncKN = load i64, i64* %R1_Var
  %lncKO = add i64 %lncKN, 7
  %lncKP = inttoptr i64 %lncKO to i64*
  %lncKQ = load i64, i64* %lncKP, !tbaa !4
  store i64 %lncKQ, i64* %lsaJ2
  %lncKT = load i64, i64* %R1_Var
  %lncKU = add i64 %lncKT, 15
  %lncKV = inttoptr i64 %lncKU to i64*
  %lncKW = load i64, i64* %lncKV, !tbaa !4
  store i64 %lncKW, i64* %lsaJ0
  %lncKZ = load i64, i64* %R1_Var
  %lncL0 = add i64 %lncKZ, 23
  %lncL1 = inttoptr i64 %lncL0 to i64*
  %lncL2 = load i64, i64* %lncL1, !tbaa !4
  store i64 %lncL2, i64* %lsaJ1
  %lncL3 = load i64*, i64** %Sp_Var
  %lncL4 = getelementptr inbounds i64, i64* %lncL3, i32 4
  %lncL5 = bitcast i64* %lncL4 to i64*
  %lncL6 = load i64, i64* %lncL5, !tbaa !2
  store i64 %lncL6, i64* %R1_Var
  %lncL8 = load i64, i64* %lsaJ2
  %lncL7 = load i64*, i64** %Sp_Var
  %lncL9 = getelementptr inbounds i64, i64* %lncL7, i32 -1
  store i64 %lncL8, i64* %lncL9, !tbaa !2
  %lncLb = load i64, i64* %lsaJ1
  %lncLa = load i64*, i64** %Sp_Var
  %lncLc = getelementptr inbounds i64, i64* %lncLa, i32 0
  store i64 %lncLb, i64* %lncLc, !tbaa !2
  %lncLe = load i64, i64* %lsaJ0
  %lncLd = load i64*, i64** %Sp_Var
  %lncLf = getelementptr inbounds i64, i64* %lncLd, i32 4
  store i64 %lncLe, i64* %lncLf, !tbaa !2
  %lncLg = load i64*, i64** %Sp_Var
  %lncLh = getelementptr inbounds i64, i64* %lncLg, i32 -2
  %lncLi = ptrtoint i64* %lncLh to i64
  %lncLj = inttoptr i64 %lncLi to i64*
  store i64* %lncLj, i64** %Sp_Var
  %lncLk = load i64, i64* %R1_Var
  %lncLl = and i64 %lncLk, 7
  %lncLm = icmp ne i64 %lncLl, 0
  br i1 %lncLm, label %ucqg, label %ccq9
ccq9:
  %lncLo = load i64, i64* %R1_Var
  %lncLp = inttoptr i64 %lncLo to i64*
  %lncLq = load i64, i64* %lncLp, !tbaa !4
  %lncLr = inttoptr i64 %lncLq to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncLs = load i64*, i64** %Sp_Var
  %lncLt = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncLr( i64* %Base_Arg, i64* %lncLs, i64* %Hp_Arg, i64 %lncLt, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ucqg:
  %lncLu = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccq4_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncLv = load i64*, i64** %Sp_Var
  %lncLw = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncLu( i64* %Base_Arg, i64* %lncLv, i64* %Hp_Arg, i64 %lncLw, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@ccq4_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccq4_info$def to i8*)
define internal ghccc void @ccq4_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 2182, i32 30, i32 0}>
{
ccq4:
  %R6_Var = alloca i64, i32 1
  store i64 undef, i64* %R6_Var
  %R5_Var = alloca i64, i32 1
  store i64 undef, i64* %R5_Var
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lncLx = load i64*, i64** %Sp_Var
  %lncLy = getelementptr inbounds i64, i64* %lncLx, i32 2
  %lncLz = bitcast i64* %lncLy to i64*
  %lncLA = load i64, i64* %lncLz, !tbaa !2
  store i64 %lncLA, i64* %R6_Var
  %lncLB = load i64*, i64** %Sp_Var
  %lncLC = getelementptr inbounds i64, i64* %lncLB, i32 6
  %lncLD = bitcast i64* %lncLC to i64*
  %lncLE = load i64, i64* %lncLD, !tbaa !2
  store i64 %lncLE, i64* %R5_Var
  %lncLF = load i64*, i64** %Sp_Var
  %lncLG = getelementptr inbounds i64, i64* %lncLF, i32 3
  %lncLH = bitcast i64* %lncLG to i64*
  %lncLI = load i64, i64* %lncLH, !tbaa !2
  store i64 %lncLI, i64* %R4_Var
  %lncLJ = load i64*, i64** %Sp_Var
  %lncLK = getelementptr inbounds i64, i64* %lncLJ, i32 4
  %lncLL = bitcast i64* %lncLK to i64*
  %lncLM = load i64, i64* %lncLL, !tbaa !2
  store i64 %lncLM, i64* %R3_Var
  %lncLN = load i64*, i64** %Sp_Var
  %lncLO = getelementptr inbounds i64, i64* %lncLN, i32 5
  %lncLP = bitcast i64* %lncLO to i64*
  %lncLQ = load i64, i64* %lncLP, !tbaa !2
  store i64 %lncLQ, i64* %R2_Var
  %lncLS = load i64*, i64** %Sp_Var
  %lncLT = getelementptr inbounds i64, i64* %lncLS, i32 1
  %lncLU = bitcast i64* %lncLT to i64*
  %lncLV = load i64, i64* %lncLU, !tbaa !2
  %lncLR = load i64*, i64** %Sp_Var
  %lncLW = getelementptr inbounds i64, i64* %lncLR, i32 3
  store i64 %lncLV, i64* %lncLW, !tbaa !2
  %lncLY = add i64 %R1_Arg, 15
  %lncLZ = inttoptr i64 %lncLY to i64*
  %lncM0 = load i64, i64* %lncLZ, !tbaa !4
  %lncLX = load i64*, i64** %Sp_Var
  %lncM1 = getelementptr inbounds i64, i64* %lncLX, i32 4
  store i64 %lncM0, i64* %lncM1, !tbaa !2
  %lncM3 = add i64 %R1_Arg, 23
  %lncM4 = inttoptr i64 %lncM3 to i64*
  %lncM5 = load i64, i64* %lncM4, !tbaa !4
  %lncM2 = load i64*, i64** %Sp_Var
  %lncM6 = getelementptr inbounds i64, i64* %lncM2, i32 5
  store i64 %lncM5, i64* %lncM6, !tbaa !2
  %lncM8 = add i64 %R1_Arg, 7
  %lncM9 = inttoptr i64 %lncM8 to i64*
  %lncMa = load i64, i64* %lncM9, !tbaa !4
  %lncM7 = load i64*, i64** %Sp_Var
  %lncMb = getelementptr inbounds i64, i64* %lncM7, i32 6
  store i64 %lncMa, i64* %lncMb, !tbaa !2
  %lncMc = load i64*, i64** %Sp_Var
  %lncMd = getelementptr inbounds i64, i64* %lncMc, i32 3
  %lncMe = ptrtoint i64* %lncMd to i64
  %lncMf = inttoptr i64 %lncMe to i64*
  store i64* %lncMf, i64** %Sp_Var
  %lncMg = bitcast i8* @hblaszm0zi0zi0zi0zminplace_HBLASziLevel1_zdwdot_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncMh = load i64*, i64** %Sp_Var
  %lncMi = load i64, i64* %R2_Var
  %lncMj = load i64, i64* %R3_Var
  %lncMk = load i64, i64* %R4_Var
  %lncMl = load i64, i64* %R5_Var
  %lncMm = load i64, i64* %R6_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncMg( i64* %Base_Arg, i64* %lncMh, i64* %Hp_Arg, i64 %R1_Arg, i64 %lncMi, i64 %lncMj, i64 %lncMk, i64 %lncMl, i64 %lncMm, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saJo_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saJo_info$def to i8*)
define internal ghccc void @saJo_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 3, i32 15, i32 0}>
{
ccqq:
  %lsaIa = alloca i64, i32 1
  %lsaIg = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lncMn = load i64*, i64** %Sp_Var
  %lncMo = getelementptr inbounds i64, i64* %lncMn, i32 -9
  %lncMp = ptrtoint i64* %lncMo to i64
  %lncMq = icmp ult i64 %lncMp, %SpLim_Arg
  %lncMr = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lncMq, i1 0 )
  br i1 %lncMr, label %ccqz, label %ccqA
ccqA:
  %lncMt = ptrtoint i8* @stg_upd_frame_info to i64
  %lncMs = load i64*, i64** %Sp_Var
  %lncMu = getelementptr inbounds i64, i64* %lncMs, i32 -2
  store i64 %lncMt, i64* %lncMu, !tbaa !2
  %lncMw = load i64, i64* %R1_Var
  %lncMv = load i64*, i64** %Sp_Var
  %lncMx = getelementptr inbounds i64, i64* %lncMv, i32 -1
  store i64 %lncMw, i64* %lncMx, !tbaa !2
  %lncMz = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccqn_info$def to i64
  %lncMy = load i64*, i64** %Sp_Var
  %lncMA = getelementptr inbounds i64, i64* %lncMy, i32 -5
  store i64 %lncMz, i64* %lncMA, !tbaa !2
  %lncMD = load i64, i64* %R1_Var
  %lncME = add i64 %lncMD, 24
  %lncMF = inttoptr i64 %lncME to i64*
  %lncMG = load i64, i64* %lncMF, !tbaa !4
  store i64 %lncMG, i64* %lsaIa
  %lncMJ = load i64, i64* %R1_Var
  %lncMK = add i64 %lncMJ, 32
  %lncML = inttoptr i64 %lncMK to i64*
  %lncMM = load i64, i64* %lncML, !tbaa !4
  store i64 %lncMM, i64* %lsaIg
  %lncMP = load i64, i64* %R1_Var
  %lncMQ = add i64 %lncMP, 16
  %lncMR = inttoptr i64 %lncMQ to i64*
  %lncMS = load i64, i64* %lncMR, !tbaa !4
  store i64 %lncMS, i64* %R1_Var
  %lncMU = load i64, i64* %lsaIa
  %lncMT = load i64*, i64** %Sp_Var
  %lncMV = getelementptr inbounds i64, i64* %lncMT, i32 -4
  store i64 %lncMU, i64* %lncMV, !tbaa !2
  %lncMX = load i64, i64* %lsaIg
  %lncMW = load i64*, i64** %Sp_Var
  %lncMY = getelementptr inbounds i64, i64* %lncMW, i32 -3
  store i64 %lncMX, i64* %lncMY, !tbaa !2
  %lncMZ = load i64*, i64** %Sp_Var
  %lncN0 = getelementptr inbounds i64, i64* %lncMZ, i32 -5
  %lncN1 = ptrtoint i64* %lncN0 to i64
  %lncN2 = inttoptr i64 %lncN1 to i64*
  store i64* %lncN2, i64** %Sp_Var
  %lncN3 = load i64, i64* %R1_Var
  %lncN4 = and i64 %lncN3, 7
  %lncN5 = icmp ne i64 %lncN4, 0
  br i1 %lncN5, label %ucqJ, label %ccqo
ccqo:
  %lncN7 = load i64, i64* %R1_Var
  %lncN8 = inttoptr i64 %lncN7 to i64*
  %lncN9 = load i64, i64* %lncN8, !tbaa !4
  %lncNa = inttoptr i64 %lncN9 to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncNb = load i64*, i64** %Sp_Var
  %lncNc = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncNa( i64* %Base_Arg, i64* %lncNb, i64* %Hp_Arg, i64 %lncNc, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ucqJ:
  %lncNd = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccqn_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncNe = load i64*, i64** %Sp_Var
  %lncNf = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncNd( i64* %Base_Arg, i64* %lncNe, i64* %Hp_Arg, i64 %lncNf, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ccqz:
  %lncNg = load i64, i64* %R1_Var
  store i64 %lncNg, i64* %R1_Var
  %lncNh = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lncNi = bitcast i64* %lncNh to i64*
  %lncNj = load i64, i64* %lncNi, !tbaa !5
  %lncNk = inttoptr i64 %lncNj to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncNl = load i64*, i64** %Sp_Var
  %lncNm = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncNk( i64* %Base_Arg, i64* %lncNl, i64* %Hp_Arg, i64 %lncNm, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@ccqn_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccqn_info$def to i8*)
define internal ghccc void @ccqn_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 2, i32 30, i32 0}>
{
ccqn:
  %lsaJ9 = alloca i64, i32 1
  %lsaJb = alloca i64, i32 1
  %lsaJf = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lncNo = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccqt_info$def to i64
  %lncNn = load i64*, i64** %Sp_Var
  %lncNp = getelementptr inbounds i64, i64* %lncNn, i32 -2
  store i64 %lncNo, i64* %lncNp, !tbaa !2
  %lncNs = load i64, i64* %R1_Var
  %lncNt = add i64 %lncNs, 7
  %lncNu = inttoptr i64 %lncNt to i64*
  %lncNv = load i64, i64* %lncNu, !tbaa !4
  store i64 %lncNv, i64* %lsaJ9
  %lncNy = load i64, i64* %R1_Var
  %lncNz = add i64 %lncNy, 23
  %lncNA = inttoptr i64 %lncNz to i64*
  %lncNB = load i64, i64* %lncNA, !tbaa !4
  store i64 %lncNB, i64* %lsaJb
  %lncNE = load i64, i64* %R1_Var
  %lncNF = add i64 %lncNE, 55
  %lncNG = inttoptr i64 %lncNF to i64*
  %lncNH = load i64, i64* %lncNG, !tbaa !4
  store i64 %lncNH, i64* %lsaJf
  %lncNI = load i64*, i64** %Sp_Var
  %lncNJ = getelementptr inbounds i64, i64* %lncNI, i32 2
  %lncNK = bitcast i64* %lncNJ to i64*
  %lncNL = load i64, i64* %lncNK, !tbaa !2
  store i64 %lncNL, i64* %R1_Var
  %lncNN = load i64, i64* %lsaJf
  %lncNM = load i64*, i64** %Sp_Var
  %lncNO = getelementptr inbounds i64, i64* %lncNM, i32 -1
  store i64 %lncNN, i64* %lncNO, !tbaa !2
  %lncNQ = load i64, i64* %lsaJb
  %lncNP = load i64*, i64** %Sp_Var
  %lncNR = getelementptr inbounds i64, i64* %lncNP, i32 0
  store i64 %lncNQ, i64* %lncNR, !tbaa !2
  %lncNT = load i64, i64* %lsaJ9
  %lncNS = load i64*, i64** %Sp_Var
  %lncNU = getelementptr inbounds i64, i64* %lncNS, i32 2
  store i64 %lncNT, i64* %lncNU, !tbaa !2
  %lncNV = load i64*, i64** %Sp_Var
  %lncNW = getelementptr inbounds i64, i64* %lncNV, i32 -2
  %lncNX = ptrtoint i64* %lncNW to i64
  %lncNY = inttoptr i64 %lncNX to i64*
  store i64* %lncNY, i64** %Sp_Var
  %lncNZ = load i64, i64* %R1_Var
  %lncO0 = and i64 %lncNZ, 7
  %lncO1 = icmp ne i64 %lncO0, 0
  br i1 %lncO1, label %ucqI, label %ccqu
ccqu:
  %lncO3 = load i64, i64* %R1_Var
  %lncO4 = inttoptr i64 %lncO3 to i64*
  %lncO5 = load i64, i64* %lncO4, !tbaa !4
  %lncO6 = inttoptr i64 %lncO5 to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncO7 = load i64*, i64** %Sp_Var
  %lncO8 = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncO6( i64* %Base_Arg, i64* %lncO7, i64* %Hp_Arg, i64 %lncO8, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ucqI:
  %lncO9 = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccqt_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncOa = load i64*, i64** %Sp_Var
  %lncOb = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncO9( i64* %Base_Arg, i64* %lncOa, i64* %Hp_Arg, i64 %lncOb, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@ccqt_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccqt_info$def to i8*)
define internal ghccc void @ccqt_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 4, i32 30, i32 0}>
{
ccqt:
  %lsaJj = alloca i64, i32 1
  %lsaJh = alloca i64, i32 1
  %lsaJi = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lncOd = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccqy_info$def to i64
  %lncOc = load i64*, i64** %Sp_Var
  %lncOe = getelementptr inbounds i64, i64* %lncOc, i32 -2
  store i64 %lncOd, i64* %lncOe, !tbaa !2
  %lncOh = load i64, i64* %R1_Var
  %lncOi = add i64 %lncOh, 7
  %lncOj = inttoptr i64 %lncOi to i64*
  %lncOk = load i64, i64* %lncOj, !tbaa !4
  store i64 %lncOk, i64* %lsaJj
  %lncOn = load i64, i64* %R1_Var
  %lncOo = add i64 %lncOn, 15
  %lncOp = inttoptr i64 %lncOo to i64*
  %lncOq = load i64, i64* %lncOp, !tbaa !4
  store i64 %lncOq, i64* %lsaJh
  %lncOt = load i64, i64* %R1_Var
  %lncOu = add i64 %lncOt, 23
  %lncOv = inttoptr i64 %lncOu to i64*
  %lncOw = load i64, i64* %lncOv, !tbaa !4
  store i64 %lncOw, i64* %lsaJi
  %lncOx = load i64*, i64** %Sp_Var
  %lncOy = getelementptr inbounds i64, i64* %lncOx, i32 3
  %lncOz = bitcast i64* %lncOy to i64*
  %lncOA = load i64, i64* %lncOz, !tbaa !2
  store i64 %lncOA, i64* %R1_Var
  %lncOC = load i64, i64* %lsaJj
  %lncOB = load i64*, i64** %Sp_Var
  %lncOD = getelementptr inbounds i64, i64* %lncOB, i32 -1
  store i64 %lncOC, i64* %lncOD, !tbaa !2
  %lncOF = load i64, i64* %lsaJi
  %lncOE = load i64*, i64** %Sp_Var
  %lncOG = getelementptr inbounds i64, i64* %lncOE, i32 0
  store i64 %lncOF, i64* %lncOG, !tbaa !2
  %lncOI = load i64, i64* %lsaJh
  %lncOH = load i64*, i64** %Sp_Var
  %lncOJ = getelementptr inbounds i64, i64* %lncOH, i32 3
  store i64 %lncOI, i64* %lncOJ, !tbaa !2
  %lncOK = load i64*, i64** %Sp_Var
  %lncOL = getelementptr inbounds i64, i64* %lncOK, i32 -2
  %lncOM = ptrtoint i64* %lncOL to i64
  %lncON = inttoptr i64 %lncOM to i64*
  store i64* %lncON, i64** %Sp_Var
  %lncOO = load i64, i64* %R1_Var
  %lncOP = and i64 %lncOO, 7
  %lncOQ = icmp ne i64 %lncOP, 0
  br i1 %lncOQ, label %ucqK, label %ccqD
ccqD:
  %lncOS = load i64, i64* %R1_Var
  %lncOT = inttoptr i64 %lncOS to i64*
  %lncOU = load i64, i64* %lncOT, !tbaa !4
  %lncOV = inttoptr i64 %lncOU to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncOW = load i64*, i64** %Sp_Var
  %lncOX = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncOV( i64* %Base_Arg, i64* %lncOW, i64* %Hp_Arg, i64 %lncOX, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ucqK:
  %lncOY = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccqy_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncOZ = load i64*, i64** %Sp_Var
  %lncP0 = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncOY( i64* %Base_Arg, i64* %lncOZ, i64* %Hp_Arg, i64 %lncP0, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@ccqy_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccqy_info$def to i8*)
define internal ghccc void @ccqy_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 1158, i32 30, i32 0}>
{
ccqy:
  %R6_Var = alloca i64, i32 1
  store i64 undef, i64* %R6_Var
  %R5_Var = alloca i64, i32 1
  store i64 undef, i64* %R5_Var
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lncP1 = load i64*, i64** %Sp_Var
  %lncP2 = getelementptr inbounds i64, i64* %lncP1, i32 2
  %lncP3 = bitcast i64* %lncP2 to i64*
  %lncP4 = load i64, i64* %lncP3, !tbaa !2
  store i64 %lncP4, i64* %R6_Var
  %lncP5 = load i64*, i64** %Sp_Var
  %lncP6 = getelementptr inbounds i64, i64* %lncP5, i32 5
  %lncP7 = bitcast i64* %lncP6 to i64*
  %lncP8 = load i64, i64* %lncP7, !tbaa !2
  store i64 %lncP8, i64* %R5_Var
  %lncP9 = load i64*, i64** %Sp_Var
  %lncPa = getelementptr inbounds i64, i64* %lncP9, i32 3
  %lncPb = bitcast i64* %lncPa to i64*
  %lncPc = load i64, i64* %lncPb, !tbaa !2
  store i64 %lncPc, i64* %R4_Var
  %lncPd = load i64*, i64** %Sp_Var
  %lncPe = getelementptr inbounds i64, i64* %lncPd, i32 4
  %lncPf = bitcast i64* %lncPe to i64*
  %lncPg = load i64, i64* %lncPf, !tbaa !2
  store i64 %lncPg, i64* %R3_Var
  %lncPh = load i64*, i64** %Sp_Var
  %lncPi = getelementptr inbounds i64, i64* %lncPh, i32 6
  %lncPj = bitcast i64* %lncPi to i64*
  %lncPk = load i64, i64* %lncPj, !tbaa !2
  store i64 %lncPk, i64* %R2_Var
  %lncPm = load i64*, i64** %Sp_Var
  %lncPn = getelementptr inbounds i64, i64* %lncPm, i32 1
  %lncPo = bitcast i64* %lncPn to i64*
  %lncPp = load i64, i64* %lncPo, !tbaa !2
  %lncPl = load i64*, i64** %Sp_Var
  %lncPq = getelementptr inbounds i64, i64* %lncPl, i32 3
  store i64 %lncPp, i64* %lncPq, !tbaa !2
  %lncPs = add i64 %R1_Arg, 15
  %lncPt = inttoptr i64 %lncPs to i64*
  %lncPu = load i64, i64* %lncPt, !tbaa !4
  %lncPr = load i64*, i64** %Sp_Var
  %lncPv = getelementptr inbounds i64, i64* %lncPr, i32 4
  store i64 %lncPu, i64* %lncPv, !tbaa !2
  %lncPx = add i64 %R1_Arg, 23
  %lncPy = inttoptr i64 %lncPx to i64*
  %lncPz = load i64, i64* %lncPy, !tbaa !4
  %lncPw = load i64*, i64** %Sp_Var
  %lncPA = getelementptr inbounds i64, i64* %lncPw, i32 5
  store i64 %lncPz, i64* %lncPA, !tbaa !2
  %lncPC = add i64 %R1_Arg, 7
  %lncPD = inttoptr i64 %lncPC to i64*
  %lncPE = load i64, i64* %lncPD, !tbaa !4
  %lncPB = load i64*, i64** %Sp_Var
  %lncPF = getelementptr inbounds i64, i64* %lncPB, i32 6
  store i64 %lncPE, i64* %lncPF, !tbaa !2
  %lncPG = load i64*, i64** %Sp_Var
  %lncPH = getelementptr inbounds i64, i64* %lncPG, i32 3
  %lncPI = ptrtoint i64* %lncPH to i64
  %lncPJ = inttoptr i64 %lncPI to i64*
  store i64* %lncPJ, i64** %Sp_Var
  %lncPK = bitcast i8* @hblaszm0zi0zi0zi0zminplace_HBLASziLevel1_zdwdot_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncPL = load i64*, i64** %Sp_Var
  %lncPM = load i64, i64* %R2_Var
  %lncPN = load i64, i64* %R3_Var
  %lncPO = load i64, i64* %R4_Var
  %lncPP = load i64, i64* %R5_Var
  %lncPQ = load i64, i64* %R6_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncPK( i64* %Base_Arg, i64* %lncPL, i64* %Hp_Arg, i64 %R1_Arg, i64 %lncPM, i64 %lncPN, i64 %lncPO, i64 %lncPP, i64 %lncPQ, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saJ7_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saJ7_info$def to i8*)
define internal ghccc void @saJ7_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 5, i32 15, i32 0}>
{
ccqL:
  %lsaJ7 = alloca i64, i32 1
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %lsaI4 = alloca i64, i32 1
  %lsaI7 = alloca i64, i32 1
  %lsaIa = alloca i64, i32 1
  %lsaIg = alloca i64, i32 1
  %lsaIQ = alloca i64, i32 1
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lncPR = load i64, i64* %R1_Var
  store i64 %lncPR, i64* %lsaJ7
  %lncPS = load i64*, i64** %Sp_Var
  %lncPT = getelementptr inbounds i64, i64* %lncPS, i32 -5
  %lncPU = ptrtoint i64* %lncPT to i64
  %lncPV = icmp ult i64 %lncPU, %SpLim_Arg
  %lncPW = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lncPV, i1 0 )
  br i1 %lncPW, label %ccqM, label %ccqN
ccqN:
  %lncPX = load i64*, i64** %Hp_Var
  %lncPY = getelementptr inbounds i64, i64* %lncPX, i32 5
  %lncPZ = ptrtoint i64* %lncPY to i64
  %lncQ0 = inttoptr i64 %lncPZ to i64*
  store i64* %lncQ0, i64** %Hp_Var
  %lncQ1 = load i64*, i64** %Hp_Var
  %lncQ2 = ptrtoint i64* %lncQ1 to i64
  %lncQ3 = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lncQ4 = bitcast i64* %lncQ3 to i64*
  %lncQ5 = load i64, i64* %lncQ4, !tbaa !5
  %lncQ6 = icmp ugt i64 %lncQ2, %lncQ5
  %lncQ7 = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lncQ6, i1 0 )
  br i1 %lncQ7, label %ccqP, label %ccqO
ccqO:
  %lncQ9 = ptrtoint i8* @stg_upd_frame_info to i64
  %lncQ8 = load i64*, i64** %Sp_Var
  %lncQa = getelementptr inbounds i64, i64* %lncQ8, i32 -2
  store i64 %lncQ9, i64* %lncQa, !tbaa !2
  %lncQc = load i64, i64* %lsaJ7
  %lncQb = load i64*, i64** %Sp_Var
  %lncQd = getelementptr inbounds i64, i64* %lncQb, i32 -1
  store i64 %lncQc, i64* %lncQd, !tbaa !2
  %lncQe = load i64, i64* %lsaJ7
  %lncQf = add i64 %lncQe, 16
  %lncQg = inttoptr i64 %lncQf to i64*
  %lncQh = load i64, i64* %lncQg, !tbaa !1
  store i64 %lncQh, i64* %lsaI4
  %lncQi = load i64, i64* %lsaJ7
  %lncQj = add i64 %lncQi, 24
  %lncQk = inttoptr i64 %lncQj to i64*
  %lncQl = load i64, i64* %lncQk, !tbaa !1
  store i64 %lncQl, i64* %lsaI7
  %lncQm = load i64, i64* %lsaJ7
  %lncQn = add i64 %lncQm, 32
  %lncQo = inttoptr i64 %lncQn to i64*
  %lncQp = load i64, i64* %lncQo, !tbaa !1
  store i64 %lncQp, i64* %lsaIa
  %lncQq = load i64, i64* %lsaJ7
  %lncQr = add i64 %lncQq, 40
  %lncQs = inttoptr i64 %lncQr to i64*
  %lncQt = load i64, i64* %lncQs, !tbaa !1
  store i64 %lncQt, i64* %lsaIg
  %lncQu = load i64, i64* %lsaJ7
  %lncQv = add i64 %lncQu, 48
  %lncQw = inttoptr i64 %lncQv to i64*
  %lncQx = load i64, i64* %lncQw, !tbaa !1
  store i64 %lncQx, i64* %lsaIQ
  %lncQz = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saJo_info$def to i64
  %lncQy = load i64*, i64** %Hp_Var
  %lncQA = getelementptr inbounds i64, i64* %lncQy, i32 -4
  store i64 %lncQz, i64* %lncQA, !tbaa !3
  %lncQC = load i64, i64* %lsaI4
  %lncQB = load i64*, i64** %Hp_Var
  %lncQD = getelementptr inbounds i64, i64* %lncQB, i32 -2
  store i64 %lncQC, i64* %lncQD, !tbaa !3
  %lncQF = load i64, i64* %lsaIa
  %lncQE = load i64*, i64** %Hp_Var
  %lncQG = getelementptr inbounds i64, i64* %lncQE, i32 -1
  store i64 %lncQF, i64* %lncQG, !tbaa !3
  %lncQI = load i64, i64* %lsaIg
  %lncQH = load i64*, i64** %Hp_Var
  %lncQJ = getelementptr inbounds i64, i64* %lncQH, i32 0
  store i64 %lncQI, i64* %lncQJ, !tbaa !3
  %lncQK = load i64, i64* %lsaI7
  store i64 %lncQK, i64* %R2_Var
  %lncQM = ptrtoint i8* @stg_ap_pp_info to i64
  %lncQL = load i64*, i64** %Sp_Var
  %lncQN = getelementptr inbounds i64, i64* %lncQL, i32 -5
  store i64 %lncQM, i64* %lncQN, !tbaa !2
  %lncQP = load i64*, i64** %Hp_Var
  %lncQQ = getelementptr inbounds i64, i64* %lncQP, i32 -4
  %lncQR = ptrtoint i64* %lncQQ to i64
  %lncQO = load i64*, i64** %Sp_Var
  %lncQS = getelementptr inbounds i64, i64* %lncQO, i32 -4
  store i64 %lncQR, i64* %lncQS, !tbaa !2
  %lncQU = load i64, i64* %lsaIQ
  %lncQT = load i64*, i64** %Sp_Var
  %lncQV = getelementptr inbounds i64, i64* %lncQT, i32 -3
  store i64 %lncQU, i64* %lncQV, !tbaa !2
  %lncQW = load i64*, i64** %Sp_Var
  %lncQX = getelementptr inbounds i64, i64* %lncQW, i32 -5
  %lncQY = ptrtoint i64* %lncQX to i64
  %lncQZ = inttoptr i64 %lncQY to i64*
  store i64* %lncQZ, i64** %Sp_Var
  %lncR0 = bitcast i8* @base_GHCziReal_zs_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncR1 = load i64*, i64** %Sp_Var
  %lncR2 = load i64*, i64** %Hp_Var
  %lncR3 = load i64, i64* %R1_Var
  %lncR4 = load i64, i64* %R2_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncR0( i64* %Base_Arg, i64* %lncR1, i64* %lncR2, i64 %lncR3, i64 %lncR4, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ccqP:
  %lncR5 = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 40, i64* %lncR5, !tbaa !5
  br label %ccqM
ccqM:
  %lncR6 = load i64, i64* %lsaJ7
  store i64 %lncR6, i64* %R1_Var
  %lncR7 = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lncR8 = bitcast i64* %lncR7 to i64*
  %lncR9 = load i64, i64* %lncR8, !tbaa !5
  %lncRa = inttoptr i64 %lncR9 to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncRb = load i64*, i64** %Sp_Var
  %lncRc = load i64*, i64** %Hp_Var
  %lncRd = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncRa( i64* %Base_Arg, i64* %lncRb, i64* %lncRc, i64 %lncRd, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saL7_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saL7_info$def to i8*)
define internal ghccc void @saL7_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 5, i32 15, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%ucuI_srt_struct* @ucuI_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saL7_info$def to i64)) to i32),i32 0)}>
{
ccqS:
  %R6_Var = alloca i64, i32 1
  store i64 undef, i64* %R6_Var
  %R5_Var = alloca i64, i32 1
  store i64 undef, i64* %R5_Var
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %lncRe = add i64 %R1_Arg, 16
  %lncRf = inttoptr i64 %lncRe to i64*
  %lncRg = load i64, i64* %lncRf, !tbaa !4
  store i64 %lncRg, i64* %R6_Var
  %lncRh = add i64 %R1_Arg, 24
  %lncRi = inttoptr i64 %lncRh to i64*
  %lncRj = load i64, i64* %lncRi, !tbaa !4
  store i64 %lncRj, i64* %R5_Var
  %lncRk = add i64 %R1_Arg, 40
  %lncRl = inttoptr i64 %lncRk to i64*
  %lncRm = load i64, i64* %lncRl, !tbaa !4
  store i64 %lncRm, i64* %R4_Var
  %lncRn = add i64 %R1_Arg, 48
  %lncRo = inttoptr i64 %lncRn to i64*
  %lncRp = load i64, i64* %lncRo, !tbaa !4
  store i64 %lncRp, i64* %R3_Var
  %lncRq = add i64 %R1_Arg, 32
  %lncRr = inttoptr i64 %lncRq to i64*
  %lncRs = load i64, i64* %lncRr, !tbaa !4
  store i64 %lncRs, i64* %R2_Var
  %lncRt = bitcast i8* @hblaszm0zi0zi0zi0zminplace_HBLASziLevel1_axpyzq_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncRu = load i64, i64* %R2_Var
  %lncRv = load i64, i64* %R3_Var
  %lncRw = load i64, i64* %R4_Var
  %lncRx = load i64, i64* %R5_Var
  %lncRy = load i64, i64* %R6_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncRt( i64* %Base_Arg, i64* %Sp_Arg, i64* %Hp_Arg, i64 %R1_Arg, i64 %lncRu, i64 %lncRv, i64 %lncRw, i64 %lncRx, i64 %lncRy, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saJB_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saJB_info$def to i8*)
define internal ghccc void @saJB_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 3, i32 15, i32 0}>
{
ccr1:
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lncRz = load i64*, i64** %Sp_Var
  %lncRA = getelementptr inbounds i64, i64* %lncRz, i32 -5
  %lncRB = ptrtoint i64* %lncRA to i64
  %lncRC = icmp ult i64 %lncRB, %SpLim_Arg
  %lncRD = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lncRC, i1 0 )
  br i1 %lncRD, label %ccr2, label %ccr3
ccr3:
  %lncRF = ptrtoint i8* @stg_upd_frame_info to i64
  %lncRE = load i64*, i64** %Sp_Var
  %lncRG = getelementptr inbounds i64, i64* %lncRE, i32 -2
  store i64 %lncRF, i64* %lncRG, !tbaa !2
  %lncRI = load i64, i64* %R1_Var
  %lncRH = load i64*, i64** %Sp_Var
  %lncRJ = getelementptr inbounds i64, i64* %lncRH, i32 -1
  store i64 %lncRI, i64* %lncRJ, !tbaa !2
  %lncRM = load i64, i64* %R1_Var
  %lncRN = add i64 %lncRM, 16
  %lncRO = inttoptr i64 %lncRN to i64*
  %lncRP = load i64, i64* %lncRO, !tbaa !4
  store i64 %lncRP, i64* %R2_Var
  %lncRR = ptrtoint i8* @stg_ap_pp_info to i64
  %lncRQ = load i64*, i64** %Sp_Var
  %lncRS = getelementptr inbounds i64, i64* %lncRQ, i32 -5
  store i64 %lncRR, i64* %lncRS, !tbaa !2
  %lncRW = load i64, i64* %R1_Var
  %lncRX = add i64 %lncRW, 24
  %lncRY = inttoptr i64 %lncRX to i64*
  %lncRZ = load i64, i64* %lncRY, !tbaa !4
  %lncRT = load i64*, i64** %Sp_Var
  %lncS0 = getelementptr inbounds i64, i64* %lncRT, i32 -4
  store i64 %lncRZ, i64* %lncS0, !tbaa !2
  %lncS4 = load i64, i64* %R1_Var
  %lncS5 = add i64 %lncS4, 32
  %lncS6 = inttoptr i64 %lncS5 to i64*
  %lncS7 = load i64, i64* %lncS6, !tbaa !4
  %lncS1 = load i64*, i64** %Sp_Var
  %lncS8 = getelementptr inbounds i64, i64* %lncS1, i32 -3
  store i64 %lncS7, i64* %lncS8, !tbaa !2
  %lncS9 = load i64*, i64** %Sp_Var
  %lncSa = getelementptr inbounds i64, i64* %lncS9, i32 -5
  %lncSb = ptrtoint i64* %lncSa to i64
  %lncSc = inttoptr i64 %lncSb to i64*
  store i64* %lncSc, i64** %Sp_Var
  %lncSd = bitcast i8* @base_GHCziNum_zt_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncSe = load i64*, i64** %Sp_Var
  %lncSf = load i64, i64* %R1_Var
  %lncSg = load i64, i64* %R2_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncSd( i64* %Base_Arg, i64* %lncSe, i64* %Hp_Arg, i64 %lncSf, i64 %lncSg, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ccr2:
  %lncSh = load i64, i64* %R1_Var
  store i64 %lncSh, i64* %R1_Var
  %lncSi = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lncSj = bitcast i64* %lncSi to i64*
  %lncSk = load i64, i64* %lncSj, !tbaa !5
  %lncSl = inttoptr i64 %lncSk to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncSm = load i64*, i64** %Sp_Var
  %lncSn = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncSl( i64* %Base_Arg, i64* %lncSm, i64* %Hp_Arg, i64 %lncSn, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saJA_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saJA_info$def to i8*)
define internal ghccc void @saJA_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 6, i32 15, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%ucuI_srt_struct* @ucuI_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saJA_info$def to i64)) to i32),i32 0)}>
{
ccr4:
  %lsaJA = alloca i64, i32 1
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %lsaI2 = alloca i64, i32 1
  %lsaI4 = alloca i64, i32 1
  %lsaI5 = alloca i64, i32 1
  %lsaJr = alloca i64, i32 1
  %lsaJt = alloca i64, i32 1
  %lsaJv = alloca i64, i32 1
  %R6_Var = alloca i64, i32 1
  store i64 undef, i64* %R6_Var
  %R5_Var = alloca i64, i32 1
  store i64 undef, i64* %R5_Var
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lncSo = load i64, i64* %R1_Var
  store i64 %lncSo, i64* %lsaJA
  %lncSp = load i64*, i64** %Sp_Var
  %lncSq = getelementptr inbounds i64, i64* %lncSp, i32 -2
  %lncSr = ptrtoint i64* %lncSq to i64
  %lncSs = icmp ult i64 %lncSr, %SpLim_Arg
  %lncSt = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lncSs, i1 0 )
  br i1 %lncSt, label %ccr5, label %ccr6
ccr6:
  %lncSu = load i64*, i64** %Hp_Var
  %lncSv = getelementptr inbounds i64, i64* %lncSu, i32 5
  %lncSw = ptrtoint i64* %lncSv to i64
  %lncSx = inttoptr i64 %lncSw to i64*
  store i64* %lncSx, i64** %Hp_Var
  %lncSy = load i64*, i64** %Hp_Var
  %lncSz = ptrtoint i64* %lncSy to i64
  %lncSA = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lncSB = bitcast i64* %lncSA to i64*
  %lncSC = load i64, i64* %lncSB, !tbaa !5
  %lncSD = icmp ugt i64 %lncSz, %lncSC
  %lncSE = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lncSD, i1 0 )
  br i1 %lncSE, label %ccr8, label %ccr7
ccr7:
  %lncSG = ptrtoint i8* @stg_upd_frame_info to i64
  %lncSF = load i64*, i64** %Sp_Var
  %lncSH = getelementptr inbounds i64, i64* %lncSF, i32 -2
  store i64 %lncSG, i64* %lncSH, !tbaa !2
  %lncSJ = load i64, i64* %lsaJA
  %lncSI = load i64*, i64** %Sp_Var
  %lncSK = getelementptr inbounds i64, i64* %lncSI, i32 -1
  store i64 %lncSJ, i64* %lncSK, !tbaa !2
  %lncSL = load i64, i64* %lsaJA
  %lncSM = add i64 %lncSL, 16
  %lncSN = inttoptr i64 %lncSM to i64*
  %lncSO = load i64, i64* %lncSN, !tbaa !1
  store i64 %lncSO, i64* %lsaI2
  %lncSP = load i64, i64* %lsaJA
  %lncSQ = add i64 %lncSP, 24
  %lncSR = inttoptr i64 %lncSQ to i64*
  %lncSS = load i64, i64* %lncSR, !tbaa !1
  store i64 %lncSS, i64* %lsaI4
  %lncST = load i64, i64* %lsaJA
  %lncSU = add i64 %lncST, 32
  %lncSV = inttoptr i64 %lncSU to i64*
  %lncSW = load i64, i64* %lncSV, !tbaa !1
  store i64 %lncSW, i64* %lsaI5
  %lncSX = load i64, i64* %lsaJA
  %lncSY = add i64 %lncSX, 40
  %lncSZ = inttoptr i64 %lncSY to i64*
  %lncT0 = load i64, i64* %lncSZ, !tbaa !1
  store i64 %lncT0, i64* %lsaJr
  %lncT1 = load i64, i64* %lsaJA
  %lncT2 = add i64 %lncT1, 48
  %lncT3 = inttoptr i64 %lncT2 to i64*
  %lncT4 = load i64, i64* %lncT3, !tbaa !1
  store i64 %lncT4, i64* %lsaJt
  %lncT5 = load i64, i64* %lsaJA
  %lncT6 = add i64 %lncT5, 56
  %lncT7 = inttoptr i64 %lncT6 to i64*
  %lncT8 = load i64, i64* %lncT7, !tbaa !1
  store i64 %lncT8, i64* %lsaJv
  %lncTa = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saJB_info$def to i64
  %lncT9 = load i64*, i64** %Hp_Var
  %lncTb = getelementptr inbounds i64, i64* %lncT9, i32 -4
  store i64 %lncTa, i64* %lncTb, !tbaa !3
  %lncTd = load i64, i64* %lsaI4
  %lncTc = load i64*, i64** %Hp_Var
  %lncTe = getelementptr inbounds i64, i64* %lncTc, i32 -2
  store i64 %lncTd, i64* %lncTe, !tbaa !3
  %lncTg = load i64, i64* %lsaI5
  %lncTf = load i64*, i64** %Hp_Var
  %lncTh = getelementptr inbounds i64, i64* %lncTf, i32 -1
  store i64 %lncTg, i64* %lncTh, !tbaa !3
  %lncTj = load i64, i64* %lsaJv
  %lncTi = load i64*, i64** %Hp_Var
  %lncTk = getelementptr inbounds i64, i64* %lncTi, i32 0
  store i64 %lncTj, i64* %lncTk, !tbaa !3
  %lncTl = load i64, i64* %lsaI2
  store i64 %lncTl, i64* %R6_Var
  %lncTm = load i64, i64* %lsaJr
  store i64 %lncTm, i64* %R5_Var
  %lncTn = load i64, i64* %lsaJt
  store i64 %lncTn, i64* %R4_Var
  %lncTo = load i64*, i64** %Hp_Var
  %lncTp = getelementptr inbounds i64, i64* %lncTo, i32 -4
  %lncTq = ptrtoint i64* %lncTp to i64
  store i64 %lncTq, i64* %R3_Var
  %lncTr = load i64, i64* %lsaI4
  store i64 %lncTr, i64* %R2_Var
  %lncTs = load i64*, i64** %Sp_Var
  %lncTt = getelementptr inbounds i64, i64* %lncTs, i32 -2
  %lncTu = ptrtoint i64* %lncTt to i64
  %lncTv = inttoptr i64 %lncTu to i64*
  store i64* %lncTv, i64** %Sp_Var
  %lncTw = bitcast i8* @hblaszm0zi0zi0zi0zminplace_HBLASziLevel1_axpyzq_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncTx = load i64*, i64** %Sp_Var
  %lncTy = load i64*, i64** %Hp_Var
  %lncTz = load i64, i64* %R1_Var
  %lncTA = load i64, i64* %R2_Var
  %lncTB = load i64, i64* %R3_Var
  %lncTC = load i64, i64* %R4_Var
  %lncTD = load i64, i64* %R5_Var
  %lncTE = load i64, i64* %R6_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncTw( i64* %Base_Arg, i64* %lncTx, i64* %lncTy, i64 %lncTz, i64 %lncTA, i64 %lncTB, i64 %lncTC, i64 %lncTD, i64 %lncTE, i64 %SpLim_Arg ) nounwind
  ret void
ccr8:
  %lncTF = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 40, i64* %lncTF, !tbaa !5
  br label %ccr5
ccr5:
  %lncTG = load i64, i64* %lsaJA
  store i64 %lncTG, i64* %R1_Var
  %lncTH = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lncTI = bitcast i64* %lncTH to i64*
  %lncTJ = load i64, i64* %lncTI, !tbaa !5
  %lncTK = inttoptr i64 %lncTJ to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncTL = load i64*, i64** %Sp_Var
  %lncTM = load i64*, i64** %Hp_Var
  %lncTN = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncTK( i64* %Base_Arg, i64* %lncTL, i64* %lncTM, i64 %lncTN, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saK3_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saK3_info$def to i8*)
define internal ghccc void @saK3_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 3, i32 15, i32 0}>
{
ccrx:
  %lsaJt = alloca i64, i32 1
  %lsaJA = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lncTO = load i64*, i64** %Sp_Var
  %lncTP = getelementptr inbounds i64, i64* %lncTO, i32 -9
  %lncTQ = ptrtoint i64* %lncTP to i64
  %lncTR = icmp ult i64 %lncTQ, %SpLim_Arg
  %lncTS = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lncTR, i1 0 )
  br i1 %lncTS, label %ccrG, label %ccrH
ccrH:
  %lncTU = ptrtoint i8* @stg_upd_frame_info to i64
  %lncTT = load i64*, i64** %Sp_Var
  %lncTV = getelementptr inbounds i64, i64* %lncTT, i32 -2
  store i64 %lncTU, i64* %lncTV, !tbaa !2
  %lncTX = load i64, i64* %R1_Var
  %lncTW = load i64*, i64** %Sp_Var
  %lncTY = getelementptr inbounds i64, i64* %lncTW, i32 -1
  store i64 %lncTX, i64* %lncTY, !tbaa !2
  %lncU0 = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccru_info$def to i64
  %lncTZ = load i64*, i64** %Sp_Var
  %lncU1 = getelementptr inbounds i64, i64* %lncTZ, i32 -5
  store i64 %lncU0, i64* %lncU1, !tbaa !2
  %lncU4 = load i64, i64* %R1_Var
  %lncU5 = add i64 %lncU4, 24
  %lncU6 = inttoptr i64 %lncU5 to i64*
  %lncU7 = load i64, i64* %lncU6, !tbaa !4
  store i64 %lncU7, i64* %lsaJt
  %lncUa = load i64, i64* %R1_Var
  %lncUb = add i64 %lncUa, 32
  %lncUc = inttoptr i64 %lncUb to i64*
  %lncUd = load i64, i64* %lncUc, !tbaa !4
  store i64 %lncUd, i64* %lsaJA
  %lncUg = load i64, i64* %R1_Var
  %lncUh = add i64 %lncUg, 16
  %lncUi = inttoptr i64 %lncUh to i64*
  %lncUj = load i64, i64* %lncUi, !tbaa !4
  store i64 %lncUj, i64* %R1_Var
  %lncUl = load i64, i64* %lsaJt
  %lncUk = load i64*, i64** %Sp_Var
  %lncUm = getelementptr inbounds i64, i64* %lncUk, i32 -4
  store i64 %lncUl, i64* %lncUm, !tbaa !2
  %lncUo = load i64, i64* %lsaJA
  %lncUn = load i64*, i64** %Sp_Var
  %lncUp = getelementptr inbounds i64, i64* %lncUn, i32 -3
  store i64 %lncUo, i64* %lncUp, !tbaa !2
  %lncUq = load i64*, i64** %Sp_Var
  %lncUr = getelementptr inbounds i64, i64* %lncUq, i32 -5
  %lncUs = ptrtoint i64* %lncUr to i64
  %lncUt = inttoptr i64 %lncUs to i64*
  store i64* %lncUt, i64** %Sp_Var
  %lncUu = load i64, i64* %R1_Var
  %lncUv = and i64 %lncUu, 7
  %lncUw = icmp ne i64 %lncUv, 0
  br i1 %lncUw, label %ucrQ, label %ccrv
ccrv:
  %lncUy = load i64, i64* %R1_Var
  %lncUz = inttoptr i64 %lncUy to i64*
  %lncUA = load i64, i64* %lncUz, !tbaa !4
  %lncUB = inttoptr i64 %lncUA to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncUC = load i64*, i64** %Sp_Var
  %lncUD = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncUB( i64* %Base_Arg, i64* %lncUC, i64* %Hp_Arg, i64 %lncUD, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ucrQ:
  %lncUE = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccru_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncUF = load i64*, i64** %Sp_Var
  %lncUG = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncUE( i64* %Base_Arg, i64* %lncUF, i64* %Hp_Arg, i64 %lncUG, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ccrG:
  %lncUH = load i64, i64* %R1_Var
  store i64 %lncUH, i64* %R1_Var
  %lncUI = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lncUJ = bitcast i64* %lncUI to i64*
  %lncUK = load i64, i64* %lncUJ, !tbaa !5
  %lncUL = inttoptr i64 %lncUK to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncUM = load i64*, i64** %Sp_Var
  %lncUN = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncUL( i64* %Base_Arg, i64* %lncUM, i64* %Hp_Arg, i64 %lncUN, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@ccru_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccru_info$def to i8*)
define internal ghccc void @ccru_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 2, i32 30, i32 0}>
{
ccru:
  %lsaJO = alloca i64, i32 1
  %lsaJQ = alloca i64, i32 1
  %lsaJU = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lncUP = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccrA_info$def to i64
  %lncUO = load i64*, i64** %Sp_Var
  %lncUQ = getelementptr inbounds i64, i64* %lncUO, i32 -2
  store i64 %lncUP, i64* %lncUQ, !tbaa !2
  %lncUT = load i64, i64* %R1_Var
  %lncUU = add i64 %lncUT, 7
  %lncUV = inttoptr i64 %lncUU to i64*
  %lncUW = load i64, i64* %lncUV, !tbaa !4
  store i64 %lncUW, i64* %lsaJO
  %lncUZ = load i64, i64* %R1_Var
  %lncV0 = add i64 %lncUZ, 23
  %lncV1 = inttoptr i64 %lncV0 to i64*
  %lncV2 = load i64, i64* %lncV1, !tbaa !4
  store i64 %lncV2, i64* %lsaJQ
  %lncV5 = load i64, i64* %R1_Var
  %lncV6 = add i64 %lncV5, 55
  %lncV7 = inttoptr i64 %lncV6 to i64*
  %lncV8 = load i64, i64* %lncV7, !tbaa !4
  store i64 %lncV8, i64* %lsaJU
  %lncV9 = load i64*, i64** %Sp_Var
  %lncVa = getelementptr inbounds i64, i64* %lncV9, i32 2
  %lncVb = bitcast i64* %lncVa to i64*
  %lncVc = load i64, i64* %lncVb, !tbaa !2
  store i64 %lncVc, i64* %R1_Var
  %lncVe = load i64, i64* %lsaJU
  %lncVd = load i64*, i64** %Sp_Var
  %lncVf = getelementptr inbounds i64, i64* %lncVd, i32 -1
  store i64 %lncVe, i64* %lncVf, !tbaa !2
  %lncVh = load i64, i64* %lsaJQ
  %lncVg = load i64*, i64** %Sp_Var
  %lncVi = getelementptr inbounds i64, i64* %lncVg, i32 0
  store i64 %lncVh, i64* %lncVi, !tbaa !2
  %lncVk = load i64, i64* %lsaJO
  %lncVj = load i64*, i64** %Sp_Var
  %lncVl = getelementptr inbounds i64, i64* %lncVj, i32 2
  store i64 %lncVk, i64* %lncVl, !tbaa !2
  %lncVm = load i64*, i64** %Sp_Var
  %lncVn = getelementptr inbounds i64, i64* %lncVm, i32 -2
  %lncVo = ptrtoint i64* %lncVn to i64
  %lncVp = inttoptr i64 %lncVo to i64*
  store i64* %lncVp, i64** %Sp_Var
  %lncVq = load i64, i64* %R1_Var
  %lncVr = and i64 %lncVq, 7
  %lncVs = icmp ne i64 %lncVr, 0
  br i1 %lncVs, label %ucrP, label %ccrB
ccrB:
  %lncVu = load i64, i64* %R1_Var
  %lncVv = inttoptr i64 %lncVu to i64*
  %lncVw = load i64, i64* %lncVv, !tbaa !4
  %lncVx = inttoptr i64 %lncVw to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncVy = load i64*, i64** %Sp_Var
  %lncVz = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncVx( i64* %Base_Arg, i64* %lncVy, i64* %Hp_Arg, i64 %lncVz, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ucrP:
  %lncVA = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccrA_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncVB = load i64*, i64** %Sp_Var
  %lncVC = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncVA( i64* %Base_Arg, i64* %lncVB, i64* %Hp_Arg, i64 %lncVC, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@ccrA_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccrA_info$def to i8*)
define internal ghccc void @ccrA_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 4, i32 30, i32 0}>
{
ccrA:
  %lsaJY = alloca i64, i32 1
  %lsaJW = alloca i64, i32 1
  %lsaJX = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lncVE = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccrF_info$def to i64
  %lncVD = load i64*, i64** %Sp_Var
  %lncVF = getelementptr inbounds i64, i64* %lncVD, i32 -2
  store i64 %lncVE, i64* %lncVF, !tbaa !2
  %lncVI = load i64, i64* %R1_Var
  %lncVJ = add i64 %lncVI, 7
  %lncVK = inttoptr i64 %lncVJ to i64*
  %lncVL = load i64, i64* %lncVK, !tbaa !4
  store i64 %lncVL, i64* %lsaJY
  %lncVO = load i64, i64* %R1_Var
  %lncVP = add i64 %lncVO, 15
  %lncVQ = inttoptr i64 %lncVP to i64*
  %lncVR = load i64, i64* %lncVQ, !tbaa !4
  store i64 %lncVR, i64* %lsaJW
  %lncVU = load i64, i64* %R1_Var
  %lncVV = add i64 %lncVU, 23
  %lncVW = inttoptr i64 %lncVV to i64*
  %lncVX = load i64, i64* %lncVW, !tbaa !4
  store i64 %lncVX, i64* %lsaJX
  %lncVY = load i64*, i64** %Sp_Var
  %lncVZ = getelementptr inbounds i64, i64* %lncVY, i32 3
  %lncW0 = bitcast i64* %lncVZ to i64*
  %lncW1 = load i64, i64* %lncW0, !tbaa !2
  store i64 %lncW1, i64* %R1_Var
  %lncW3 = load i64, i64* %lsaJY
  %lncW2 = load i64*, i64** %Sp_Var
  %lncW4 = getelementptr inbounds i64, i64* %lncW2, i32 -1
  store i64 %lncW3, i64* %lncW4, !tbaa !2
  %lncW6 = load i64, i64* %lsaJX
  %lncW5 = load i64*, i64** %Sp_Var
  %lncW7 = getelementptr inbounds i64, i64* %lncW5, i32 0
  store i64 %lncW6, i64* %lncW7, !tbaa !2
  %lncW9 = load i64, i64* %lsaJW
  %lncW8 = load i64*, i64** %Sp_Var
  %lncWa = getelementptr inbounds i64, i64* %lncW8, i32 3
  store i64 %lncW9, i64* %lncWa, !tbaa !2
  %lncWb = load i64*, i64** %Sp_Var
  %lncWc = getelementptr inbounds i64, i64* %lncWb, i32 -2
  %lncWd = ptrtoint i64* %lncWc to i64
  %lncWe = inttoptr i64 %lncWd to i64*
  store i64* %lncWe, i64** %Sp_Var
  %lncWf = load i64, i64* %R1_Var
  %lncWg = and i64 %lncWf, 7
  %lncWh = icmp ne i64 %lncWg, 0
  br i1 %lncWh, label %ucrR, label %ccrK
ccrK:
  %lncWj = load i64, i64* %R1_Var
  %lncWk = inttoptr i64 %lncWj to i64*
  %lncWl = load i64, i64* %lncWk, !tbaa !4
  %lncWm = inttoptr i64 %lncWl to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncWn = load i64*, i64** %Sp_Var
  %lncWo = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncWm( i64* %Base_Arg, i64* %lncWn, i64* %Hp_Arg, i64 %lncWo, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ucrR:
  %lncWp = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccrF_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncWq = load i64*, i64** %Sp_Var
  %lncWr = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncWp( i64* %Base_Arg, i64* %lncWq, i64* %Hp_Arg, i64 %lncWr, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@ccrF_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccrF_info$def to i8*)
define internal ghccc void @ccrF_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 1158, i32 30, i32 0}>
{
ccrF:
  %R6_Var = alloca i64, i32 1
  store i64 undef, i64* %R6_Var
  %R5_Var = alloca i64, i32 1
  store i64 undef, i64* %R5_Var
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lncWs = load i64*, i64** %Sp_Var
  %lncWt = getelementptr inbounds i64, i64* %lncWs, i32 2
  %lncWu = bitcast i64* %lncWt to i64*
  %lncWv = load i64, i64* %lncWu, !tbaa !2
  store i64 %lncWv, i64* %R6_Var
  %lncWw = load i64*, i64** %Sp_Var
  %lncWx = getelementptr inbounds i64, i64* %lncWw, i32 5
  %lncWy = bitcast i64* %lncWx to i64*
  %lncWz = load i64, i64* %lncWy, !tbaa !2
  store i64 %lncWz, i64* %R5_Var
  %lncWA = load i64*, i64** %Sp_Var
  %lncWB = getelementptr inbounds i64, i64* %lncWA, i32 3
  %lncWC = bitcast i64* %lncWB to i64*
  %lncWD = load i64, i64* %lncWC, !tbaa !2
  store i64 %lncWD, i64* %R4_Var
  %lncWE = load i64*, i64** %Sp_Var
  %lncWF = getelementptr inbounds i64, i64* %lncWE, i32 4
  %lncWG = bitcast i64* %lncWF to i64*
  %lncWH = load i64, i64* %lncWG, !tbaa !2
  store i64 %lncWH, i64* %R3_Var
  %lncWI = load i64*, i64** %Sp_Var
  %lncWJ = getelementptr inbounds i64, i64* %lncWI, i32 6
  %lncWK = bitcast i64* %lncWJ to i64*
  %lncWL = load i64, i64* %lncWK, !tbaa !2
  store i64 %lncWL, i64* %R2_Var
  %lncWN = load i64*, i64** %Sp_Var
  %lncWO = getelementptr inbounds i64, i64* %lncWN, i32 1
  %lncWP = bitcast i64* %lncWO to i64*
  %lncWQ = load i64, i64* %lncWP, !tbaa !2
  %lncWM = load i64*, i64** %Sp_Var
  %lncWR = getelementptr inbounds i64, i64* %lncWM, i32 3
  store i64 %lncWQ, i64* %lncWR, !tbaa !2
  %lncWT = add i64 %R1_Arg, 15
  %lncWU = inttoptr i64 %lncWT to i64*
  %lncWV = load i64, i64* %lncWU, !tbaa !4
  %lncWS = load i64*, i64** %Sp_Var
  %lncWW = getelementptr inbounds i64, i64* %lncWS, i32 4
  store i64 %lncWV, i64* %lncWW, !tbaa !2
  %lncWY = add i64 %R1_Arg, 23
  %lncWZ = inttoptr i64 %lncWY to i64*
  %lncX0 = load i64, i64* %lncWZ, !tbaa !4
  %lncWX = load i64*, i64** %Sp_Var
  %lncX1 = getelementptr inbounds i64, i64* %lncWX, i32 5
  store i64 %lncX0, i64* %lncX1, !tbaa !2
  %lncX3 = add i64 %R1_Arg, 7
  %lncX4 = inttoptr i64 %lncX3 to i64*
  %lncX5 = load i64, i64* %lncX4, !tbaa !4
  %lncX2 = load i64*, i64** %Sp_Var
  %lncX6 = getelementptr inbounds i64, i64* %lncX2, i32 6
  store i64 %lncX5, i64* %lncX6, !tbaa !2
  %lncX7 = load i64*, i64** %Sp_Var
  %lncX8 = getelementptr inbounds i64, i64* %lncX7, i32 3
  %lncX9 = ptrtoint i64* %lncX8 to i64
  %lncXa = inttoptr i64 %lncX9 to i64*
  store i64* %lncXa, i64** %Sp_Var
  %lncXb = bitcast i8* @hblaszm0zi0zi0zi0zminplace_HBLASziLevel1_zdwdot_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncXc = load i64*, i64** %Sp_Var
  %lncXd = load i64, i64* %R2_Var
  %lncXe = load i64, i64* %R3_Var
  %lncXf = load i64, i64* %R4_Var
  %lncXg = load i64, i64* %R5_Var
  %lncXh = load i64, i64* %R6_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncXb( i64* %Base_Arg, i64* %lncXc, i64* %Hp_Arg, i64 %R1_Arg, i64 %lncXd, i64 %lncXe, i64 %lncXf, i64 %lncXg, i64 %lncXh, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saK4_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saK4_info$def to i8*)
define internal ghccc void @saK4_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 5, i32 15, i32 0}>
{
ccrS:
  %lsaK4 = alloca i64, i32 1
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %lsaI4 = alloca i64, i32 1
  %lsaI7 = alloca i64, i32 1
  %lsaJt = alloca i64, i32 1
  %lsaJu = alloca i64, i32 1
  %lsaJA = alloca i64, i32 1
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lncXi = load i64, i64* %R1_Var
  store i64 %lncXi, i64* %lsaK4
  %lncXj = load i64*, i64** %Sp_Var
  %lncXk = getelementptr inbounds i64, i64* %lncXj, i32 -5
  %lncXl = ptrtoint i64* %lncXk to i64
  %lncXm = icmp ult i64 %lncXl, %SpLim_Arg
  %lncXn = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lncXm, i1 0 )
  br i1 %lncXn, label %ccrT, label %ccrU
ccrU:
  %lncXo = load i64*, i64** %Hp_Var
  %lncXp = getelementptr inbounds i64, i64* %lncXo, i32 5
  %lncXq = ptrtoint i64* %lncXp to i64
  %lncXr = inttoptr i64 %lncXq to i64*
  store i64* %lncXr, i64** %Hp_Var
  %lncXs = load i64*, i64** %Hp_Var
  %lncXt = ptrtoint i64* %lncXs to i64
  %lncXu = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lncXv = bitcast i64* %lncXu to i64*
  %lncXw = load i64, i64* %lncXv, !tbaa !5
  %lncXx = icmp ugt i64 %lncXt, %lncXw
  %lncXy = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lncXx, i1 0 )
  br i1 %lncXy, label %ccrW, label %ccrV
ccrV:
  %lncXA = ptrtoint i8* @stg_upd_frame_info to i64
  %lncXz = load i64*, i64** %Sp_Var
  %lncXB = getelementptr inbounds i64, i64* %lncXz, i32 -2
  store i64 %lncXA, i64* %lncXB, !tbaa !2
  %lncXD = load i64, i64* %lsaK4
  %lncXC = load i64*, i64** %Sp_Var
  %lncXE = getelementptr inbounds i64, i64* %lncXC, i32 -1
  store i64 %lncXD, i64* %lncXE, !tbaa !2
  %lncXF = load i64, i64* %lsaK4
  %lncXG = add i64 %lncXF, 16
  %lncXH = inttoptr i64 %lncXG to i64*
  %lncXI = load i64, i64* %lncXH, !tbaa !1
  store i64 %lncXI, i64* %lsaI4
  %lncXJ = load i64, i64* %lsaK4
  %lncXK = add i64 %lncXJ, 24
  %lncXL = inttoptr i64 %lncXK to i64*
  %lncXM = load i64, i64* %lncXL, !tbaa !1
  store i64 %lncXM, i64* %lsaI7
  %lncXN = load i64, i64* %lsaK4
  %lncXO = add i64 %lncXN, 32
  %lncXP = inttoptr i64 %lncXO to i64*
  %lncXQ = load i64, i64* %lncXP, !tbaa !1
  store i64 %lncXQ, i64* %lsaJt
  %lncXR = load i64, i64* %lsaK4
  %lncXS = add i64 %lncXR, 40
  %lncXT = inttoptr i64 %lncXS to i64*
  %lncXU = load i64, i64* %lncXT, !tbaa !1
  store i64 %lncXU, i64* %lsaJu
  %lncXV = load i64, i64* %lsaK4
  %lncXW = add i64 %lncXV, 48
  %lncXX = inttoptr i64 %lncXW to i64*
  %lncXY = load i64, i64* %lncXX, !tbaa !1
  store i64 %lncXY, i64* %lsaJA
  %lncY0 = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saK3_info$def to i64
  %lncXZ = load i64*, i64** %Hp_Var
  %lncY1 = getelementptr inbounds i64, i64* %lncXZ, i32 -4
  store i64 %lncY0, i64* %lncY1, !tbaa !3
  %lncY3 = load i64, i64* %lsaI4
  %lncY2 = load i64*, i64** %Hp_Var
  %lncY4 = getelementptr inbounds i64, i64* %lncY2, i32 -2
  store i64 %lncY3, i64* %lncY4, !tbaa !3
  %lncY6 = load i64, i64* %lsaJt
  %lncY5 = load i64*, i64** %Hp_Var
  %lncY7 = getelementptr inbounds i64, i64* %lncY5, i32 -1
  store i64 %lncY6, i64* %lncY7, !tbaa !3
  %lncY9 = load i64, i64* %lsaJA
  %lncY8 = load i64*, i64** %Hp_Var
  %lncYa = getelementptr inbounds i64, i64* %lncY8, i32 0
  store i64 %lncY9, i64* %lncYa, !tbaa !3
  %lncYb = load i64, i64* %lsaI7
  store i64 %lncYb, i64* %R2_Var
  %lncYd = ptrtoint i8* @stg_ap_pp_info to i64
  %lncYc = load i64*, i64** %Sp_Var
  %lncYe = getelementptr inbounds i64, i64* %lncYc, i32 -5
  store i64 %lncYd, i64* %lncYe, !tbaa !2
  %lncYg = load i64*, i64** %Hp_Var
  %lncYh = getelementptr inbounds i64, i64* %lncYg, i32 -4
  %lncYi = ptrtoint i64* %lncYh to i64
  %lncYf = load i64*, i64** %Sp_Var
  %lncYj = getelementptr inbounds i64, i64* %lncYf, i32 -4
  store i64 %lncYi, i64* %lncYj, !tbaa !2
  %lncYl = load i64, i64* %lsaJu
  %lncYk = load i64*, i64** %Sp_Var
  %lncYm = getelementptr inbounds i64, i64* %lncYk, i32 -3
  store i64 %lncYl, i64* %lncYm, !tbaa !2
  %lncYn = load i64*, i64** %Sp_Var
  %lncYo = getelementptr inbounds i64, i64* %lncYn, i32 -5
  %lncYp = ptrtoint i64* %lncYo to i64
  %lncYq = inttoptr i64 %lncYp to i64*
  store i64* %lncYq, i64** %Sp_Var
  %lncYr = bitcast i8* @base_GHCziReal_zs_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncYs = load i64*, i64** %Sp_Var
  %lncYt = load i64*, i64** %Hp_Var
  %lncYu = load i64, i64* %R1_Var
  %lncYv = load i64, i64* %R2_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncYr( i64* %Base_Arg, i64* %lncYs, i64* %lncYt, i64 %lncYu, i64 %lncYv, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ccrW:
  %lncYw = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 40, i64* %lncYw, !tbaa !5
  br label %ccrT
ccrT:
  %lncYx = load i64, i64* %lsaK4
  store i64 %lncYx, i64* %R1_Var
  %lncYy = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lncYz = bitcast i64* %lncYy to i64*
  %lncYA = load i64, i64* %lncYz, !tbaa !5
  %lncYB = inttoptr i64 %lncYA to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncYC = load i64*, i64** %Sp_Var
  %lncYD = load i64*, i64** %Hp_Var
  %lncYE = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncYB( i64* %Base_Arg, i64* %lncYC, i64* %lncYD, i64 %lncYE, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saJM_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saJM_info$def to i8*)
define internal ghccc void @saJM_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 5, i32 15, i32 0}>
{
ccrX:
  %lsaJM = alloca i64, i32 1
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %lsaI4 = alloca i64, i32 1
  %lsaI7 = alloca i64, i32 1
  %lsaJt = alloca i64, i32 1
  %lsaJu = alloca i64, i32 1
  %lsaJA = alloca i64, i32 1
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lncYF = load i64, i64* %R1_Var
  store i64 %lncYF, i64* %lsaJM
  %lncYG = load i64*, i64** %Sp_Var
  %lncYH = getelementptr inbounds i64, i64* %lncYG, i32 -4
  %lncYI = ptrtoint i64* %lncYH to i64
  %lncYJ = icmp ult i64 %lncYI, %SpLim_Arg
  %lncYK = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lncYJ, i1 0 )
  br i1 %lncYK, label %ccrY, label %ccrZ
ccrZ:
  %lncYL = load i64*, i64** %Hp_Var
  %lncYM = getelementptr inbounds i64, i64* %lncYL, i32 7
  %lncYN = ptrtoint i64* %lncYM to i64
  %lncYO = inttoptr i64 %lncYN to i64*
  store i64* %lncYO, i64** %Hp_Var
  %lncYP = load i64*, i64** %Hp_Var
  %lncYQ = ptrtoint i64* %lncYP to i64
  %lncYR = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lncYS = bitcast i64* %lncYR to i64*
  %lncYT = load i64, i64* %lncYS, !tbaa !5
  %lncYU = icmp ugt i64 %lncYQ, %lncYT
  %lncYV = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lncYU, i1 0 )
  br i1 %lncYV, label %ccs1, label %ccs0
ccs0:
  %lncYX = ptrtoint i8* @stg_upd_frame_info to i64
  %lncYW = load i64*, i64** %Sp_Var
  %lncYY = getelementptr inbounds i64, i64* %lncYW, i32 -2
  store i64 %lncYX, i64* %lncYY, !tbaa !2
  %lncZ0 = load i64, i64* %lsaJM
  %lncYZ = load i64*, i64** %Sp_Var
  %lncZ1 = getelementptr inbounds i64, i64* %lncYZ, i32 -1
  store i64 %lncZ0, i64* %lncZ1, !tbaa !2
  %lncZ2 = load i64, i64* %lsaJM
  %lncZ3 = add i64 %lncZ2, 16
  %lncZ4 = inttoptr i64 %lncZ3 to i64*
  %lncZ5 = load i64, i64* %lncZ4, !tbaa !1
  store i64 %lncZ5, i64* %lsaI4
  %lncZ6 = load i64, i64* %lsaJM
  %lncZ7 = add i64 %lncZ6, 24
  %lncZ8 = inttoptr i64 %lncZ7 to i64*
  %lncZ9 = load i64, i64* %lncZ8, !tbaa !1
  store i64 %lncZ9, i64* %lsaI7
  %lncZa = load i64, i64* %lsaJM
  %lncZb = add i64 %lncZa, 32
  %lncZc = inttoptr i64 %lncZb to i64*
  %lncZd = load i64, i64* %lncZc, !tbaa !1
  store i64 %lncZd, i64* %lsaJt
  %lncZe = load i64, i64* %lsaJM
  %lncZf = add i64 %lncZe, 40
  %lncZg = inttoptr i64 %lncZf to i64*
  %lncZh = load i64, i64* %lncZg, !tbaa !1
  store i64 %lncZh, i64* %lsaJu
  %lncZi = load i64, i64* %lsaJM
  %lncZj = add i64 %lncZi, 48
  %lncZk = inttoptr i64 %lncZj to i64*
  %lncZl = load i64, i64* %lncZk, !tbaa !1
  store i64 %lncZl, i64* %lsaJA
  %lncZn = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saK4_info$def to i64
  %lncZm = load i64*, i64** %Hp_Var
  %lncZo = getelementptr inbounds i64, i64* %lncZm, i32 -6
  store i64 %lncZn, i64* %lncZo, !tbaa !3
  %lncZq = load i64, i64* %lsaI4
  %lncZp = load i64*, i64** %Hp_Var
  %lncZr = getelementptr inbounds i64, i64* %lncZp, i32 -4
  store i64 %lncZq, i64* %lncZr, !tbaa !3
  %lncZt = load i64, i64* %lsaI7
  %lncZs = load i64*, i64** %Hp_Var
  %lncZu = getelementptr inbounds i64, i64* %lncZs, i32 -3
  store i64 %lncZt, i64* %lncZu, !tbaa !3
  %lncZw = load i64, i64* %lsaJt
  %lncZv = load i64*, i64** %Hp_Var
  %lncZx = getelementptr inbounds i64, i64* %lncZv, i32 -2
  store i64 %lncZw, i64* %lncZx, !tbaa !3
  %lncZz = load i64, i64* %lsaJu
  %lncZy = load i64*, i64** %Hp_Var
  %lncZA = getelementptr inbounds i64, i64* %lncZy, i32 -1
  store i64 %lncZz, i64* %lncZA, !tbaa !3
  %lncZC = load i64, i64* %lsaJA
  %lncZB = load i64*, i64** %Hp_Var
  %lncZD = getelementptr inbounds i64, i64* %lncZB, i32 0
  store i64 %lncZC, i64* %lncZD, !tbaa !3
  %lncZE = load i64, i64* %lsaI4
  store i64 %lncZE, i64* %R2_Var
  %lncZG = ptrtoint i8* @stg_ap_p_info to i64
  %lncZF = load i64*, i64** %Sp_Var
  %lncZH = getelementptr inbounds i64, i64* %lncZF, i32 -4
  store i64 %lncZG, i64* %lncZH, !tbaa !2
  %lncZJ = load i64*, i64** %Hp_Var
  %lncZK = getelementptr inbounds i64, i64* %lncZJ, i32 -6
  %lncZL = ptrtoint i64* %lncZK to i64
  %lncZI = load i64*, i64** %Sp_Var
  %lncZM = getelementptr inbounds i64, i64* %lncZI, i32 -3
  store i64 %lncZL, i64* %lncZM, !tbaa !2
  %lncZN = load i64*, i64** %Sp_Var
  %lncZO = getelementptr inbounds i64, i64* %lncZN, i32 -4
  %lncZP = ptrtoint i64* %lncZO to i64
  %lncZQ = inttoptr i64 %lncZP to i64*
  store i64* %lncZQ, i64** %Sp_Var
  %lncZR = bitcast i8* @base_GHCziNum_zt_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lncZS = load i64*, i64** %Sp_Var
  %lncZT = load i64*, i64** %Hp_Var
  %lncZU = load i64, i64* %R1_Var
  %lncZV = load i64, i64* %R2_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lncZR( i64* %Base_Arg, i64* %lncZS, i64* %lncZT, i64 %lncZU, i64 %lncZV, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ccs1:
  %lncZW = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 56, i64* %lncZW, !tbaa !5
  br label %ccrY
ccrY:
  %lncZX = load i64, i64* %lsaJM
  store i64 %lncZX, i64* %R1_Var
  %lncZY = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lncZZ = bitcast i64* %lncZY to i64*
  %lnd00 = load i64, i64* %lncZZ, !tbaa !5
  %lnd01 = inttoptr i64 %lnd00 to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnd02 = load i64*, i64** %Sp_Var
  %lnd03 = load i64*, i64** %Hp_Var
  %lnd04 = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnd01( i64* %Base_Arg, i64* %lnd02, i64* %lnd03, i64 %lnd04, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saJE_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saJE_info$def to i8*)
define internal ghccc void @saJE_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 8, i32 15, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%ucuO_srt_struct* @ucuO_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saJE_info$def to i64)) to i32),i32 0)}>
{
ccs2:
  %lsaI2 = alloca i64, i32 1
  %lsaI4 = alloca i64, i32 1
  %lsaI5 = alloca i64, i32 1
  %lsaI7 = alloca i64, i32 1
  %lsaJt = alloca i64, i32 1
  %lsaJu = alloca i64, i32 1
  %lsaJA = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnd05 = load i64*, i64** %Sp_Var
  %lnd06 = getelementptr inbounds i64, i64* %lnd05, i32 -14
  %lnd07 = ptrtoint i64* %lnd06 to i64
  %lnd08 = icmp ult i64 %lnd07, %SpLim_Arg
  %lnd09 = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnd08, i1 0 )
  br i1 %lnd09, label %ccs3, label %ccs4
ccs4:
  %lnd0b = ptrtoint i8* @stg_upd_frame_info to i64
  %lnd0a = load i64*, i64** %Sp_Var
  %lnd0c = getelementptr inbounds i64, i64* %lnd0a, i32 -2
  store i64 %lnd0b, i64* %lnd0c, !tbaa !2
  %lnd0e = load i64, i64* %R1_Var
  %lnd0d = load i64*, i64** %Sp_Var
  %lnd0f = getelementptr inbounds i64, i64* %lnd0d, i32 -1
  store i64 %lnd0e, i64* %lnd0f, !tbaa !2
  %lnd0h = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccrb_info$def to i64
  %lnd0g = load i64*, i64** %Sp_Var
  %lnd0i = getelementptr inbounds i64, i64* %lnd0g, i32 -10
  store i64 %lnd0h, i64* %lnd0i, !tbaa !2
  %lnd0l = load i64, i64* %R1_Var
  %lnd0m = add i64 %lnd0l, 16
  %lnd0n = inttoptr i64 %lnd0m to i64*
  %lnd0o = load i64, i64* %lnd0n, !tbaa !4
  store i64 %lnd0o, i64* %lsaI2
  %lnd0r = load i64, i64* %R1_Var
  %lnd0s = add i64 %lnd0r, 24
  %lnd0t = inttoptr i64 %lnd0s to i64*
  %lnd0u = load i64, i64* %lnd0t, !tbaa !4
  store i64 %lnd0u, i64* %lsaI4
  %lnd0x = load i64, i64* %R1_Var
  %lnd0y = add i64 %lnd0x, 32
  %lnd0z = inttoptr i64 %lnd0y to i64*
  %lnd0A = load i64, i64* %lnd0z, !tbaa !4
  store i64 %lnd0A, i64* %lsaI5
  %lnd0D = load i64, i64* %R1_Var
  %lnd0E = add i64 %lnd0D, 40
  %lnd0F = inttoptr i64 %lnd0E to i64*
  %lnd0G = load i64, i64* %lnd0F, !tbaa !4
  store i64 %lnd0G, i64* %lsaI7
  %lnd0J = load i64, i64* %R1_Var
  %lnd0K = add i64 %lnd0J, 56
  %lnd0L = inttoptr i64 %lnd0K to i64*
  %lnd0M = load i64, i64* %lnd0L, !tbaa !4
  store i64 %lnd0M, i64* %lsaJt
  %lnd0P = load i64, i64* %R1_Var
  %lnd0Q = add i64 %lnd0P, 64
  %lnd0R = inttoptr i64 %lnd0Q to i64*
  %lnd0S = load i64, i64* %lnd0R, !tbaa !4
  store i64 %lnd0S, i64* %lsaJu
  %lnd0V = load i64, i64* %R1_Var
  %lnd0W = add i64 %lnd0V, 72
  %lnd0X = inttoptr i64 %lnd0W to i64*
  %lnd0Y = load i64, i64* %lnd0X, !tbaa !4
  store i64 %lnd0Y, i64* %lsaJA
  %lnd11 = load i64, i64* %R1_Var
  %lnd12 = add i64 %lnd11, 48
  %lnd13 = inttoptr i64 %lnd12 to i64*
  %lnd14 = load i64, i64* %lnd13, !tbaa !4
  store i64 %lnd14, i64* %R1_Var
  %lnd16 = load i64, i64* %lsaI2
  %lnd15 = load i64*, i64** %Sp_Var
  %lnd17 = getelementptr inbounds i64, i64* %lnd15, i32 -9
  store i64 %lnd16, i64* %lnd17, !tbaa !2
  %lnd19 = load i64, i64* %lsaI4
  %lnd18 = load i64*, i64** %Sp_Var
  %lnd1a = getelementptr inbounds i64, i64* %lnd18, i32 -8
  store i64 %lnd19, i64* %lnd1a, !tbaa !2
  %lnd1c = load i64, i64* %lsaI5
  %lnd1b = load i64*, i64** %Sp_Var
  %lnd1d = getelementptr inbounds i64, i64* %lnd1b, i32 -7
  store i64 %lnd1c, i64* %lnd1d, !tbaa !2
  %lnd1f = load i64, i64* %lsaI7
  %lnd1e = load i64*, i64** %Sp_Var
  %lnd1g = getelementptr inbounds i64, i64* %lnd1e, i32 -6
  store i64 %lnd1f, i64* %lnd1g, !tbaa !2
  %lnd1i = load i64, i64* %lsaJt
  %lnd1h = load i64*, i64** %Sp_Var
  %lnd1j = getelementptr inbounds i64, i64* %lnd1h, i32 -5
  store i64 %lnd1i, i64* %lnd1j, !tbaa !2
  %lnd1l = load i64, i64* %lsaJu
  %lnd1k = load i64*, i64** %Sp_Var
  %lnd1m = getelementptr inbounds i64, i64* %lnd1k, i32 -4
  store i64 %lnd1l, i64* %lnd1m, !tbaa !2
  %lnd1o = load i64, i64* %lsaJA
  %lnd1n = load i64*, i64** %Sp_Var
  %lnd1p = getelementptr inbounds i64, i64* %lnd1n, i32 -3
  store i64 %lnd1o, i64* %lnd1p, !tbaa !2
  %lnd1q = load i64*, i64** %Sp_Var
  %lnd1r = getelementptr inbounds i64, i64* %lnd1q, i32 -10
  %lnd1s = ptrtoint i64* %lnd1r to i64
  %lnd1t = inttoptr i64 %lnd1s to i64*
  store i64* %lnd1t, i64** %Sp_Var
  %lnd1u = load i64, i64* %R1_Var
  %lnd1v = and i64 %lnd1u, 7
  %lnd1w = icmp ne i64 %lnd1v, 0
  br i1 %lnd1w, label %ucsN, label %ccrc
ccrc:
  %lnd1y = load i64, i64* %R1_Var
  %lnd1z = inttoptr i64 %lnd1y to i64*
  %lnd1A = load i64, i64* %lnd1z, !tbaa !4
  %lnd1B = inttoptr i64 %lnd1A to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnd1C = load i64*, i64** %Sp_Var
  %lnd1D = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnd1B( i64* %Base_Arg, i64* %lnd1C, i64* %Hp_Arg, i64 %lnd1D, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ucsN:
  %lnd1E = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccrb_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnd1F = load i64*, i64** %Sp_Var
  %lnd1G = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnd1E( i64* %Base_Arg, i64* %lnd1F, i64* %Hp_Arg, i64 %lnd1G, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ccs3:
  %lnd1H = load i64, i64* %R1_Var
  store i64 %lnd1H, i64* %R1_Var
  %lnd1I = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lnd1J = bitcast i64* %lnd1I to i64*
  %lnd1K = load i64, i64* %lnd1J, !tbaa !5
  %lnd1L = inttoptr i64 %lnd1K to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnd1M = load i64*, i64** %Sp_Var
  %lnd1N = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnd1L( i64* %Base_Arg, i64* %lnd1M, i64* %Hp_Arg, i64 %lnd1N, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@ccrb_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccrb_info$def to i8*)
define internal ghccc void @ccrb_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 7, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%ucuN_srt_struct* @ucuN_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccrb_info$def to i64)) to i32),i32 0)}>
{
ccrb:
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %lsaJI = alloca i64, i32 1
  %lsaJG = alloca i64, i32 1
  %lsaJH = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnd1P = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccrg_info$def to i64
  %lnd1O = load i64*, i64** %Sp_Var
  %lnd1Q = getelementptr inbounds i64, i64* %lnd1O, i32 -3
  store i64 %lnd1P, i64* %lnd1Q, !tbaa !2
  %lnd1R = ptrtoint i8* @vctrzm0zi12zi0zi2zm9a8f7398_DataziVectorziMutable_uninitialised_closure to i64
  store i64 %lnd1R, i64* %R2_Var
  %lnd1U = load i64, i64* %R1_Var
  %lnd1V = add i64 %lnd1U, 7
  %lnd1W = inttoptr i64 %lnd1V to i64*
  %lnd1X = load i64, i64* %lnd1W, !tbaa !4
  store i64 %lnd1X, i64* %lsaJI
  %lnd20 = load i64, i64* %R1_Var
  %lnd21 = add i64 %lnd20, 15
  %lnd22 = inttoptr i64 %lnd21 to i64*
  %lnd23 = load i64, i64* %lnd22, !tbaa !4
  store i64 %lnd23, i64* %lsaJG
  %lnd26 = load i64, i64* %R1_Var
  %lnd27 = add i64 %lnd26, 23
  %lnd28 = inttoptr i64 %lnd27 to i64*
  %lnd29 = load i64, i64* %lnd28, !tbaa !4
  store i64 %lnd29, i64* %lsaJH
  %lnd2a = load i64, i64* %lsaJH
  store i64 %lnd2a, i64* %R1_Var
  %lnd2c = load i64, i64* %lsaJH
  %lnd2b = load i64*, i64** %Sp_Var
  %lnd2d = getelementptr inbounds i64, i64* %lnd2b, i32 -2
  store i64 %lnd2c, i64* %lnd2d, !tbaa !2
  %lnd2f = load i64, i64* %lsaJI
  %lnd2e = load i64*, i64** %Sp_Var
  %lnd2g = getelementptr inbounds i64, i64* %lnd2e, i32 -1
  store i64 %lnd2f, i64* %lnd2g, !tbaa !2
  %lnd2i = load i64, i64* %lsaJG
  %lnd2h = load i64*, i64** %Sp_Var
  %lnd2j = getelementptr inbounds i64, i64* %lnd2h, i32 0
  store i64 %lnd2i, i64* %lnd2j, !tbaa !2
  %lnd2k = load i64*, i64** %Sp_Var
  %lnd2l = getelementptr inbounds i64, i64* %lnd2k, i32 -3
  %lnd2m = ptrtoint i64* %lnd2l to i64
  %lnd2n = inttoptr i64 %lnd2m to i64*
  store i64* %lnd2n, i64** %Sp_Var
  %lnd2o = bitcast i8* @stg_newArrayzh to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnd2p = load i64*, i64** %Sp_Var
  %lnd2q = load i64, i64* %R1_Var
  %lnd2r = load i64, i64* %R2_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnd2o( i64* %Base_Arg, i64* %lnd2p, i64* %Hp_Arg, i64 %lnd2q, i64 %lnd2r, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@ccrg_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccrg_info$def to i8*)
define internal ghccc void @ccrg_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 330, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%ucuM_srt_struct* @ucuM_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccrg_info$def to i64)) to i32),i32 0)}>
{
ccrg:
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lnd2s = load i64*, i64** %Hp_Var
  %lnd2t = getelementptr inbounds i64, i64* %lnd2s, i32 7
  %lnd2u = ptrtoint i64* %lnd2t to i64
  %lnd2v = inttoptr i64 %lnd2u to i64*
  store i64* %lnd2v, i64** %Hp_Var
  %lnd2w = load i64*, i64** %Hp_Var
  %lnd2x = ptrtoint i64* %lnd2w to i64
  %lnd2y = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lnd2z = bitcast i64* %lnd2y to i64*
  %lnd2A = load i64, i64* %lnd2z, !tbaa !5
  %lnd2B = icmp ugt i64 %lnd2x, %lnd2A
  %lnd2C = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnd2B, i1 0 )
  br i1 %lnd2C, label %ccs8, label %ccs7
ccs7:
  %lnd2E = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saJM_info$def to i64
  %lnd2D = load i64*, i64** %Hp_Var
  %lnd2F = getelementptr inbounds i64, i64* %lnd2D, i32 -6
  store i64 %lnd2E, i64* %lnd2F, !tbaa !3
  %lnd2H = load i64*, i64** %Sp_Var
  %lnd2I = getelementptr inbounds i64, i64* %lnd2H, i32 5
  %lnd2J = bitcast i64* %lnd2I to i64*
  %lnd2K = load i64, i64* %lnd2J, !tbaa !2
  %lnd2G = load i64*, i64** %Hp_Var
  %lnd2L = getelementptr inbounds i64, i64* %lnd2G, i32 -4
  store i64 %lnd2K, i64* %lnd2L, !tbaa !3
  %lnd2N = load i64*, i64** %Sp_Var
  %lnd2O = getelementptr inbounds i64, i64* %lnd2N, i32 7
  %lnd2P = bitcast i64* %lnd2O to i64*
  %lnd2Q = load i64, i64* %lnd2P, !tbaa !2
  %lnd2M = load i64*, i64** %Hp_Var
  %lnd2R = getelementptr inbounds i64, i64* %lnd2M, i32 -3
  store i64 %lnd2Q, i64* %lnd2R, !tbaa !3
  %lnd2T = load i64*, i64** %Sp_Var
  %lnd2U = getelementptr inbounds i64, i64* %lnd2T, i32 8
  %lnd2V = bitcast i64* %lnd2U to i64*
  %lnd2W = load i64, i64* %lnd2V, !tbaa !2
  %lnd2S = load i64*, i64** %Hp_Var
  %lnd2X = getelementptr inbounds i64, i64* %lnd2S, i32 -2
  store i64 %lnd2W, i64* %lnd2X, !tbaa !3
  %lnd2Z = load i64*, i64** %Sp_Var
  %lnd30 = getelementptr inbounds i64, i64* %lnd2Z, i32 9
  %lnd31 = bitcast i64* %lnd30 to i64*
  %lnd32 = load i64, i64* %lnd31, !tbaa !2
  %lnd2Y = load i64*, i64** %Hp_Var
  %lnd33 = getelementptr inbounds i64, i64* %lnd2Y, i32 -1
  store i64 %lnd32, i64* %lnd33, !tbaa !3
  %lnd35 = load i64*, i64** %Sp_Var
  %lnd36 = getelementptr inbounds i64, i64* %lnd35, i32 10
  %lnd37 = bitcast i64* %lnd36 to i64*
  %lnd38 = load i64, i64* %lnd37, !tbaa !2
  %lnd34 = load i64*, i64** %Hp_Var
  %lnd39 = getelementptr inbounds i64, i64* %lnd34, i32 0
  store i64 %lnd38, i64* %lnd39, !tbaa !3
  %lnd3a = load i64*, i64** %Sp_Var
  %lnd3b = getelementptr inbounds i64, i64* %lnd3a, i32 0
  store i64 0, i64* %lnd3b, !tbaa !2
  %lnd3c = load i64*, i64** %Sp_Var
  %lnd3d = getelementptr inbounds i64, i64* %lnd3c, i32 7
  store i64 0, i64* %lnd3d, !tbaa !2
  %lnd3f = load i64, i64* %R1_Var
  %lnd3e = load i64*, i64** %Sp_Var
  %lnd3g = getelementptr inbounds i64, i64* %lnd3e, i32 8
  store i64 %lnd3f, i64* %lnd3g, !tbaa !2
  %lnd3i = load i64*, i64** %Hp_Var
  %lnd3j = getelementptr inbounds i64, i64* %lnd3i, i32 -6
  %lnd3k = ptrtoint i64* %lnd3j to i64
  %lnd3h = load i64*, i64** %Sp_Var
  %lnd3l = getelementptr inbounds i64, i64* %lnd3h, i32 9
  store i64 %lnd3k, i64* %lnd3l, !tbaa !2
  %lnd3m = load i64*, i64** %Sp_Var
  %lnd3n = getelementptr inbounds i64, i64* %lnd3m, i32 -1
  %lnd3o = ptrtoint i64* %lnd3n to i64
  %lnd3p = inttoptr i64 %lnd3o to i64*
  store i64* %lnd3p, i64** %Sp_Var
  %lnd3q = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccsj_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnd3r = load i64*, i64** %Sp_Var
  %lnd3s = load i64*, i64** %Hp_Var
  %lnd3t = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnd3q( i64* %Base_Arg, i64* %lnd3r, i64* %lnd3s, i64 %lnd3t, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ccs8:
  %lnd3u = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 56, i64* %lnd3u, !tbaa !5
  %lnd3v = load i64, i64* %R1_Var
  store i64 %lnd3v, i64* %R1_Var
  %lnd3w = bitcast i8* @stg_gc_unpt_r1 to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnd3x = load i64*, i64** %Sp_Var
  %lnd3y = load i64*, i64** %Hp_Var
  %lnd3z = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnd3w( i64* %Base_Arg, i64* %lnd3x, i64* %lnd3y, i64 %lnd3z, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@ccsj_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccsj_info$def to i8*)
define internal ghccc void @ccsj_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 8907, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%ucuL_srt_struct* @ucuL_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccsj_info$def to i64)) to i32),i32 0)}>
{
ccsj:
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %lsaKe = alloca i64, i32 1
  %lsaKf = alloca i64, i32 1
  %lsaJL = alloca i64, i32 1
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R5_Var = alloca i64, i32 1
  store i64 undef, i64* %R5_Var
  %R6_Var = alloca i64, i32 1
  store i64 undef, i64* %R6_Var
  %F1_Var = alloca float, i32 1
  store float undef, float* %F1_Var
  %D1_Var = alloca double, i32 1
  store double undef, double* %D1_Var
  %F2_Var = alloca float, i32 1
  store float undef, float* %F2_Var
  %D2_Var = alloca double, i32 1
  store double undef, double* %D2_Var
  %F3_Var = alloca float, i32 1
  store float undef, float* %F3_Var
  %D3_Var = alloca double, i32 1
  store double undef, double* %D3_Var
  %F4_Var = alloca float, i32 1
  store float undef, float* %F4_Var
  %D4_Var = alloca double, i32 1
  store double undef, double* %D4_Var
  %F5_Var = alloca float, i32 1
  store float undef, float* %F5_Var
  %D5_Var = alloca double, i32 1
  store double undef, double* %D5_Var
  %F6_Var = alloca float, i32 1
  store float undef, float* %F6_Var
  %D6_Var = alloca double, i32 1
  store double undef, double* %D6_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnd3A = load i64*, i64** %Hp_Var
  %lnd3B = getelementptr inbounds i64, i64* %lnd3A, i32 4
  %lnd3C = ptrtoint i64* %lnd3B to i64
  %lnd3D = inttoptr i64 %lnd3C to i64*
  store i64* %lnd3D, i64** %Hp_Var
  %lnd3E = load i64*, i64** %Hp_Var
  %lnd3F = ptrtoint i64* %lnd3E to i64
  %lnd3G = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lnd3H = bitcast i64* %lnd3G to i64*
  %lnd3I = load i64, i64* %lnd3H, !tbaa !5
  %lnd3J = icmp ugt i64 %lnd3F, %lnd3I
  %lnd3K = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnd3J, i1 0 )
  br i1 %lnd3K, label %ccso, label %ccsn
ccsn:
  %lnd3L = load i64*, i64** %Sp_Var
  %lnd3M = getelementptr inbounds i64, i64* %lnd3L, i32 8
  %lnd3N = bitcast i64* %lnd3M to i64*
  %lnd3O = load i64, i64* %lnd3N, !tbaa !2
  store i64 %lnd3O, i64* %lsaKe
  %lnd3P = load i64*, i64** %Sp_Var
  %lnd3Q = getelementptr inbounds i64, i64* %lnd3P, i32 1
  %lnd3R = bitcast i64* %lnd3Q to i64*
  %lnd3S = load i64, i64* %lnd3R, !tbaa !2
  store i64 %lnd3S, i64* %lsaKf
  %lnd3T = load i64, i64* %lsaKe
  %lnd3U = load i64*, i64** %Sp_Var
  %lnd3V = getelementptr inbounds i64, i64* %lnd3U, i32 2
  %lnd3W = bitcast i64* %lnd3V to i64*
  %lnd3X = load i64, i64* %lnd3W, !tbaa !2
  %lnd3Y = icmp sge i64 %lnd3T, %lnd3X
  %lnd3Z = zext i1 %lnd3Y to i64
  switch i64 %lnd3Z, label %ccss [i64 1, label %ccst]
ccss:
  %lnd41 = ptrtoint i8* @stg_ap_2_upd_info to i64
  %lnd40 = load i64*, i64** %Hp_Var
  %lnd42 = getelementptr inbounds i64, i64* %lnd40, i32 -3
  store i64 %lnd41, i64* %lnd42, !tbaa !3
  %lnd44 = load i64*, i64** %Sp_Var
  %lnd45 = getelementptr inbounds i64, i64* %lnd44, i32 10
  %lnd46 = bitcast i64* %lnd45 to i64*
  %lnd47 = load i64, i64* %lnd46, !tbaa !2
  %lnd43 = load i64*, i64** %Hp_Var
  %lnd48 = getelementptr inbounds i64, i64* %lnd43, i32 -1
  store i64 %lnd47, i64* %lnd48, !tbaa !3
  %lnd4a = load i64*, i64** %Sp_Var
  %lnd4b = getelementptr inbounds i64, i64* %lnd4a, i32 3
  %lnd4c = bitcast i64* %lnd4b to i64*
  %lnd4d = load i64, i64* %lnd4c, !tbaa !2
  %lnd4e = load i64*, i64** %Sp_Var
  %lnd4f = getelementptr inbounds i64, i64* %lnd4e, i32 4
  %lnd4g = bitcast i64* %lnd4f to i64*
  %lnd4h = load i64, i64* %lnd4g, !tbaa !2
  %lnd4i = load i64, i64* %lsaKe
  %lnd4j = add i64 %lnd4h, %lnd4i
  %lnd4k = shl i64 %lnd4j, 3
  %lnd4l = add i64 %lnd4k, 24
  %lnd4m = add i64 %lnd4d, %lnd4l
  %lnd4n = inttoptr i64 %lnd4m to i64*
  %lnd4o = load i64, i64* %lnd4n, !tbaa !1
  %lnd49 = load i64*, i64** %Hp_Var
  %lnd4p = getelementptr inbounds i64, i64* %lnd49, i32 0
  store i64 %lnd4o, i64* %lnd4p, !tbaa !3
  %lnd4q = load i64*, i64** %Sp_Var
  %lnd4r = getelementptr inbounds i64, i64* %lnd4q, i32 9
  %lnd4s = bitcast i64* %lnd4r to i64*
  %lnd4t = load i64, i64* %lnd4s, !tbaa !2
  store i64 %lnd4t, i64* %lsaJL
  %lnd4u = load i64, i64* %lsaJL
  %lnd4v = add i64 %lnd4u, 24
  %lnd4w = load i64, i64* %lsaKf
  %lnd4x = shl i64 %lnd4w, 3
  %lnd4y = add i64 %lnd4v, %lnd4x
  %lnd4z = load i64*, i64** %Hp_Var
  %lnd4A = getelementptr inbounds i64, i64* %lnd4z, i32 -3
  %lnd4B = ptrtoint i64* %lnd4A to i64
  %lnd4C = inttoptr i64 %lnd4y to i64*
  store i64 %lnd4B, i64* %lnd4C, !tbaa !1
  %lnd4D = load i64, i64* %lsaJL
  %lnd4E = ptrtoint i8* @stg_MUT_ARR_PTRS_DIRTY_info to i64
  %lnd4F = inttoptr i64 %lnd4D to i64*
  store i64 %lnd4E, i64* %lnd4F, !tbaa !1
  %lnd4G = load i64, i64* %lsaJL
  %lnd4H = add i64 %lnd4G, 24
  %lnd4I = load i64, i64* %lsaJL
  %lnd4J = add i64 %lnd4I, 8
  %lnd4K = inttoptr i64 %lnd4J to i64*
  %lnd4L = load i64, i64* %lnd4K, !tbaa !1
  %lnd4M = shl i64 %lnd4L, 3
  %lnd4N = load i64, i64* %lsaKf
  %lnd4O = lshr i64 %lnd4N, 7
  %lnd4P = add i64 %lnd4M, %lnd4O
  %lnd4Q = add i64 %lnd4H, %lnd4P
  %lnd4R = inttoptr i64 %lnd4Q to i8*
  store i8 1, i8* %lnd4R, !tbaa !1
  %lnd4T = load i64, i64* %lsaKe
  %lnd4U = add i64 %lnd4T, 1
  %lnd4S = load i64*, i64** %Sp_Var
  %lnd4V = getelementptr inbounds i64, i64* %lnd4S, i32 8
  store i64 %lnd4U, i64* %lnd4V, !tbaa !2
  %lnd4X = load i64, i64* %lsaKf
  %lnd4Y = add i64 %lnd4X, 1
  %lnd4W = load i64*, i64** %Sp_Var
  %lnd4Z = getelementptr inbounds i64, i64* %lnd4W, i32 1
  store i64 %lnd4Y, i64* %lnd4Z, !tbaa !2
  %lnd50 = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccsj_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnd51 = load i64*, i64** %Sp_Var
  %lnd52 = load i64*, i64** %Hp_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnd50( i64* %Base_Arg, i64* %lnd51, i64* %lnd52, i64 %R1_Arg, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ccst:
  %lnd53 = load i64*, i64** %Hp_Var
  %lnd54 = getelementptr inbounds i64, i64* %lnd53, i32 -4
  %lnd55 = ptrtoint i64* %lnd54 to i64
  %lnd56 = inttoptr i64 %lnd55 to i64*
  store i64* %lnd56, i64** %Hp_Var
  %lnd58 = load i64, i64* %lsaKf
  %lnd57 = load i64*, i64** %Sp_Var
  %lnd59 = getelementptr inbounds i64, i64* %lnd57, i32 10
  store i64 %lnd58, i64* %lnd59, !tbaa !2
  %lnd5a = load i64*, i64** %Sp_Var
  %lnd5b = getelementptr inbounds i64, i64* %lnd5a, i32 5
  %lnd5c = ptrtoint i64* %lnd5b to i64
  %lnd5d = inttoptr i64 %lnd5c to i64*
  store i64* %lnd5d, i64** %Sp_Var
  %lnd5e = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @_ccsc$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnd5f = load i64*, i64** %Sp_Var
  %lnd5g = load i64*, i64** %Hp_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnd5e( i64* %Base_Arg, i64* %lnd5f, i64* %lnd5g, i64 %R1_Arg, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ccso:
  %lnd5h = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 32, i64* %lnd5h, !tbaa !5
  %lnd5j = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccsj_info$def to i64
  %lnd5i = load i64*, i64** %Sp_Var
  %lnd5k = getelementptr inbounds i64, i64* %lnd5i, i32 0
  store i64 %lnd5j, i64* %lnd5k, !tbaa !2
  %lnd5l = bitcast i8* @stg_gc_noregs to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnd5m = load i64*, i64** %Sp_Var
  %lnd5n = load i64*, i64** %Hp_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnd5l( i64* %Base_Arg, i64* %lnd5m, i64* %lnd5n, i64 %R1_Arg, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@_ccsc = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @_ccsc$def to i8*)
define internal ghccc void @_ccsc$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind
{
ccsc:
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %lsaK7 = alloca i64, i32 1
  %lsaJL = alloca i64, i32 1
  %R6_Var = alloca i64, i32 1
  store i64 undef, i64* %R6_Var
  %R5_Var = alloca i64, i32 1
  store i64 undef, i64* %R5_Var
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lnd5o = load i64*, i64** %Hp_Var
  %lnd5p = getelementptr inbounds i64, i64* %lnd5o, i32 4
  %lnd5q = ptrtoint i64* %lnd5p to i64
  %lnd5r = inttoptr i64 %lnd5q to i64*
  store i64* %lnd5r, i64** %Hp_Var
  %lnd5s = load i64*, i64** %Sp_Var
  %lnd5t = getelementptr inbounds i64, i64* %lnd5s, i32 5
  %lnd5u = bitcast i64* %lnd5t to i64*
  %lnd5v = load i64, i64* %lnd5u, !tbaa !2
  store i64 %lnd5v, i64* %lsaK7
  %lnd5w = load i64*, i64** %Hp_Var
  %lnd5x = ptrtoint i64* %lnd5w to i64
  %lnd5y = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lnd5z = bitcast i64* %lnd5y to i64*
  %lnd5A = load i64, i64* %lnd5z, !tbaa !5
  %lnd5B = icmp ugt i64 %lnd5x, %lnd5A
  %lnd5C = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnd5B, i1 0 )
  br i1 %lnd5C, label %ccsg, label %ccsf
ccsf:
  %lnd5D = load i64*, i64** %Sp_Var
  %lnd5E = getelementptr inbounds i64, i64* %lnd5D, i32 4
  %lnd5F = bitcast i64* %lnd5E to i64*
  %lnd5G = load i64, i64* %lnd5F, !tbaa !2
  store i64 %lnd5G, i64* %lsaJL
  %lnd5H = load i64, i64* %lsaJL
  %lnd5I = ptrtoint i8* @stg_MUT_ARR_PTRS_FROZEN_DIRTY_info to i64
  %lnd5J = inttoptr i64 %lnd5H to i64*
  store i64 %lnd5I, i64* %lnd5J, !tbaa !1
  %lnd5L = ptrtoint i8* @vctrzm0zi12zi0zi2zm9a8f7398_DataziVector_Vector_con_info to i64
  %lnd5K = load i64*, i64** %Hp_Var
  %lnd5M = getelementptr inbounds i64, i64* %lnd5K, i32 -3
  store i64 %lnd5L, i64* %lnd5M, !tbaa !3
  %lnd5O = load i64, i64* %lsaJL
  %lnd5N = load i64*, i64** %Hp_Var
  %lnd5P = getelementptr inbounds i64, i64* %lnd5N, i32 -2
  store i64 %lnd5O, i64* %lnd5P, !tbaa !3
  %lnd5Q = load i64*, i64** %Hp_Var
  %lnd5R = getelementptr inbounds i64, i64* %lnd5Q, i32 -1
  store i64 0, i64* %lnd5R, !tbaa !3
  %lnd5T = load i64, i64* %lsaK7
  %lnd5S = load i64*, i64** %Hp_Var
  %lnd5U = getelementptr inbounds i64, i64* %lnd5S, i32 0
  store i64 %lnd5T, i64* %lnd5U, !tbaa !3
  %lnd5V = load i64*, i64** %Sp_Var
  %lnd5W = getelementptr inbounds i64, i64* %lnd5V, i32 0
  %lnd5X = bitcast i64* %lnd5W to i64*
  %lnd5Y = load i64, i64* %lnd5X, !tbaa !2
  store i64 %lnd5Y, i64* %R6_Var
  %lnd60 = load i64*, i64** %Hp_Var
  %lnd61 = ptrtoint i64* %lnd60 to i64
  %lnd62 = add i64 %lnd61, -23
  store i64 %lnd62, i64* %R5_Var
  %lnd63 = load i64*, i64** %Sp_Var
  %lnd64 = getelementptr inbounds i64, i64* %lnd63, i32 6
  %lnd65 = bitcast i64* %lnd64 to i64*
  %lnd66 = load i64, i64* %lnd65, !tbaa !2
  store i64 %lnd66, i64* %R4_Var
  %lnd67 = load i64*, i64** %Sp_Var
  %lnd68 = getelementptr inbounds i64, i64* %lnd67, i32 2
  %lnd69 = bitcast i64* %lnd68 to i64*
  %lnd6a = load i64, i64* %lnd69, !tbaa !2
  store i64 %lnd6a, i64* %R3_Var
  %lnd6b = load i64*, i64** %Sp_Var
  %lnd6c = getelementptr inbounds i64, i64* %lnd6b, i32 1
  %lnd6d = bitcast i64* %lnd6c to i64*
  %lnd6e = load i64, i64* %lnd6d, !tbaa !2
  store i64 %lnd6e, i64* %R2_Var
  %lnd6f = load i64*, i64** %Sp_Var
  %lnd6g = getelementptr inbounds i64, i64* %lnd6f, i32 7
  %lnd6h = ptrtoint i64* %lnd6g to i64
  %lnd6i = inttoptr i64 %lnd6h to i64*
  store i64* %lnd6i, i64** %Sp_Var
  %lnd6j = bitcast i8* @hblaszm0zi0zi0zi0zminplace_HBLASziLevel1_axpyzq_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnd6k = load i64*, i64** %Sp_Var
  %lnd6l = load i64*, i64** %Hp_Var
  %lnd6m = load i64, i64* %R1_Var
  %lnd6n = load i64, i64* %R2_Var
  %lnd6o = load i64, i64* %R3_Var
  %lnd6p = load i64, i64* %R4_Var
  %lnd6q = load i64, i64* %R5_Var
  %lnd6r = load i64, i64* %R6_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnd6j( i64* %Base_Arg, i64* %lnd6k, i64* %lnd6l, i64 %lnd6m, i64 %lnd6n, i64 %lnd6o, i64 %lnd6p, i64 %lnd6q, i64 %lnd6r, i64 %SpLim_Arg ) nounwind
  ret void
ccsg:
  %lnd6s = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 32, i64* %lnd6s, !tbaa !5
  %lnd6u = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccsb_info$def to i64
  %lnd6t = load i64*, i64** %Sp_Var
  %lnd6v = getelementptr inbounds i64, i64* %lnd6t, i32 -1
  store i64 %lnd6u, i64* %lnd6v, !tbaa !2
  %lnd6w = load i64, i64* %lsaK7
  store i64 %lnd6w, i64* %R1_Var
  %lnd6x = load i64*, i64** %Sp_Var
  %lnd6y = getelementptr inbounds i64, i64* %lnd6x, i32 -1
  %lnd6z = ptrtoint i64* %lnd6y to i64
  %lnd6A = inttoptr i64 %lnd6z to i64*
  store i64* %lnd6A, i64** %Sp_Var
  %lnd6B = bitcast i8* @stg_gc_unbx_r1 to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnd6C = load i64*, i64** %Sp_Var
  %lnd6D = load i64*, i64** %Hp_Var
  %lnd6E = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnd6B( i64* %Base_Arg, i64* %lnd6C, i64* %lnd6D, i64 %lnd6E, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@ccsb_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccsb_info$def to i8*)
define internal ghccc void @ccsb_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 2567, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%ucuI_srt_struct* @ucuI_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccsb_info$def to i64)) to i32),i32 0)}>
{
ccsb:
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnd6F = load i64*, i64** %Sp_Var
  %lnd6G = getelementptr inbounds i64, i64* %lnd6F, i32 6
  store i64 %R1_Arg, i64* %lnd6G, !tbaa !2
  %lnd6H = load i64*, i64** %Sp_Var
  %lnd6I = getelementptr inbounds i64, i64* %lnd6H, i32 1
  %lnd6J = ptrtoint i64* %lnd6I to i64
  %lnd6K = inttoptr i64 %lnd6J to i64*
  store i64* %lnd6K, i64** %Sp_Var
  %lnd6L = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @_ccsc$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnd6M = load i64*, i64** %Sp_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnd6L( i64* %Base_Arg, i64* %lnd6M, i64* %Hp_Arg, i64 %R1_Arg, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saKr_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saKr_info$def to i8*)
define internal ghccc void @saKr_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 3, i32 15, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%ucuK_srt_struct* @ucuK_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saKr_info$def to i64)) to i32),i32 0)}>
{
ccsW:
  %lsaI4 = alloca i64, i32 1
  %lsaJE = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnd6N = load i64*, i64** %Sp_Var
  %lnd6O = getelementptr inbounds i64, i64* %lnd6N, i32 -5
  %lnd6P = ptrtoint i64* %lnd6O to i64
  %lnd6Q = icmp ult i64 %lnd6P, %SpLim_Arg
  %lnd6R = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnd6Q, i1 0 )
  br i1 %lnd6R, label %ccsX, label %ccsY
ccsY:
  %lnd6T = ptrtoint i8* @stg_upd_frame_info to i64
  %lnd6S = load i64*, i64** %Sp_Var
  %lnd6U = getelementptr inbounds i64, i64* %lnd6S, i32 -2
  store i64 %lnd6T, i64* %lnd6U, !tbaa !2
  %lnd6W = load i64, i64* %R1_Var
  %lnd6V = load i64*, i64** %Sp_Var
  %lnd6X = getelementptr inbounds i64, i64* %lnd6V, i32 -1
  store i64 %lnd6W, i64* %lnd6X, !tbaa !2
  %lnd6Z = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccsT_info$def to i64
  %lnd6Y = load i64*, i64** %Sp_Var
  %lnd70 = getelementptr inbounds i64, i64* %lnd6Y, i32 -5
  store i64 %lnd6Z, i64* %lnd70, !tbaa !2
  %lnd73 = load i64, i64* %R1_Var
  %lnd74 = add i64 %lnd73, 24
  %lnd75 = inttoptr i64 %lnd74 to i64*
  %lnd76 = load i64, i64* %lnd75, !tbaa !4
  store i64 %lnd76, i64* %lsaI4
  %lnd79 = load i64, i64* %R1_Var
  %lnd7a = add i64 %lnd79, 32
  %lnd7b = inttoptr i64 %lnd7a to i64*
  %lnd7c = load i64, i64* %lnd7b, !tbaa !4
  store i64 %lnd7c, i64* %lsaJE
  %lnd7f = load i64, i64* %R1_Var
  %lnd7g = add i64 %lnd7f, 16
  %lnd7h = inttoptr i64 %lnd7g to i64*
  %lnd7i = load i64, i64* %lnd7h, !tbaa !4
  store i64 %lnd7i, i64* %R1_Var
  %lnd7k = load i64, i64* %lsaI4
  %lnd7j = load i64*, i64** %Sp_Var
  %lnd7l = getelementptr inbounds i64, i64* %lnd7j, i32 -4
  store i64 %lnd7k, i64* %lnd7l, !tbaa !2
  %lnd7n = load i64, i64* %lsaJE
  %lnd7m = load i64*, i64** %Sp_Var
  %lnd7o = getelementptr inbounds i64, i64* %lnd7m, i32 -3
  store i64 %lnd7n, i64* %lnd7o, !tbaa !2
  %lnd7p = load i64*, i64** %Sp_Var
  %lnd7q = getelementptr inbounds i64, i64* %lnd7p, i32 -5
  %lnd7r = ptrtoint i64* %lnd7q to i64
  %lnd7s = inttoptr i64 %lnd7r to i64*
  store i64* %lnd7s, i64** %Sp_Var
  %lnd7t = load i64, i64* %R1_Var
  %lnd7u = and i64 %lnd7t, 7
  %lnd7v = icmp ne i64 %lnd7u, 0
  br i1 %lnd7v, label %uct2, label %ccsU
ccsU:
  %lnd7x = load i64, i64* %R1_Var
  %lnd7y = inttoptr i64 %lnd7x to i64*
  %lnd7z = load i64, i64* %lnd7y, !tbaa !4
  %lnd7A = inttoptr i64 %lnd7z to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnd7B = load i64*, i64** %Sp_Var
  %lnd7C = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnd7A( i64* %Base_Arg, i64* %lnd7B, i64* %Hp_Arg, i64 %lnd7C, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
uct2:
  %lnd7D = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccsT_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnd7E = load i64*, i64** %Sp_Var
  %lnd7F = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnd7D( i64* %Base_Arg, i64* %lnd7E, i64* %Hp_Arg, i64 %lnd7F, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ccsX:
  %lnd7G = load i64, i64* %R1_Var
  store i64 %lnd7G, i64* %R1_Var
  %lnd7H = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lnd7I = bitcast i64* %lnd7H to i64*
  %lnd7J = load i64, i64* %lnd7I, !tbaa !5
  %lnd7K = inttoptr i64 %lnd7J to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnd7L = load i64*, i64** %Sp_Var
  %lnd7M = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnd7K( i64* %Base_Arg, i64* %lnd7L, i64* %Hp_Arg, i64 %lnd7M, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@ccsT_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccsT_info$def to i8*)
define internal ghccc void @ccsT_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 2, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%ucuJ_srt_struct* @ucuJ_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccsT_info$def to i64)) to i32),i32 0)}>
{
ccsT:
  %R6_Var = alloca i64, i32 1
  store i64 undef, i64* %R6_Var
  %R5_Var = alloca i64, i32 1
  store i64 undef, i64* %R5_Var
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnd7N = load i64*, i64** %Sp_Var
  %lnd7O = getelementptr inbounds i64, i64* %lnd7N, i32 2
  %lnd7P = bitcast i64* %lnd7O to i64*
  %lnd7Q = load i64, i64* %lnd7P, !tbaa !2
  store i64 %lnd7Q, i64* %R6_Var
  %lnd7R = add i64 %R1_Arg, 7
  %lnd7S = inttoptr i64 %lnd7R to i64*
  %lnd7T = load i64, i64* %lnd7S, !tbaa !4
  store i64 %lnd7T, i64* %R5_Var
  %lnd7U = add i64 %R1_Arg, 23
  %lnd7V = inttoptr i64 %lnd7U to i64*
  %lnd7W = load i64, i64* %lnd7V, !tbaa !4
  store i64 %lnd7W, i64* %R4_Var
  %lnd7X = add i64 %R1_Arg, 15
  %lnd7Y = inttoptr i64 %lnd7X to i64*
  %lnd7Z = load i64, i64* %lnd7Y, !tbaa !4
  store i64 %lnd7Z, i64* %R3_Var
  %lnd80 = load i64*, i64** %Sp_Var
  %lnd81 = getelementptr inbounds i64, i64* %lnd80, i32 1
  %lnd82 = bitcast i64* %lnd81 to i64*
  %lnd83 = load i64, i64* %lnd82, !tbaa !2
  store i64 %lnd83, i64* %R2_Var
  %lnd84 = load i64*, i64** %Sp_Var
  %lnd85 = getelementptr inbounds i64, i64* %lnd84, i32 3
  %lnd86 = ptrtoint i64* %lnd85 to i64
  %lnd87 = inttoptr i64 %lnd86 to i64*
  store i64* %lnd87, i64** %Sp_Var
  %lnd88 = bitcast i8* @hblaszm0zi0zi0zi0zminplace_HBLASziLevel2_zdwgemvzq_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnd89 = load i64*, i64** %Sp_Var
  %lnd8a = load i64, i64* %R2_Var
  %lnd8b = load i64, i64* %R3_Var
  %lnd8c = load i64, i64* %R4_Var
  %lnd8d = load i64, i64* %R5_Var
  %lnd8e = load i64, i64* %R6_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnd88( i64* %Base_Arg, i64* %lnd89, i64* %Hp_Arg, i64 %R1_Arg, i64 %lnd8a, i64 %lnd8b, i64 %lnd8c, i64 %lnd8d, i64 %lnd8e, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saKw_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saKw_info$def to i8*)
define internal ghccc void @saKw_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 3, i32 15, i32 0}>
{
cct8:
  %lsaJE = alloca i64, i32 1
  %lsaKr = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnd8f = load i64*, i64** %Sp_Var
  %lnd8g = getelementptr inbounds i64, i64* %lnd8f, i32 -9
  %lnd8h = ptrtoint i64* %lnd8g to i64
  %lnd8i = icmp ult i64 %lnd8h, %SpLim_Arg
  %lnd8j = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnd8i, i1 0 )
  br i1 %lnd8j, label %ccth, label %ccti
ccti:
  %lnd8l = ptrtoint i8* @stg_upd_frame_info to i64
  %lnd8k = load i64*, i64** %Sp_Var
  %lnd8m = getelementptr inbounds i64, i64* %lnd8k, i32 -2
  store i64 %lnd8l, i64* %lnd8m, !tbaa !2
  %lnd8o = load i64, i64* %R1_Var
  %lnd8n = load i64*, i64** %Sp_Var
  %lnd8p = getelementptr inbounds i64, i64* %lnd8n, i32 -1
  store i64 %lnd8o, i64* %lnd8p, !tbaa !2
  %lnd8r = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cct5_info$def to i64
  %lnd8q = load i64*, i64** %Sp_Var
  %lnd8s = getelementptr inbounds i64, i64* %lnd8q, i32 -5
  store i64 %lnd8r, i64* %lnd8s, !tbaa !2
  %lnd8v = load i64, i64* %R1_Var
  %lnd8w = add i64 %lnd8v, 24
  %lnd8x = inttoptr i64 %lnd8w to i64*
  %lnd8y = load i64, i64* %lnd8x, !tbaa !4
  store i64 %lnd8y, i64* %lsaJE
  %lnd8B = load i64, i64* %R1_Var
  %lnd8C = add i64 %lnd8B, 32
  %lnd8D = inttoptr i64 %lnd8C to i64*
  %lnd8E = load i64, i64* %lnd8D, !tbaa !4
  store i64 %lnd8E, i64* %lsaKr
  %lnd8H = load i64, i64* %R1_Var
  %lnd8I = add i64 %lnd8H, 16
  %lnd8J = inttoptr i64 %lnd8I to i64*
  %lnd8K = load i64, i64* %lnd8J, !tbaa !4
  store i64 %lnd8K, i64* %R1_Var
  %lnd8M = load i64, i64* %lsaJE
  %lnd8L = load i64*, i64** %Sp_Var
  %lnd8N = getelementptr inbounds i64, i64* %lnd8L, i32 -4
  store i64 %lnd8M, i64* %lnd8N, !tbaa !2
  %lnd8P = load i64, i64* %lsaKr
  %lnd8O = load i64*, i64** %Sp_Var
  %lnd8Q = getelementptr inbounds i64, i64* %lnd8O, i32 -3
  store i64 %lnd8P, i64* %lnd8Q, !tbaa !2
  %lnd8R = load i64*, i64** %Sp_Var
  %lnd8S = getelementptr inbounds i64, i64* %lnd8R, i32 -5
  %lnd8T = ptrtoint i64* %lnd8S to i64
  %lnd8U = inttoptr i64 %lnd8T to i64*
  store i64* %lnd8U, i64** %Sp_Var
  %lnd8V = load i64, i64* %R1_Var
  %lnd8W = and i64 %lnd8V, 7
  %lnd8X = icmp ne i64 %lnd8W, 0
  br i1 %lnd8X, label %uctr, label %cct6
cct6:
  %lnd8Z = load i64, i64* %R1_Var
  %lnd90 = inttoptr i64 %lnd8Z to i64*
  %lnd91 = load i64, i64* %lnd90, !tbaa !4
  %lnd92 = inttoptr i64 %lnd91 to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnd93 = load i64*, i64** %Sp_Var
  %lnd94 = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnd92( i64* %Base_Arg, i64* %lnd93, i64* %Hp_Arg, i64 %lnd94, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
uctr:
  %lnd95 = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cct5_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnd96 = load i64*, i64** %Sp_Var
  %lnd97 = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnd95( i64* %Base_Arg, i64* %lnd96, i64* %Hp_Arg, i64 %lnd97, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ccth:
  %lnd98 = load i64, i64* %R1_Var
  store i64 %lnd98, i64* %R1_Var
  %lnd99 = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lnd9a = bitcast i64* %lnd99 to i64*
  %lnd9b = load i64, i64* %lnd9a, !tbaa !5
  %lnd9c = inttoptr i64 %lnd9b to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnd9d = load i64*, i64** %Sp_Var
  %lnd9e = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnd9c( i64* %Base_Arg, i64* %lnd9d, i64* %Hp_Arg, i64 %lnd9e, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cct5_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cct5_info$def to i8*)
define internal ghccc void @cct5_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 2, i32 30, i32 0}>
{
cct5:
  %lsaKy = alloca i64, i32 1
  %lsaKA = alloca i64, i32 1
  %lsaKE = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnd9g = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cctb_info$def to i64
  %lnd9f = load i64*, i64** %Sp_Var
  %lnd9h = getelementptr inbounds i64, i64* %lnd9f, i32 -2
  store i64 %lnd9g, i64* %lnd9h, !tbaa !2
  %lnd9k = load i64, i64* %R1_Var
  %lnd9l = add i64 %lnd9k, 7
  %lnd9m = inttoptr i64 %lnd9l to i64*
  %lnd9n = load i64, i64* %lnd9m, !tbaa !4
  store i64 %lnd9n, i64* %lsaKy
  %lnd9q = load i64, i64* %R1_Var
  %lnd9r = add i64 %lnd9q, 23
  %lnd9s = inttoptr i64 %lnd9r to i64*
  %lnd9t = load i64, i64* %lnd9s, !tbaa !4
  store i64 %lnd9t, i64* %lsaKA
  %lnd9w = load i64, i64* %R1_Var
  %lnd9x = add i64 %lnd9w, 55
  %lnd9y = inttoptr i64 %lnd9x to i64*
  %lnd9z = load i64, i64* %lnd9y, !tbaa !4
  store i64 %lnd9z, i64* %lsaKE
  %lnd9A = load i64*, i64** %Sp_Var
  %lnd9B = getelementptr inbounds i64, i64* %lnd9A, i32 1
  %lnd9C = bitcast i64* %lnd9B to i64*
  %lnd9D = load i64, i64* %lnd9C, !tbaa !2
  store i64 %lnd9D, i64* %R1_Var
  %lnd9F = load i64, i64* %lsaKE
  %lnd9E = load i64*, i64** %Sp_Var
  %lnd9G = getelementptr inbounds i64, i64* %lnd9E, i32 -1
  store i64 %lnd9F, i64* %lnd9G, !tbaa !2
  %lnd9I = load i64, i64* %lsaKA
  %lnd9H = load i64*, i64** %Sp_Var
  %lnd9J = getelementptr inbounds i64, i64* %lnd9H, i32 0
  store i64 %lnd9I, i64* %lnd9J, !tbaa !2
  %lnd9L = load i64, i64* %lsaKy
  %lnd9K = load i64*, i64** %Sp_Var
  %lnd9M = getelementptr inbounds i64, i64* %lnd9K, i32 1
  store i64 %lnd9L, i64* %lnd9M, !tbaa !2
  %lnd9N = load i64*, i64** %Sp_Var
  %lnd9O = getelementptr inbounds i64, i64* %lnd9N, i32 -2
  %lnd9P = ptrtoint i64* %lnd9O to i64
  %lnd9Q = inttoptr i64 %lnd9P to i64*
  store i64* %lnd9Q, i64** %Sp_Var
  %lnd9R = load i64, i64* %R1_Var
  %lnd9S = and i64 %lnd9R, 7
  %lnd9T = icmp ne i64 %lnd9S, 0
  br i1 %lnd9T, label %uctq, label %cctc
cctc:
  %lnd9V = load i64, i64* %R1_Var
  %lnd9W = inttoptr i64 %lnd9V to i64*
  %lnd9X = load i64, i64* %lnd9W, !tbaa !4
  %lnd9Y = inttoptr i64 %lnd9X to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnd9Z = load i64*, i64** %Sp_Var
  %lnda0 = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnd9Y( i64* %Base_Arg, i64* %lnd9Z, i64* %Hp_Arg, i64 %lnda0, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
uctq:
  %lnda1 = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cctb_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnda2 = load i64*, i64** %Sp_Var
  %lnda3 = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnda1( i64* %Base_Arg, i64* %lnda2, i64* %Hp_Arg, i64 %lnda3, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cctb_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cctb_info$def to i8*)
define internal ghccc void @cctb_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 4, i32 30, i32 0}>
{
cctb:
  %lsaKI = alloca i64, i32 1
  %lsaKG = alloca i64, i32 1
  %lsaKH = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnda5 = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cctg_info$def to i64
  %lnda4 = load i64*, i64** %Sp_Var
  %lnda6 = getelementptr inbounds i64, i64* %lnda4, i32 -2
  store i64 %lnda5, i64* %lnda6, !tbaa !2
  %lnda9 = load i64, i64* %R1_Var
  %lndaa = add i64 %lnda9, 7
  %lndab = inttoptr i64 %lndaa to i64*
  %lndac = load i64, i64* %lndab, !tbaa !4
  store i64 %lndac, i64* %lsaKI
  %lndaf = load i64, i64* %R1_Var
  %lndag = add i64 %lndaf, 15
  %lndah = inttoptr i64 %lndag to i64*
  %lndai = load i64, i64* %lndah, !tbaa !4
  store i64 %lndai, i64* %lsaKG
  %lndal = load i64, i64* %R1_Var
  %lndam = add i64 %lndal, 23
  %lndan = inttoptr i64 %lndam to i64*
  %lndao = load i64, i64* %lndan, !tbaa !4
  store i64 %lndao, i64* %lsaKH
  %lndap = load i64*, i64** %Sp_Var
  %lndaq = getelementptr inbounds i64, i64* %lndap, i32 4
  %lndar = bitcast i64* %lndaq to i64*
  %lndas = load i64, i64* %lndar, !tbaa !2
  store i64 %lndas, i64* %R1_Var
  %lndau = load i64, i64* %lsaKI
  %lndat = load i64*, i64** %Sp_Var
  %lndav = getelementptr inbounds i64, i64* %lndat, i32 -1
  store i64 %lndau, i64* %lndav, !tbaa !2
  %lndax = load i64, i64* %lsaKH
  %lndaw = load i64*, i64** %Sp_Var
  %lnday = getelementptr inbounds i64, i64* %lndaw, i32 0
  store i64 %lndax, i64* %lnday, !tbaa !2
  %lndaA = load i64, i64* %lsaKG
  %lndaz = load i64*, i64** %Sp_Var
  %lndaB = getelementptr inbounds i64, i64* %lndaz, i32 4
  store i64 %lndaA, i64* %lndaB, !tbaa !2
  %lndaC = load i64*, i64** %Sp_Var
  %lndaD = getelementptr inbounds i64, i64* %lndaC, i32 -2
  %lndaE = ptrtoint i64* %lndaD to i64
  %lndaF = inttoptr i64 %lndaE to i64*
  store i64* %lndaF, i64** %Sp_Var
  %lndaG = load i64, i64* %R1_Var
  %lndaH = and i64 %lndaG, 7
  %lndaI = icmp ne i64 %lndaH, 0
  br i1 %lndaI, label %ucts, label %cctl
cctl:
  %lndaK = load i64, i64* %R1_Var
  %lndaL = inttoptr i64 %lndaK to i64*
  %lndaM = load i64, i64* %lndaL, !tbaa !4
  %lndaN = inttoptr i64 %lndaM to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndaO = load i64*, i64** %Sp_Var
  %lndaP = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndaN( i64* %Base_Arg, i64* %lndaO, i64* %Hp_Arg, i64 %lndaP, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ucts:
  %lndaQ = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cctg_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndaR = load i64*, i64** %Sp_Var
  %lndaS = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndaQ( i64* %Base_Arg, i64* %lndaR, i64* %Hp_Arg, i64 %lndaS, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cctg_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cctg_info$def to i8*)
define internal ghccc void @cctg_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 2182, i32 30, i32 0}>
{
cctg:
  %R6_Var = alloca i64, i32 1
  store i64 undef, i64* %R6_Var
  %R5_Var = alloca i64, i32 1
  store i64 undef, i64* %R5_Var
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lndaT = load i64*, i64** %Sp_Var
  %lndaU = getelementptr inbounds i64, i64* %lndaT, i32 2
  %lndaV = bitcast i64* %lndaU to i64*
  %lndaW = load i64, i64* %lndaV, !tbaa !2
  store i64 %lndaW, i64* %R6_Var
  %lndaX = load i64*, i64** %Sp_Var
  %lndaY = getelementptr inbounds i64, i64* %lndaX, i32 6
  %lndaZ = bitcast i64* %lndaY to i64*
  %lndb0 = load i64, i64* %lndaZ, !tbaa !2
  store i64 %lndb0, i64* %R5_Var
  %lndb1 = load i64*, i64** %Sp_Var
  %lndb2 = getelementptr inbounds i64, i64* %lndb1, i32 3
  %lndb3 = bitcast i64* %lndb2 to i64*
  %lndb4 = load i64, i64* %lndb3, !tbaa !2
  store i64 %lndb4, i64* %R4_Var
  %lndb5 = load i64*, i64** %Sp_Var
  %lndb6 = getelementptr inbounds i64, i64* %lndb5, i32 4
  %lndb7 = bitcast i64* %lndb6 to i64*
  %lndb8 = load i64, i64* %lndb7, !tbaa !2
  store i64 %lndb8, i64* %R3_Var
  %lndb9 = load i64*, i64** %Sp_Var
  %lndba = getelementptr inbounds i64, i64* %lndb9, i32 5
  %lndbb = bitcast i64* %lndba to i64*
  %lndbc = load i64, i64* %lndbb, !tbaa !2
  store i64 %lndbc, i64* %R2_Var
  %lndbe = load i64*, i64** %Sp_Var
  %lndbf = getelementptr inbounds i64, i64* %lndbe, i32 1
  %lndbg = bitcast i64* %lndbf to i64*
  %lndbh = load i64, i64* %lndbg, !tbaa !2
  %lndbd = load i64*, i64** %Sp_Var
  %lndbi = getelementptr inbounds i64, i64* %lndbd, i32 3
  store i64 %lndbh, i64* %lndbi, !tbaa !2
  %lndbk = add i64 %R1_Arg, 15
  %lndbl = inttoptr i64 %lndbk to i64*
  %lndbm = load i64, i64* %lndbl, !tbaa !4
  %lndbj = load i64*, i64** %Sp_Var
  %lndbn = getelementptr inbounds i64, i64* %lndbj, i32 4
  store i64 %lndbm, i64* %lndbn, !tbaa !2
  %lndbp = add i64 %R1_Arg, 23
  %lndbq = inttoptr i64 %lndbp to i64*
  %lndbr = load i64, i64* %lndbq, !tbaa !4
  %lndbo = load i64*, i64** %Sp_Var
  %lndbs = getelementptr inbounds i64, i64* %lndbo, i32 5
  store i64 %lndbr, i64* %lndbs, !tbaa !2
  %lndbu = add i64 %R1_Arg, 7
  %lndbv = inttoptr i64 %lndbu to i64*
  %lndbw = load i64, i64* %lndbv, !tbaa !4
  %lndbt = load i64*, i64** %Sp_Var
  %lndbx = getelementptr inbounds i64, i64* %lndbt, i32 6
  store i64 %lndbw, i64* %lndbx, !tbaa !2
  %lndby = load i64*, i64** %Sp_Var
  %lndbz = getelementptr inbounds i64, i64* %lndby, i32 3
  %lndbA = ptrtoint i64* %lndbz to i64
  %lndbB = inttoptr i64 %lndbA to i64*
  store i64* %lndbB, i64** %Sp_Var
  %lndbC = bitcast i8* @hblaszm0zi0zi0zi0zminplace_HBLASziLevel1_zdwdot_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndbD = load i64*, i64** %Sp_Var
  %lndbE = load i64, i64* %R2_Var
  %lndbF = load i64, i64* %R3_Var
  %lndbG = load i64, i64* %R4_Var
  %lndbH = load i64, i64* %R5_Var
  %lndbI = load i64, i64* %R6_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndbC( i64* %Base_Arg, i64* %lndbD, i64* %Hp_Arg, i64 %R1_Arg, i64 %lndbE, i64 %lndbF, i64 %lndbG, i64 %lndbH, i64 %lndbI, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saL4_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saL4_info$def to i8*)
define internal ghccc void @saL4_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 3, i32 15, i32 0}>
{
cctC:
  %lsaJA = alloca i64, i32 1
  %lsaJE = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lndbJ = load i64*, i64** %Sp_Var
  %lndbK = getelementptr inbounds i64, i64* %lndbJ, i32 -9
  %lndbL = ptrtoint i64* %lndbK to i64
  %lndbM = icmp ult i64 %lndbL, %SpLim_Arg
  %lndbN = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lndbM, i1 0 )
  br i1 %lndbN, label %cctL, label %cctM
cctM:
  %lndbP = ptrtoint i8* @stg_upd_frame_info to i64
  %lndbO = load i64*, i64** %Sp_Var
  %lndbQ = getelementptr inbounds i64, i64* %lndbO, i32 -2
  store i64 %lndbP, i64* %lndbQ, !tbaa !2
  %lndbS = load i64, i64* %R1_Var
  %lndbR = load i64*, i64** %Sp_Var
  %lndbT = getelementptr inbounds i64, i64* %lndbR, i32 -1
  store i64 %lndbS, i64* %lndbT, !tbaa !2
  %lndbV = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cctz_info$def to i64
  %lndbU = load i64*, i64** %Sp_Var
  %lndbW = getelementptr inbounds i64, i64* %lndbU, i32 -5
  store i64 %lndbV, i64* %lndbW, !tbaa !2
  %lndbZ = load i64, i64* %R1_Var
  %lndc0 = add i64 %lndbZ, 24
  %lndc1 = inttoptr i64 %lndc0 to i64*
  %lndc2 = load i64, i64* %lndc1, !tbaa !4
  store i64 %lndc2, i64* %lsaJA
  %lndc5 = load i64, i64* %R1_Var
  %lndc6 = add i64 %lndc5, 32
  %lndc7 = inttoptr i64 %lndc6 to i64*
  %lndc8 = load i64, i64* %lndc7, !tbaa !4
  store i64 %lndc8, i64* %lsaJE
  %lndcb = load i64, i64* %R1_Var
  %lndcc = add i64 %lndcb, 16
  %lndcd = inttoptr i64 %lndcc to i64*
  %lndce = load i64, i64* %lndcd, !tbaa !4
  store i64 %lndce, i64* %R1_Var
  %lndcg = load i64, i64* %lsaJA
  %lndcf = load i64*, i64** %Sp_Var
  %lndch = getelementptr inbounds i64, i64* %lndcf, i32 -4
  store i64 %lndcg, i64* %lndch, !tbaa !2
  %lndcj = load i64, i64* %lsaJE
  %lndci = load i64*, i64** %Sp_Var
  %lndck = getelementptr inbounds i64, i64* %lndci, i32 -3
  store i64 %lndcj, i64* %lndck, !tbaa !2
  %lndcl = load i64*, i64** %Sp_Var
  %lndcm = getelementptr inbounds i64, i64* %lndcl, i32 -5
  %lndcn = ptrtoint i64* %lndcm to i64
  %lndco = inttoptr i64 %lndcn to i64*
  store i64* %lndco, i64** %Sp_Var
  %lndcp = load i64, i64* %R1_Var
  %lndcq = and i64 %lndcp, 7
  %lndcr = icmp ne i64 %lndcq, 0
  br i1 %lndcr, label %uctV, label %cctA
cctA:
  %lndct = load i64, i64* %R1_Var
  %lndcu = inttoptr i64 %lndct to i64*
  %lndcv = load i64, i64* %lndcu, !tbaa !4
  %lndcw = inttoptr i64 %lndcv to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndcx = load i64*, i64** %Sp_Var
  %lndcy = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndcw( i64* %Base_Arg, i64* %lndcx, i64* %Hp_Arg, i64 %lndcy, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
uctV:
  %lndcz = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cctz_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndcA = load i64*, i64** %Sp_Var
  %lndcB = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndcz( i64* %Base_Arg, i64* %lndcA, i64* %Hp_Arg, i64 %lndcB, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cctL:
  %lndcC = load i64, i64* %R1_Var
  store i64 %lndcC, i64* %R1_Var
  %lndcD = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lndcE = bitcast i64* %lndcD to i64*
  %lndcF = load i64, i64* %lndcE, !tbaa !5
  %lndcG = inttoptr i64 %lndcF to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndcH = load i64*, i64** %Sp_Var
  %lndcI = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndcG( i64* %Base_Arg, i64* %lndcH, i64* %Hp_Arg, i64 %lndcI, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cctz_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cctz_info$def to i8*)
define internal ghccc void @cctz_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 2, i32 30, i32 0}>
{
cctz:
  %lsaKP = alloca i64, i32 1
  %lsaKR = alloca i64, i32 1
  %lsaKV = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lndcK = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cctF_info$def to i64
  %lndcJ = load i64*, i64** %Sp_Var
  %lndcL = getelementptr inbounds i64, i64* %lndcJ, i32 -2
  store i64 %lndcK, i64* %lndcL, !tbaa !2
  %lndcO = load i64, i64* %R1_Var
  %lndcP = add i64 %lndcO, 7
  %lndcQ = inttoptr i64 %lndcP to i64*
  %lndcR = load i64, i64* %lndcQ, !tbaa !4
  store i64 %lndcR, i64* %lsaKP
  %lndcU = load i64, i64* %R1_Var
  %lndcV = add i64 %lndcU, 23
  %lndcW = inttoptr i64 %lndcV to i64*
  %lndcX = load i64, i64* %lndcW, !tbaa !4
  store i64 %lndcX, i64* %lsaKR
  %lndd0 = load i64, i64* %R1_Var
  %lndd1 = add i64 %lndd0, 55
  %lndd2 = inttoptr i64 %lndd1 to i64*
  %lndd3 = load i64, i64* %lndd2, !tbaa !4
  store i64 %lndd3, i64* %lsaKV
  %lndd4 = load i64*, i64** %Sp_Var
  %lndd5 = getelementptr inbounds i64, i64* %lndd4, i32 1
  %lndd6 = bitcast i64* %lndd5 to i64*
  %lndd7 = load i64, i64* %lndd6, !tbaa !2
  store i64 %lndd7, i64* %R1_Var
  %lndd9 = load i64, i64* %lsaKV
  %lndd8 = load i64*, i64** %Sp_Var
  %lndda = getelementptr inbounds i64, i64* %lndd8, i32 -1
  store i64 %lndd9, i64* %lndda, !tbaa !2
  %lnddc = load i64, i64* %lsaKR
  %lnddb = load i64*, i64** %Sp_Var
  %lnddd = getelementptr inbounds i64, i64* %lnddb, i32 0
  store i64 %lnddc, i64* %lnddd, !tbaa !2
  %lnddf = load i64, i64* %lsaKP
  %lndde = load i64*, i64** %Sp_Var
  %lnddg = getelementptr inbounds i64, i64* %lndde, i32 1
  store i64 %lnddf, i64* %lnddg, !tbaa !2
  %lnddh = load i64*, i64** %Sp_Var
  %lnddi = getelementptr inbounds i64, i64* %lnddh, i32 -2
  %lnddj = ptrtoint i64* %lnddi to i64
  %lnddk = inttoptr i64 %lnddj to i64*
  store i64* %lnddk, i64** %Sp_Var
  %lnddl = load i64, i64* %R1_Var
  %lnddm = and i64 %lnddl, 7
  %lnddn = icmp ne i64 %lnddm, 0
  br i1 %lnddn, label %uctU, label %cctG
cctG:
  %lnddp = load i64, i64* %R1_Var
  %lnddq = inttoptr i64 %lnddp to i64*
  %lnddr = load i64, i64* %lnddq, !tbaa !4
  %lndds = inttoptr i64 %lnddr to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnddt = load i64*, i64** %Sp_Var
  %lnddu = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndds( i64* %Base_Arg, i64* %lnddt, i64* %Hp_Arg, i64 %lnddu, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
uctU:
  %lnddv = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cctF_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnddw = load i64*, i64** %Sp_Var
  %lnddx = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnddv( i64* %Base_Arg, i64* %lnddw, i64* %Hp_Arg, i64 %lnddx, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cctF_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cctF_info$def to i8*)
define internal ghccc void @cctF_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 4, i32 30, i32 0}>
{
cctF:
  %lsaKZ = alloca i64, i32 1
  %lsaKX = alloca i64, i32 1
  %lsaKY = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnddz = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cctK_info$def to i64
  %lnddy = load i64*, i64** %Sp_Var
  %lnddA = getelementptr inbounds i64, i64* %lnddy, i32 -2
  store i64 %lnddz, i64* %lnddA, !tbaa !2
  %lnddD = load i64, i64* %R1_Var
  %lnddE = add i64 %lnddD, 7
  %lnddF = inttoptr i64 %lnddE to i64*
  %lnddG = load i64, i64* %lnddF, !tbaa !4
  store i64 %lnddG, i64* %lsaKZ
  %lnddJ = load i64, i64* %R1_Var
  %lnddK = add i64 %lnddJ, 15
  %lnddL = inttoptr i64 %lnddK to i64*
  %lnddM = load i64, i64* %lnddL, !tbaa !4
  store i64 %lnddM, i64* %lsaKX
  %lnddP = load i64, i64* %R1_Var
  %lnddQ = add i64 %lnddP, 23
  %lnddR = inttoptr i64 %lnddQ to i64*
  %lnddS = load i64, i64* %lnddR, !tbaa !4
  store i64 %lnddS, i64* %lsaKY
  %lnddT = load i64*, i64** %Sp_Var
  %lnddU = getelementptr inbounds i64, i64* %lnddT, i32 4
  %lnddV = bitcast i64* %lnddU to i64*
  %lnddW = load i64, i64* %lnddV, !tbaa !2
  store i64 %lnddW, i64* %R1_Var
  %lnddY = load i64, i64* %lsaKZ
  %lnddX = load i64*, i64** %Sp_Var
  %lnddZ = getelementptr inbounds i64, i64* %lnddX, i32 -1
  store i64 %lnddY, i64* %lnddZ, !tbaa !2
  %lnde1 = load i64, i64* %lsaKY
  %lnde0 = load i64*, i64** %Sp_Var
  %lnde2 = getelementptr inbounds i64, i64* %lnde0, i32 0
  store i64 %lnde1, i64* %lnde2, !tbaa !2
  %lnde4 = load i64, i64* %lsaKX
  %lnde3 = load i64*, i64** %Sp_Var
  %lnde5 = getelementptr inbounds i64, i64* %lnde3, i32 4
  store i64 %lnde4, i64* %lnde5, !tbaa !2
  %lnde6 = load i64*, i64** %Sp_Var
  %lnde7 = getelementptr inbounds i64, i64* %lnde6, i32 -2
  %lnde8 = ptrtoint i64* %lnde7 to i64
  %lnde9 = inttoptr i64 %lnde8 to i64*
  store i64* %lnde9, i64** %Sp_Var
  %lndea = load i64, i64* %R1_Var
  %lndeb = and i64 %lndea, 7
  %lndec = icmp ne i64 %lndeb, 0
  br i1 %lndec, label %uctW, label %cctP
cctP:
  %lndee = load i64, i64* %R1_Var
  %lndef = inttoptr i64 %lndee to i64*
  %lndeg = load i64, i64* %lndef, !tbaa !4
  %lndeh = inttoptr i64 %lndeg to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndei = load i64*, i64** %Sp_Var
  %lndej = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndeh( i64* %Base_Arg, i64* %lndei, i64* %Hp_Arg, i64 %lndej, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
uctW:
  %lndek = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cctK_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndel = load i64*, i64** %Sp_Var
  %lndem = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndek( i64* %Base_Arg, i64* %lndel, i64* %Hp_Arg, i64 %lndem, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cctK_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cctK_info$def to i8*)
define internal ghccc void @cctK_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 2182, i32 30, i32 0}>
{
cctK:
  %R6_Var = alloca i64, i32 1
  store i64 undef, i64* %R6_Var
  %R5_Var = alloca i64, i32 1
  store i64 undef, i64* %R5_Var
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lnden = load i64*, i64** %Sp_Var
  %lndeo = getelementptr inbounds i64, i64* %lnden, i32 2
  %lndep = bitcast i64* %lndeo to i64*
  %lndeq = load i64, i64* %lndep, !tbaa !2
  store i64 %lndeq, i64* %R6_Var
  %lnder = load i64*, i64** %Sp_Var
  %lndes = getelementptr inbounds i64, i64* %lnder, i32 6
  %lndet = bitcast i64* %lndes to i64*
  %lndeu = load i64, i64* %lndet, !tbaa !2
  store i64 %lndeu, i64* %R5_Var
  %lndev = load i64*, i64** %Sp_Var
  %lndew = getelementptr inbounds i64, i64* %lndev, i32 3
  %lndex = bitcast i64* %lndew to i64*
  %lndey = load i64, i64* %lndex, !tbaa !2
  store i64 %lndey, i64* %R4_Var
  %lndez = load i64*, i64** %Sp_Var
  %lndeA = getelementptr inbounds i64, i64* %lndez, i32 4
  %lndeB = bitcast i64* %lndeA to i64*
  %lndeC = load i64, i64* %lndeB, !tbaa !2
  store i64 %lndeC, i64* %R3_Var
  %lndeD = load i64*, i64** %Sp_Var
  %lndeE = getelementptr inbounds i64, i64* %lndeD, i32 5
  %lndeF = bitcast i64* %lndeE to i64*
  %lndeG = load i64, i64* %lndeF, !tbaa !2
  store i64 %lndeG, i64* %R2_Var
  %lndeI = load i64*, i64** %Sp_Var
  %lndeJ = getelementptr inbounds i64, i64* %lndeI, i32 1
  %lndeK = bitcast i64* %lndeJ to i64*
  %lndeL = load i64, i64* %lndeK, !tbaa !2
  %lndeH = load i64*, i64** %Sp_Var
  %lndeM = getelementptr inbounds i64, i64* %lndeH, i32 3
  store i64 %lndeL, i64* %lndeM, !tbaa !2
  %lndeO = add i64 %R1_Arg, 15
  %lndeP = inttoptr i64 %lndeO to i64*
  %lndeQ = load i64, i64* %lndeP, !tbaa !4
  %lndeN = load i64*, i64** %Sp_Var
  %lndeR = getelementptr inbounds i64, i64* %lndeN, i32 4
  store i64 %lndeQ, i64* %lndeR, !tbaa !2
  %lndeT = add i64 %R1_Arg, 23
  %lndeU = inttoptr i64 %lndeT to i64*
  %lndeV = load i64, i64* %lndeU, !tbaa !4
  %lndeS = load i64*, i64** %Sp_Var
  %lndeW = getelementptr inbounds i64, i64* %lndeS, i32 5
  store i64 %lndeV, i64* %lndeW, !tbaa !2
  %lndeY = add i64 %R1_Arg, 7
  %lndeZ = inttoptr i64 %lndeY to i64*
  %lndf0 = load i64, i64* %lndeZ, !tbaa !4
  %lndeX = load i64*, i64** %Sp_Var
  %lndf1 = getelementptr inbounds i64, i64* %lndeX, i32 6
  store i64 %lndf0, i64* %lndf1, !tbaa !2
  %lndf2 = load i64*, i64** %Sp_Var
  %lndf3 = getelementptr inbounds i64, i64* %lndf2, i32 3
  %lndf4 = ptrtoint i64* %lndf3 to i64
  %lndf5 = inttoptr i64 %lndf4 to i64*
  store i64* %lndf5, i64** %Sp_Var
  %lndf6 = bitcast i8* @hblaszm0zi0zi0zi0zminplace_HBLASziLevel1_zdwdot_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndf7 = load i64*, i64** %Sp_Var
  %lndf8 = load i64, i64* %R2_Var
  %lndf9 = load i64, i64* %R3_Var
  %lndfa = load i64, i64* %R4_Var
  %lndfb = load i64, i64* %R5_Var
  %lndfc = load i64, i64* %R6_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndf6( i64* %Base_Arg, i64* %lndf7, i64* %Hp_Arg, i64 %R1_Arg, i64 %lndf8, i64 %lndf9, i64 %lndfa, i64 %lndfb, i64 %lndfc, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saKN_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saKN_info$def to i8*)
define internal ghccc void @saKN_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 5, i32 15, i32 0}>
{
cctX:
  %lsaKN = alloca i64, i32 1
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %lsaI4 = alloca i64, i32 1
  %lsaI7 = alloca i64, i32 1
  %lsaJA = alloca i64, i32 1
  %lsaJE = alloca i64, i32 1
  %lsaKw = alloca i64, i32 1
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lndfd = load i64, i64* %R1_Var
  store i64 %lndfd, i64* %lsaKN
  %lndfe = load i64*, i64** %Sp_Var
  %lndff = getelementptr inbounds i64, i64* %lndfe, i32 -5
  %lndfg = ptrtoint i64* %lndff to i64
  %lndfh = icmp ult i64 %lndfg, %SpLim_Arg
  %lndfi = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lndfh, i1 0 )
  br i1 %lndfi, label %cctY, label %cctZ
cctZ:
  %lndfj = load i64*, i64** %Hp_Var
  %lndfk = getelementptr inbounds i64, i64* %lndfj, i32 5
  %lndfl = ptrtoint i64* %lndfk to i64
  %lndfm = inttoptr i64 %lndfl to i64*
  store i64* %lndfm, i64** %Hp_Var
  %lndfn = load i64*, i64** %Hp_Var
  %lndfo = ptrtoint i64* %lndfn to i64
  %lndfp = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lndfq = bitcast i64* %lndfp to i64*
  %lndfr = load i64, i64* %lndfq, !tbaa !5
  %lndfs = icmp ugt i64 %lndfo, %lndfr
  %lndft = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lndfs, i1 0 )
  br i1 %lndft, label %ccu1, label %ccu0
ccu0:
  %lndfv = ptrtoint i8* @stg_upd_frame_info to i64
  %lndfu = load i64*, i64** %Sp_Var
  %lndfw = getelementptr inbounds i64, i64* %lndfu, i32 -2
  store i64 %lndfv, i64* %lndfw, !tbaa !2
  %lndfy = load i64, i64* %lsaKN
  %lndfx = load i64*, i64** %Sp_Var
  %lndfz = getelementptr inbounds i64, i64* %lndfx, i32 -1
  store i64 %lndfy, i64* %lndfz, !tbaa !2
  %lndfA = load i64, i64* %lsaKN
  %lndfB = add i64 %lndfA, 16
  %lndfC = inttoptr i64 %lndfB to i64*
  %lndfD = load i64, i64* %lndfC, !tbaa !1
  store i64 %lndfD, i64* %lsaI4
  %lndfE = load i64, i64* %lsaKN
  %lndfF = add i64 %lndfE, 24
  %lndfG = inttoptr i64 %lndfF to i64*
  %lndfH = load i64, i64* %lndfG, !tbaa !1
  store i64 %lndfH, i64* %lsaI7
  %lndfI = load i64, i64* %lsaKN
  %lndfJ = add i64 %lndfI, 32
  %lndfK = inttoptr i64 %lndfJ to i64*
  %lndfL = load i64, i64* %lndfK, !tbaa !1
  store i64 %lndfL, i64* %lsaJA
  %lndfM = load i64, i64* %lsaKN
  %lndfN = add i64 %lndfM, 40
  %lndfO = inttoptr i64 %lndfN to i64*
  %lndfP = load i64, i64* %lndfO, !tbaa !1
  store i64 %lndfP, i64* %lsaJE
  %lndfQ = load i64, i64* %lsaKN
  %lndfR = add i64 %lndfQ, 48
  %lndfS = inttoptr i64 %lndfR to i64*
  %lndfT = load i64, i64* %lndfS, !tbaa !1
  store i64 %lndfT, i64* %lsaKw
  %lndfV = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saL4_info$def to i64
  %lndfU = load i64*, i64** %Hp_Var
  %lndfW = getelementptr inbounds i64, i64* %lndfU, i32 -4
  store i64 %lndfV, i64* %lndfW, !tbaa !3
  %lndfY = load i64, i64* %lsaI4
  %lndfX = load i64*, i64** %Hp_Var
  %lndfZ = getelementptr inbounds i64, i64* %lndfX, i32 -2
  store i64 %lndfY, i64* %lndfZ, !tbaa !3
  %lndg1 = load i64, i64* %lsaJA
  %lndg0 = load i64*, i64** %Hp_Var
  %lndg2 = getelementptr inbounds i64, i64* %lndg0, i32 -1
  store i64 %lndg1, i64* %lndg2, !tbaa !3
  %lndg4 = load i64, i64* %lsaJE
  %lndg3 = load i64*, i64** %Hp_Var
  %lndg5 = getelementptr inbounds i64, i64* %lndg3, i32 0
  store i64 %lndg4, i64* %lndg5, !tbaa !3
  %lndg6 = load i64, i64* %lsaI7
  store i64 %lndg6, i64* %R2_Var
  %lndg8 = ptrtoint i8* @stg_ap_pp_info to i64
  %lndg7 = load i64*, i64** %Sp_Var
  %lndg9 = getelementptr inbounds i64, i64* %lndg7, i32 -5
  store i64 %lndg8, i64* %lndg9, !tbaa !2
  %lndgb = load i64*, i64** %Hp_Var
  %lndgc = getelementptr inbounds i64, i64* %lndgb, i32 -4
  %lndgd = ptrtoint i64* %lndgc to i64
  %lndga = load i64*, i64** %Sp_Var
  %lndge = getelementptr inbounds i64, i64* %lndga, i32 -4
  store i64 %lndgd, i64* %lndge, !tbaa !2
  %lndgg = load i64, i64* %lsaKw
  %lndgf = load i64*, i64** %Sp_Var
  %lndgh = getelementptr inbounds i64, i64* %lndgf, i32 -3
  store i64 %lndgg, i64* %lndgh, !tbaa !2
  %lndgi = load i64*, i64** %Sp_Var
  %lndgj = getelementptr inbounds i64, i64* %lndgi, i32 -5
  %lndgk = ptrtoint i64* %lndgj to i64
  %lndgl = inttoptr i64 %lndgk to i64*
  store i64* %lndgl, i64** %Sp_Var
  %lndgm = bitcast i8* @base_GHCziReal_zs_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndgn = load i64*, i64** %Sp_Var
  %lndgo = load i64*, i64** %Hp_Var
  %lndgp = load i64, i64* %R1_Var
  %lndgq = load i64, i64* %R2_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndgm( i64* %Base_Arg, i64* %lndgn, i64* %lndgo, i64 %lndgp, i64 %lndgq, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ccu1:
  %lndgr = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 40, i64* %lndgr, !tbaa !5
  br label %cctY
cctY:
  %lndgs = load i64, i64* %lsaKN
  store i64 %lndgs, i64* %R1_Var
  %lndgt = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lndgu = bitcast i64* %lndgt to i64*
  %lndgv = load i64, i64* %lndgu, !tbaa !5
  %lndgw = inttoptr i64 %lndgv to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndgx = load i64*, i64** %Sp_Var
  %lndgy = load i64*, i64** %Hp_Var
  %lndgz = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndgw( i64* %Base_Arg, i64* %lndgx, i64* %lndgy, i64 %lndgz, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saL6_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saL6_info$def to i8*)
define internal ghccc void @saL6_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 5, i32 15, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%ucuI_srt_struct* @ucuI_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saL6_info$def to i64)) to i32),i32 0)}>
{
ccu5:
  %R6_Var = alloca i64, i32 1
  store i64 undef, i64* %R6_Var
  %R5_Var = alloca i64, i32 1
  store i64 undef, i64* %R5_Var
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %lndgA = add i64 %R1_Arg, 16
  %lndgB = inttoptr i64 %lndgA to i64*
  %lndgC = load i64, i64* %lndgB, !tbaa !4
  store i64 %lndgC, i64* %R6_Var
  %lndgD = add i64 %R1_Arg, 32
  %lndgE = inttoptr i64 %lndgD to i64*
  %lndgF = load i64, i64* %lndgE, !tbaa !4
  store i64 %lndgF, i64* %R5_Var
  %lndgG = add i64 %R1_Arg, 40
  %lndgH = inttoptr i64 %lndgG to i64*
  %lndgI = load i64, i64* %lndgH, !tbaa !4
  store i64 %lndgI, i64* %R4_Var
  %lndgJ = add i64 %R1_Arg, 48
  %lndgK = inttoptr i64 %lndgJ to i64*
  %lndgL = load i64, i64* %lndgK, !tbaa !4
  store i64 %lndgL, i64* %R3_Var
  %lndgM = add i64 %R1_Arg, 24
  %lndgN = inttoptr i64 %lndgM to i64*
  %lndgO = load i64, i64* %lndgN, !tbaa !4
  store i64 %lndgO, i64* %R2_Var
  %lndgP = bitcast i8* @hblaszm0zi0zi0zi0zminplace_HBLASziLevel1_axpyzq_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndgQ = load i64, i64* %R2_Var
  %lndgR = load i64, i64* %R3_Var
  %lndgS = load i64, i64* %R4_Var
  %lndgT = load i64, i64* %R5_Var
  %lndgU = load i64, i64* %R6_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndgP( i64* %Base_Arg, i64* %Sp_Arg, i64* %Hp_Arg, i64 %R1_Arg, i64 %lndgQ, i64 %lndgR, i64 %lndgS, i64 %lndgT, i64 %lndgU, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@Main_zdwconjugateGradient_info = alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_zdwconjugateGradient_info$def to i8*)
define ghccc void @Main_zdwconjugateGradient_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i64, i64, i64, i32, i32}><{i64 add (i64 sub (i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_zdwconjugateGradient_slow$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_zdwconjugateGradient_info$def to i64)),i64 0), i64 3080, i64 34359738368, i64 3, i32 14, i32 0}>
{
ccu8:
  %lsaHZ = alloca i64, i32 1
  %lsaHY = alloca i64, i32 1
  %lsaHX = alloca i64, i32 1
  %lsaHW = alloca i64, i32 1
  %lsaHV = alloca i64, i32 1
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %lsaI0 = alloca i64, i32 1
  %lccmX = alloca i64, i32 1
  %lccn1 = alloca i64, i32 1
  %lsaI2 = alloca i64, i32 1
  %lccmW = alloca i64, i32 1
  %lccmZ = alloca i64, i32 1
  %lccn7 = alloca i64, i32 1
  %lccn9 = alloca i64, i32 1
  %lccnb = alloca i64, i32 1
  %lccnd = alloca i64, i32 1
  %lccnf = alloca i64, i32 1
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  store i64 %R6_Arg, i64* %lsaHZ
  store i64 %R5_Arg, i64* %lsaHY
  store i64 %R4_Arg, i64* %lsaHX
  store i64 %R3_Arg, i64* %lsaHW
  store i64 %R2_Arg, i64* %lsaHV
  %lndgV = load i64*, i64** %Sp_Var
  %lndgW = getelementptr inbounds i64, i64* %lndgV, i32 -17
  %lndgX = ptrtoint i64* %lndgW to i64
  %lndgY = icmp ult i64 %lndgX, %SpLim_Arg
  %lndgZ = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lndgY, i1 0 )
  br i1 %lndgZ, label %ccu9, label %ccua
ccua:
  %lndh0 = load i64*, i64** %Hp_Var
  %lndh1 = getelementptr inbounds i64, i64* %lndh0, i32 55
  %lndh2 = ptrtoint i64* %lndh1 to i64
  %lndh3 = inttoptr i64 %lndh2 to i64*
  store i64* %lndh3, i64** %Hp_Var
  %lndh4 = load i64*, i64** %Hp_Var
  %lndh5 = ptrtoint i64* %lndh4 to i64
  %lndh6 = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lndh7 = bitcast i64* %lndh6 to i64*
  %lndh8 = load i64, i64* %lndh7, !tbaa !5
  %lndh9 = icmp ugt i64 %lndh5, %lndh8
  %lndha = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lndh9, i1 0 )
  br i1 %lndha, label %ccuc, label %ccub
ccub:
  %lndhc = ptrtoint i8* @vctrzm0zi12zi0zi2zm9a8f7398_DataziVector_Vector_con_info to i64
  %lndhb = load i64*, i64** %Hp_Var
  %lndhd = getelementptr inbounds i64, i64* %lndhb, i32 -54
  store i64 %lndhc, i64* %lndhd, !tbaa !3
  %lndhf = load i64*, i64** %Sp_Var
  %lndhg = getelementptr inbounds i64, i64* %lndhf, i32 1
  %lndhh = bitcast i64* %lndhg to i64*
  %lndhi = load i64, i64* %lndhh, !tbaa !2
  %lndhe = load i64*, i64** %Hp_Var
  %lndhj = getelementptr inbounds i64, i64* %lndhe, i32 -53
  store i64 %lndhi, i64* %lndhj, !tbaa !3
  %lndhl = load i64, i64* %lsaHZ
  %lndhk = load i64*, i64** %Hp_Var
  %lndhm = getelementptr inbounds i64, i64* %lndhk, i32 -52
  store i64 %lndhl, i64* %lndhm, !tbaa !3
  %lndhn = load i64*, i64** %Sp_Var
  %lndho = getelementptr inbounds i64, i64* %lndhn, i32 0
  %lndhp = bitcast i64* %lndho to i64*
  %lndhq = load i64, i64* %lndhp, !tbaa !2
  store i64 %lndhq, i64* %lsaI0
  %lndhs = load i64, i64* %lsaI0
  %lndhr = load i64*, i64** %Hp_Var
  %lndht = getelementptr inbounds i64, i64* %lndhr, i32 -51
  store i64 %lndhs, i64* %lndht, !tbaa !3
  %lndhv = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saI4_info$def to i64
  %lndhu = load i64*, i64** %Hp_Var
  %lndhw = getelementptr inbounds i64, i64* %lndhu, i32 -50
  store i64 %lndhv, i64* %lndhw, !tbaa !3
  %lndhy = load i64, i64* %lsaHV
  %lndhx = load i64*, i64** %Hp_Var
  %lndhz = getelementptr inbounds i64, i64* %lndhx, i32 -48
  store i64 %lndhy, i64* %lndhz, !tbaa !3
  %lndhB = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saI5_info$def to i64
  %lndhA = load i64*, i64** %Hp_Var
  %lndhC = getelementptr inbounds i64, i64* %lndhA, i32 -47
  store i64 %lndhB, i64* %lndhC, !tbaa !3
  %lndhD = load i64*, i64** %Hp_Var
  %lndhE = getelementptr inbounds i64, i64* %lndhD, i32 -50
  %lndhF = ptrtoint i64* %lndhE to i64
  store i64 %lndhF, i64* %lccmX
  %lndhH = load i64, i64* %lccmX
  %lndhG = load i64*, i64** %Hp_Var
  %lndhI = getelementptr inbounds i64, i64* %lndhG, i32 -45
  store i64 %lndhH, i64* %lndhI, !tbaa !3
  %lndhK = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saI7_info$def to i64
  %lndhJ = load i64*, i64** %Hp_Var
  %lndhL = getelementptr inbounds i64, i64* %lndhJ, i32 -44
  store i64 %lndhK, i64* %lndhL, !tbaa !3
  %lndhN = load i64, i64* %lsaHX
  %lndhM = load i64*, i64** %Hp_Var
  %lndhO = getelementptr inbounds i64, i64* %lndhM, i32 -42
  store i64 %lndhN, i64* %lndhO, !tbaa !3
  %lndhQ = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saI8_info$def to i64
  %lndhP = load i64*, i64** %Hp_Var
  %lndhR = getelementptr inbounds i64, i64* %lndhP, i32 -41
  store i64 %lndhQ, i64* %lndhR, !tbaa !3
  %lndhS = load i64*, i64** %Hp_Var
  %lndhT = getelementptr inbounds i64, i64* %lndhS, i32 -44
  %lndhU = ptrtoint i64* %lndhT to i64
  store i64 %lndhU, i64* %lccn1
  %lndhW = load i64, i64* %lccn1
  %lndhV = load i64*, i64** %Hp_Var
  %lndhX = getelementptr inbounds i64, i64* %lndhV, i32 -39
  store i64 %lndhW, i64* %lndhX, !tbaa !3
  %lndhZ = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saI9_info$def to i64
  %lndhY = load i64*, i64** %Hp_Var
  %lndi0 = getelementptr inbounds i64, i64* %lndhY, i32 -38
  store i64 %lndhZ, i64* %lndi0, !tbaa !3
  %lndi2 = load i64, i64* %lsaHX
  %lndi1 = load i64*, i64** %Hp_Var
  %lndi3 = getelementptr inbounds i64, i64* %lndi1, i32 -36
  store i64 %lndi2, i64* %lndi3, !tbaa !3
  %lndi5 = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saIa_info$def to i64
  %lndi4 = load i64*, i64** %Hp_Var
  %lndi6 = getelementptr inbounds i64, i64* %lndi4, i32 -35
  store i64 %lndi5, i64* %lndi6, !tbaa !3
  %lndi8 = load i64, i64* %lsaHY
  %lndi7 = load i64*, i64** %Hp_Var
  %lndi9 = getelementptr inbounds i64, i64* %lndi7, i32 -33
  store i64 %lndi8, i64* %lndi9, !tbaa !3
  %lndia = load i64*, i64** %Sp_Var
  %lndib = getelementptr inbounds i64, i64* %lndia, i32 2
  %lndic = bitcast i64* %lndib to i64*
  %lndid = load i64, i64* %lndic, !tbaa !2
  store i64 %lndid, i64* %lsaI2
  %lndif = load i64, i64* %lsaI2
  %lndie = load i64*, i64** %Hp_Var
  %lndig = getelementptr inbounds i64, i64* %lndie, i32 -32
  store i64 %lndif, i64* %lndig, !tbaa !3
  %lndii = load i64*, i64** %Hp_Var
  %lndij = ptrtoint i64* %lndii to i64
  %lndik = add i64 %lndij, -431
  store i64 %lndik, i64* %lccmW
  %lndim = load i64, i64* %lccmW
  %lndil = load i64*, i64** %Hp_Var
  %lndin = getelementptr inbounds i64, i64* %lndil, i32 -31
  store i64 %lndim, i64* %lndin, !tbaa !3
  %lndip = load i64, i64* %lccmX
  %lndio = load i64*, i64** %Hp_Var
  %lndiq = getelementptr inbounds i64, i64* %lndio, i32 -30
  store i64 %lndip, i64* %lndiq, !tbaa !3
  %lndir = load i64*, i64** %Hp_Var
  %lndis = getelementptr inbounds i64, i64* %lndir, i32 -47
  %lndit = ptrtoint i64* %lndis to i64
  store i64 %lndit, i64* %lccmZ
  %lndiv = load i64, i64* %lccmZ
  %lndiu = load i64*, i64** %Hp_Var
  %lndiw = getelementptr inbounds i64, i64* %lndiu, i32 -29
  store i64 %lndiv, i64* %lndiw, !tbaa !3
  %lndiy = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saIg_info$def to i64
  %lndix = load i64*, i64** %Hp_Var
  %lndiz = getelementptr inbounds i64, i64* %lndix, i32 -28
  store i64 %lndiy, i64* %lndiz, !tbaa !3
  %lndiB = load i64, i64* %lccmX
  %lndiA = load i64*, i64** %Hp_Var
  %lndiC = getelementptr inbounds i64, i64* %lndiA, i32 -26
  store i64 %lndiB, i64* %lndiC, !tbaa !3
  %lndiE = load i64, i64* %lccmZ
  %lndiD = load i64*, i64** %Hp_Var
  %lndiF = getelementptr inbounds i64, i64* %lndiD, i32 -25
  store i64 %lndiE, i64* %lndiF, !tbaa !3
  %lndiG = load i64*, i64** %Hp_Var
  %lndiH = getelementptr inbounds i64, i64* %lndiG, i32 -35
  %lndiI = ptrtoint i64* %lndiH to i64
  store i64 %lndiI, i64* %lccn7
  %lndiK = load i64, i64* %lccn7
  %lndiJ = load i64*, i64** %Hp_Var
  %lndiL = getelementptr inbounds i64, i64* %lndiJ, i32 -24
  store i64 %lndiK, i64* %lndiL, !tbaa !3
  %lndiN = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saIL_info$def to i64
  %lndiM = load i64*, i64** %Hp_Var
  %lndiO = getelementptr inbounds i64, i64* %lndiM, i32 -23
  store i64 %lndiN, i64* %lndiO, !tbaa !3
  %lndiQ = load i64, i64* %lsaHY
  %lndiP = load i64*, i64** %Hp_Var
  %lndiR = getelementptr inbounds i64, i64* %lndiP, i32 -21
  store i64 %lndiQ, i64* %lndiR, !tbaa !3
  %lndiT = load i64, i64* %lccmX
  %lndiS = load i64*, i64** %Hp_Var
  %lndiU = getelementptr inbounds i64, i64* %lndiS, i32 -20
  store i64 %lndiT, i64* %lndiU, !tbaa !3
  %lndiV = load i64*, i64** %Hp_Var
  %lndiW = getelementptr inbounds i64, i64* %lndiV, i32 -28
  %lndiX = ptrtoint i64* %lndiW to i64
  store i64 %lndiX, i64* %lccn9
  %lndiZ = load i64, i64* %lccn9
  %lndiY = load i64*, i64** %Hp_Var
  %lndj0 = getelementptr inbounds i64, i64* %lndiY, i32 -19
  store i64 %lndiZ, i64* %lndj0, !tbaa !3
  %lndj2 = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saIQ_info$def to i64
  %lndj1 = load i64*, i64** %Hp_Var
  %lndj3 = getelementptr inbounds i64, i64* %lndj1, i32 -18
  store i64 %lndj2, i64* %lndj3, !tbaa !3
  %lndj5 = load i64, i64* %lccmX
  %lndj4 = load i64*, i64** %Hp_Var
  %lndj6 = getelementptr inbounds i64, i64* %lndj4, i32 -16
  store i64 %lndj5, i64* %lndj6, !tbaa !3
  %lndj8 = load i64, i64* %lccn9
  %lndj7 = load i64*, i64** %Hp_Var
  %lndj9 = getelementptr inbounds i64, i64* %lndj7, i32 -15
  store i64 %lndj8, i64* %lndj9, !tbaa !3
  %lndja = load i64*, i64** %Hp_Var
  %lndjb = getelementptr inbounds i64, i64* %lndja, i32 -23
  %lndjc = ptrtoint i64* %lndjb to i64
  store i64 %lndjc, i64* %lccnb
  %lndje = load i64, i64* %lccnb
  %lndjd = load i64*, i64** %Hp_Var
  %lndjf = getelementptr inbounds i64, i64* %lndjd, i32 -14
  store i64 %lndje, i64* %lndjf, !tbaa !3
  %lndjh = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saJ7_info$def to i64
  %lndjg = load i64*, i64** %Hp_Var
  %lndji = getelementptr inbounds i64, i64* %lndjg, i32 -13
  store i64 %lndjh, i64* %lndji, !tbaa !3
  %lndjk = load i64, i64* %lccmX
  %lndjj = load i64*, i64** %Hp_Var
  %lndjl = getelementptr inbounds i64, i64* %lndjj, i32 -11
  store i64 %lndjk, i64* %lndjl, !tbaa !3
  %lndjn = load i64, i64* %lccn1
  %lndjm = load i64*, i64** %Hp_Var
  %lndjo = getelementptr inbounds i64, i64* %lndjm, i32 -10
  store i64 %lndjn, i64* %lndjo, !tbaa !3
  %lndjq = load i64, i64* %lccn7
  %lndjp = load i64*, i64** %Hp_Var
  %lndjr = getelementptr inbounds i64, i64* %lndjp, i32 -9
  store i64 %lndjq, i64* %lndjr, !tbaa !3
  %lndjt = load i64, i64* %lccn9
  %lndjs = load i64*, i64** %Hp_Var
  %lndju = getelementptr inbounds i64, i64* %lndjs, i32 -8
  store i64 %lndjt, i64* %lndju, !tbaa !3
  %lndjv = load i64*, i64** %Hp_Var
  %lndjw = getelementptr inbounds i64, i64* %lndjv, i32 -18
  %lndjx = ptrtoint i64* %lndjw to i64
  store i64 %lndjx, i64* %lccnd
  %lndjz = load i64, i64* %lccnd
  %lndjy = load i64*, i64** %Hp_Var
  %lndjA = getelementptr inbounds i64, i64* %lndjy, i32 -7
  store i64 %lndjz, i64* %lndjA, !tbaa !3
  %lndjC = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saL7_info$def to i64
  %lndjB = load i64*, i64** %Hp_Var
  %lndjD = getelementptr inbounds i64, i64* %lndjB, i32 -6
  store i64 %lndjC, i64* %lndjD, !tbaa !3
  %lndjF = load i64, i64* %lsaI2
  %lndjE = load i64*, i64** %Hp_Var
  %lndjG = getelementptr inbounds i64, i64* %lndjE, i32 -4
  store i64 %lndjF, i64* %lndjG, !tbaa !3
  %lndjI = load i64, i64* %lccmW
  %lndjH = load i64*, i64** %Hp_Var
  %lndjJ = getelementptr inbounds i64, i64* %lndjH, i32 -3
  store i64 %lndjI, i64* %lndjJ, !tbaa !3
  %lndjL = load i64, i64* %lccmX
  %lndjK = load i64*, i64** %Hp_Var
  %lndjM = getelementptr inbounds i64, i64* %lndjK, i32 -2
  store i64 %lndjL, i64* %lndjM, !tbaa !3
  %lndjO = load i64, i64* %lccn9
  %lndjN = load i64*, i64** %Hp_Var
  %lndjP = getelementptr inbounds i64, i64* %lndjN, i32 -1
  store i64 %lndjO, i64* %lndjP, !tbaa !3
  %lndjQ = load i64*, i64** %Hp_Var
  %lndjR = getelementptr inbounds i64, i64* %lndjQ, i32 -13
  %lndjS = ptrtoint i64* %lndjR to i64
  store i64 %lndjS, i64* %lccnf
  %lndjU = load i64, i64* %lccnf
  %lndjT = load i64*, i64** %Hp_Var
  %lndjV = getelementptr inbounds i64, i64* %lndjT, i32 0
  store i64 %lndjU, i64* %lndjV, !tbaa !3
  %lndjX = load i64, i64* %lccmZ
  %lndjW = load i64*, i64** %Sp_Var
  %lndjY = getelementptr inbounds i64, i64* %lndjW, i32 -13
  store i64 %lndjX, i64* %lndjY, !tbaa !2
  %lndk0 = load i64, i64* %lccn1
  %lndjZ = load i64*, i64** %Sp_Var
  %lndk1 = getelementptr inbounds i64, i64* %lndjZ, i32 -12
  store i64 %lndk0, i64* %lndk1, !tbaa !2
  %lndk3 = load i64*, i64** %Hp_Var
  %lndk4 = getelementptr inbounds i64, i64* %lndk3, i32 -41
  %lndk5 = ptrtoint i64* %lndk4 to i64
  %lndk2 = load i64*, i64** %Sp_Var
  %lndk6 = getelementptr inbounds i64, i64* %lndk2, i32 -11
  store i64 %lndk5, i64* %lndk6, !tbaa !2
  %lndk8 = load i64*, i64** %Hp_Var
  %lndk9 = getelementptr inbounds i64, i64* %lndk8, i32 -38
  %lndka = ptrtoint i64* %lndk9 to i64
  %lndk7 = load i64*, i64** %Sp_Var
  %lndkb = getelementptr inbounds i64, i64* %lndk7, i32 -10
  store i64 %lndka, i64* %lndkb, !tbaa !2
  %lndkd = load i64, i64* %lsaHW
  %lndkc = load i64*, i64** %Sp_Var
  %lndke = getelementptr inbounds i64, i64* %lndkc, i32 -9
  store i64 %lndkd, i64* %lndke, !tbaa !2
  %lndkg = load i64, i64* %lsaHY
  %lndkf = load i64*, i64** %Sp_Var
  %lndkh = getelementptr inbounds i64, i64* %lndkf, i32 -8
  store i64 %lndkg, i64* %lndkh, !tbaa !2
  %lndkj = load i64, i64* %lsaI0
  %lndki = load i64*, i64** %Sp_Var
  %lndkk = getelementptr inbounds i64, i64* %lndki, i32 -7
  store i64 %lndkj, i64* %lndkk, !tbaa !2
  %lndkm = load i64, i64* %lccn7
  %lndkl = load i64*, i64** %Sp_Var
  %lndkn = getelementptr inbounds i64, i64* %lndkl, i32 -6
  store i64 %lndkm, i64* %lndkn, !tbaa !2
  %lndkp = load i64, i64* %lccn9
  %lndko = load i64*, i64** %Sp_Var
  %lndkq = getelementptr inbounds i64, i64* %lndko, i32 -5
  store i64 %lndkp, i64* %lndkq, !tbaa !2
  %lndks = load i64, i64* %lccnb
  %lndkr = load i64*, i64** %Sp_Var
  %lndkt = getelementptr inbounds i64, i64* %lndkr, i32 -4
  store i64 %lndks, i64* %lndkt, !tbaa !2
  %lndkv = load i64, i64* %lccnd
  %lndku = load i64*, i64** %Sp_Var
  %lndkw = getelementptr inbounds i64, i64* %lndku, i32 -3
  store i64 %lndkv, i64* %lndkw, !tbaa !2
  %lndky = load i64, i64* %lccnf
  %lndkx = load i64*, i64** %Sp_Var
  %lndkz = getelementptr inbounds i64, i64* %lndkx, i32 -2
  store i64 %lndky, i64* %lndkz, !tbaa !2
  %lndkB = load i64*, i64** %Hp_Var
  %lndkC = getelementptr inbounds i64, i64* %lndkB, i32 -6
  %lndkD = ptrtoint i64* %lndkC to i64
  %lndkA = load i64*, i64** %Sp_Var
  %lndkE = getelementptr inbounds i64, i64* %lndkA, i32 -1
  store i64 %lndkD, i64* %lndkE, !tbaa !2
  %lndkG = load i64, i64* %lccmX
  %lndkF = load i64*, i64** %Sp_Var
  %lndkH = getelementptr inbounds i64, i64* %lndkF, i32 0
  store i64 %lndkG, i64* %lndkH, !tbaa !2
  %lndkJ = load i64, i64* %lccmW
  %lndkI = load i64*, i64** %Sp_Var
  %lndkK = getelementptr inbounds i64, i64* %lndkI, i32 1
  store i64 %lndkJ, i64* %lndkK, !tbaa !2
  %lndkL = load i64*, i64** %Sp_Var
  %lndkM = getelementptr inbounds i64, i64* %lndkL, i32 -14
  %lndkN = ptrtoint i64* %lndkM to i64
  %lndkO = inttoptr i64 %lndkN to i64*
  store i64* %lndkO, i64** %Sp_Var
  %lndkP = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccnl_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndkQ = load i64*, i64** %Sp_Var
  %lndkR = load i64*, i64** %Hp_Var
  %lndkS = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndkP( i64* %Base_Arg, i64* %lndkQ, i64* %lndkR, i64 %lndkS, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ccuc:
  %lndkT = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 440, i64* %lndkT, !tbaa !5
  br label %ccu9
ccu9:
  %lndkU = ptrtoint %Main_zdwconjugateGradient_closure_struct* @Main_zdwconjugateGradient_closure$def to i64
  store i64 %lndkU, i64* %R1_Var
  %lndkW = load i64, i64* %lsaHV
  %lndkV = load i64*, i64** %Sp_Var
  %lndkX = getelementptr inbounds i64, i64* %lndkV, i32 -5
  store i64 %lndkW, i64* %lndkX, !tbaa !2
  %lndkZ = load i64, i64* %lsaHW
  %lndkY = load i64*, i64** %Sp_Var
  %lndl0 = getelementptr inbounds i64, i64* %lndkY, i32 -4
  store i64 %lndkZ, i64* %lndl0, !tbaa !2
  %lndl2 = load i64, i64* %lsaHX
  %lndl1 = load i64*, i64** %Sp_Var
  %lndl3 = getelementptr inbounds i64, i64* %lndl1, i32 -3
  store i64 %lndl2, i64* %lndl3, !tbaa !2
  %lndl5 = load i64, i64* %lsaHY
  %lndl4 = load i64*, i64** %Sp_Var
  %lndl6 = getelementptr inbounds i64, i64* %lndl4, i32 -2
  store i64 %lndl5, i64* %lndl6, !tbaa !2
  %lndl8 = load i64, i64* %lsaHZ
  %lndl7 = load i64*, i64** %Sp_Var
  %lndl9 = getelementptr inbounds i64, i64* %lndl7, i32 -1
  store i64 %lndl8, i64* %lndl9, !tbaa !2
  %lndla = load i64*, i64** %Sp_Var
  %lndlb = getelementptr inbounds i64, i64* %lndla, i32 -5
  %lndlc = ptrtoint i64* %lndlb to i64
  %lndld = inttoptr i64 %lndlc to i64*
  store i64* %lndld, i64** %Sp_Var
  %lndle = getelementptr inbounds i64, i64* %Base_Arg, i32 -1
  %lndlf = bitcast i64* %lndle to i64*
  %lndlg = load i64, i64* %lndlf, !tbaa !5
  %lndlh = inttoptr i64 %lndlg to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndli = load i64*, i64** %Sp_Var
  %lndlj = load i64*, i64** %Hp_Var
  %lndlk = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndlh( i64* %Base_Arg, i64* %lndli, i64* %lndlj, i64 %lndlk, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@ccnl_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccnl_info$def to i8*)
define internal ghccc void @ccnl_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 4112, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%ucuP_srt_struct* @ucuP_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccnl_info$def to i64)) to i32),i32 0)}>
{
ccnl:
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %lsaJx = alloca i64, i32 1
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lndll = load i64*, i64** %Hp_Var
  %lndlm = getelementptr inbounds i64, i64* %lndll, i32 4
  %lndln = ptrtoint i64* %lndlm to i64
  %lndlo = inttoptr i64 %lndln to i64*
  store i64* %lndlo, i64** %Hp_Var
  %lndlp = load i64*, i64** %Hp_Var
  %lndlq = ptrtoint i64* %lndlp to i64
  %lndlr = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lndls = bitcast i64* %lndlr to i64*
  %lndlt = load i64, i64* %lndls, !tbaa !5
  %lndlu = icmp ugt i64 %lndlq, %lndlt
  %lndlv = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lndlu, i1 0 )
  br i1 %lndlv, label %ccuf, label %ccue
ccue:
  %lndlw = load i64*, i64** %Sp_Var
  %lndlx = getelementptr inbounds i64, i64* %lndlw, i32 7
  %lndly = bitcast i64* %lndlx to i64*
  %lndlz = load i64, i64* %lndly, !tbaa !2
  store i64 %lndlz, i64* %lsaJx
  %lndlA = load i64, i64* %lsaJx
  switch i64 %lndlA, label %ccuh [i64 0, label %ccuA]
ccuh:
  %lndlC = ptrtoint i8* @stg_ap_2_upd_info to i64
  %lndlB = load i64*, i64** %Hp_Var
  %lndlD = getelementptr inbounds i64, i64* %lndlB, i32 -3
  store i64 %lndlC, i64* %lndlD, !tbaa !3
  %lndlF = load i64*, i64** %Sp_Var
  %lndlG = getelementptr inbounds i64, i64* %lndlF, i32 4
  %lndlH = bitcast i64* %lndlG to i64*
  %lndlI = load i64, i64* %lndlH, !tbaa !2
  %lndlE = load i64*, i64** %Hp_Var
  %lndlJ = getelementptr inbounds i64, i64* %lndlE, i32 -1
  store i64 %lndlI, i64* %lndlJ, !tbaa !3
  %lndlL = load i64*, i64** %Sp_Var
  %lndlM = getelementptr inbounds i64, i64* %lndlL, i32 8
  %lndlN = bitcast i64* %lndlM to i64*
  %lndlO = load i64, i64* %lndlN, !tbaa !2
  %lndlK = load i64*, i64** %Hp_Var
  %lndlP = getelementptr inbounds i64, i64* %lndlK, i32 0
  store i64 %lndlO, i64* %lndlP, !tbaa !3
  %lndlR = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccnr_info$def to i64
  %lndlQ = load i64*, i64** %Sp_Var
  %lndlS = getelementptr inbounds i64, i64* %lndlQ, i32 0
  store i64 %lndlR, i64* %lndlS, !tbaa !2
  %lndlT = load i64*, i64** %Sp_Var
  %lndlU = getelementptr inbounds i64, i64* %lndlT, i32 5
  %lndlV = bitcast i64* %lndlU to i64*
  %lndlW = load i64, i64* %lndlV, !tbaa !2
  store i64 %lndlW, i64* %R2_Var
  %lndlY = ptrtoint i8* @stg_ap_pp_info to i64
  %lndlX = load i64*, i64** %Sp_Var
  %lndlZ = getelementptr inbounds i64, i64* %lndlX, i32 -3
  store i64 %lndlY, i64* %lndlZ, !tbaa !2
  %lndm1 = load i64*, i64** %Hp_Var
  %lndm2 = getelementptr inbounds i64, i64* %lndm1, i32 -3
  %lndm3 = ptrtoint i64* %lndm2 to i64
  %lndm0 = load i64*, i64** %Sp_Var
  %lndm4 = getelementptr inbounds i64, i64* %lndm0, i32 -2
  store i64 %lndm3, i64* %lndm4, !tbaa !2
  %lndm6 = load i64*, i64** %Sp_Var
  %lndm7 = getelementptr inbounds i64, i64* %lndm6, i32 3
  %lndm8 = bitcast i64* %lndm7 to i64*
  %lndm9 = load i64, i64* %lndm8, !tbaa !2
  %lndm5 = load i64*, i64** %Sp_Var
  %lndma = getelementptr inbounds i64, i64* %lndm5, i32 -1
  store i64 %lndm9, i64* %lndma, !tbaa !2
  %lndmc = load i64, i64* %lsaJx
  %lndmb = load i64*, i64** %Sp_Var
  %lndmd = getelementptr inbounds i64, i64* %lndmb, i32 7
  store i64 %lndmc, i64* %lndmd, !tbaa !2
  %lndme = load i64*, i64** %Sp_Var
  %lndmf = getelementptr inbounds i64, i64* %lndme, i32 -3
  %lndmg = ptrtoint i64* %lndmf to i64
  %lndmh = inttoptr i64 %lndmg to i64*
  store i64* %lndmh, i64** %Sp_Var
  %lndmi = bitcast i8* @ghczmprim_GHCziClasses_zl_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndmj = load i64*, i64** %Sp_Var
  %lndmk = load i64*, i64** %Hp_Var
  %lndml = load i64, i64* %R1_Var
  %lndmm = load i64, i64* %R2_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndmi( i64* %Base_Arg, i64* %lndmj, i64* %lndmk, i64 %lndml, i64 %lndmm, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ccuA:
  %lndmn = load i64*, i64** %Hp_Var
  %lndmo = getelementptr inbounds i64, i64* %lndmn, i32 -4
  %lndmp = ptrtoint i64* %lndmo to i64
  %lndmq = inttoptr i64 %lndmp to i64*
  store i64* %lndmq, i64** %Hp_Var
  %lndmr = load i64*, i64** %Sp_Var
  %lndms = getelementptr inbounds i64, i64* %lndmr, i32 13
  %lndmt = bitcast i64* %lndms to i64*
  %lndmu = load i64, i64* %lndmt, !tbaa !2
  %lndmv = and i64 %lndmu, -8
  store i64 %lndmv, i64* %R1_Var
  %lndmw = load i64*, i64** %Sp_Var
  %lndmx = getelementptr inbounds i64, i64* %lndmw, i32 17
  %lndmy = ptrtoint i64* %lndmx to i64
  %lndmz = inttoptr i64 %lndmy to i64*
  store i64* %lndmz, i64** %Sp_Var
  %lndmB = load i64, i64* %R1_Var
  %lndmC = inttoptr i64 %lndmB to i64*
  %lndmD = load i64, i64* %lndmC, !tbaa !4
  %lndmE = inttoptr i64 %lndmD to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndmF = load i64*, i64** %Sp_Var
  %lndmG = load i64*, i64** %Hp_Var
  %lndmH = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndmE( i64* %Base_Arg, i64* %lndmF, i64* %lndmG, i64 %lndmH, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ccuf:
  %lndmI = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 32, i64* %lndmI, !tbaa !5
  %lndmK = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccnl_info$def to i64
  %lndmJ = load i64*, i64** %Sp_Var
  %lndmL = getelementptr inbounds i64, i64* %lndmJ, i32 0
  store i64 %lndmK, i64* %lndmL, !tbaa !2
  %lndmM = bitcast i8* @stg_gc_noregs to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndmN = load i64*, i64** %Sp_Var
  %lndmO = load i64*, i64** %Hp_Var
  %lndmP = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndmM( i64* %Base_Arg, i64* %lndmN, i64* %lndmO, i64 %lndmP, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@ccnr_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccnr_info$def to i8*)
define internal ghccc void @ccnr_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 4112, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%ucuP_srt_struct* @ucuP_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccnr_info$def to i64)) to i32),i32 0)}>
{
ccnr:
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %lccnv = alloca i64, i32 1
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lndmQ = load i64, i64* %R1_Var
  %lndmR = and i64 %lndmQ, 7
  switch i64 %lndmR, label %ccuj [i64 1, label %ccuj
                                  i64 2, label %ccuz]
ccuj:
  %lndmS = load i64*, i64** %Hp_Var
  %lndmT = getelementptr inbounds i64, i64* %lndmS, i32 12
  %lndmU = ptrtoint i64* %lndmT to i64
  %lndmV = inttoptr i64 %lndmU to i64*
  store i64* %lndmV, i64** %Hp_Var
  %lndmW = load i64*, i64** %Hp_Var
  %lndmX = ptrtoint i64* %lndmW to i64
  %lndmY = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lndmZ = bitcast i64* %lndmY to i64*
  %lndn0 = load i64, i64* %lndmZ, !tbaa !5
  %lndn1 = icmp ugt i64 %lndmX, %lndn0
  %lndn2 = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lndn1, i1 0 )
  br i1 %lndn2, label %ccum, label %ccul
ccul:
  %lndn4 = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saJA_info$def to i64
  %lndn3 = load i64*, i64** %Hp_Var
  %lndn5 = getelementptr inbounds i64, i64* %lndn3, i32 -11
  store i64 %lndn4, i64* %lndn5, !tbaa !3
  %lndn7 = load i64*, i64** %Sp_Var
  %lndn8 = getelementptr inbounds i64, i64* %lndn7, i32 16
  %lndn9 = bitcast i64* %lndn8 to i64*
  %lndna = load i64, i64* %lndn9, !tbaa !2
  %lndn6 = load i64*, i64** %Hp_Var
  %lndnb = getelementptr inbounds i64, i64* %lndn6, i32 -9
  store i64 %lndna, i64* %lndnb, !tbaa !3
  %lndnd = load i64*, i64** %Sp_Var
  %lndne = getelementptr inbounds i64, i64* %lndnd, i32 14
  %lndnf = bitcast i64* %lndne to i64*
  %lndng = load i64, i64* %lndnf, !tbaa !2
  %lndnc = load i64*, i64** %Hp_Var
  %lndnh = getelementptr inbounds i64, i64* %lndnc, i32 -8
  store i64 %lndng, i64* %lndnh, !tbaa !3
  %lndnj = load i64*, i64** %Sp_Var
  %lndnk = getelementptr inbounds i64, i64* %lndnj, i32 1
  %lndnl = bitcast i64* %lndnk to i64*
  %lndnm = load i64, i64* %lndnl, !tbaa !2
  %lndni = load i64*, i64** %Hp_Var
  %lndnn = getelementptr inbounds i64, i64* %lndni, i32 -7
  store i64 %lndnm, i64* %lndnn, !tbaa !3
  %lndnp = load i64*, i64** %Sp_Var
  %lndnq = getelementptr inbounds i64, i64* %lndnp, i32 8
  %lndnr = bitcast i64* %lndnq to i64*
  %lndns = load i64, i64* %lndnr, !tbaa !2
  %lndno = load i64*, i64** %Hp_Var
  %lndnt = getelementptr inbounds i64, i64* %lndno, i32 -6
  store i64 %lndns, i64* %lndnt, !tbaa !3
  %lndnv = load i64*, i64** %Sp_Var
  %lndnw = getelementptr inbounds i64, i64* %lndnv, i32 10
  %lndnx = bitcast i64* %lndnw to i64*
  %lndny = load i64, i64* %lndnx, !tbaa !2
  %lndnu = load i64*, i64** %Hp_Var
  %lndnz = getelementptr inbounds i64, i64* %lndnu, i32 -5
  store i64 %lndny, i64* %lndnz, !tbaa !3
  %lndnB = load i64*, i64** %Sp_Var
  %lndnC = getelementptr inbounds i64, i64* %lndnB, i32 12
  %lndnD = bitcast i64* %lndnC to i64*
  %lndnE = load i64, i64* %lndnD, !tbaa !2
  %lndnA = load i64*, i64** %Hp_Var
  %lndnF = getelementptr inbounds i64, i64* %lndnA, i32 -4
  store i64 %lndnE, i64* %lndnF, !tbaa !3
  %lndnH = ptrtoint i8* @stg_ap_2_upd_info to i64
  %lndnG = load i64*, i64** %Hp_Var
  %lndnI = getelementptr inbounds i64, i64* %lndnG, i32 -3
  store i64 %lndnH, i64* %lndnI, !tbaa !3
  %lndnK = load i64*, i64** %Sp_Var
  %lndnL = getelementptr inbounds i64, i64* %lndnK, i32 4
  %lndnM = bitcast i64* %lndnL to i64*
  %lndnN = load i64, i64* %lndnM, !tbaa !2
  %lndnJ = load i64*, i64** %Hp_Var
  %lndnO = getelementptr inbounds i64, i64* %lndnJ, i32 -1
  store i64 %lndnN, i64* %lndnO, !tbaa !3
  %lndnP = load i64*, i64** %Hp_Var
  %lndnQ = getelementptr inbounds i64, i64* %lndnP, i32 -11
  %lndnR = ptrtoint i64* %lndnQ to i64
  store i64 %lndnR, i64* %lccnv
  %lndnT = load i64, i64* %lccnv
  %lndnS = load i64*, i64** %Hp_Var
  %lndnU = getelementptr inbounds i64, i64* %lndnS, i32 0
  store i64 %lndnT, i64* %lndnU, !tbaa !3
  %lndnW = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccny_info$def to i64
  %lndnV = load i64*, i64** %Sp_Var
  %lndnX = getelementptr inbounds i64, i64* %lndnV, i32 0
  store i64 %lndnW, i64* %lndnX, !tbaa !2
  %lndnY = load i64*, i64** %Sp_Var
  %lndnZ = getelementptr inbounds i64, i64* %lndnY, i32 5
  %lndo0 = bitcast i64* %lndnZ to i64*
  %lndo1 = load i64, i64* %lndo0, !tbaa !2
  store i64 %lndo1, i64* %R2_Var
  %lndo3 = ptrtoint i8* @stg_ap_pp_info to i64
  %lndo2 = load i64*, i64** %Sp_Var
  %lndo4 = getelementptr inbounds i64, i64* %lndo2, i32 -3
  store i64 %lndo3, i64* %lndo4, !tbaa !2
  %lndo6 = load i64*, i64** %Hp_Var
  %lndo7 = getelementptr inbounds i64, i64* %lndo6, i32 -3
  %lndo8 = ptrtoint i64* %lndo7 to i64
  %lndo5 = load i64*, i64** %Sp_Var
  %lndo9 = getelementptr inbounds i64, i64* %lndo5, i32 -2
  store i64 %lndo8, i64* %lndo9, !tbaa !2
  %lndob = load i64*, i64** %Sp_Var
  %lndoc = getelementptr inbounds i64, i64* %lndob, i32 3
  %lndod = bitcast i64* %lndoc to i64*
  %lndoe = load i64, i64* %lndod, !tbaa !2
  %lndoa = load i64*, i64** %Sp_Var
  %lndof = getelementptr inbounds i64, i64* %lndoa, i32 -1
  store i64 %lndoe, i64* %lndof, !tbaa !2
  %lndoh = load i64, i64* %lccnv
  %lndog = load i64*, i64** %Sp_Var
  %lndoi = getelementptr inbounds i64, i64* %lndog, i32 12
  store i64 %lndoh, i64* %lndoi, !tbaa !2
  %lndoj = load i64*, i64** %Sp_Var
  %lndok = getelementptr inbounds i64, i64* %lndoj, i32 -3
  %lndol = ptrtoint i64* %lndok to i64
  %lndom = inttoptr i64 %lndol to i64*
  store i64* %lndom, i64** %Sp_Var
  %lndon = bitcast i8* @ghczmprim_GHCziClasses_zl_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndoo = load i64*, i64** %Sp_Var
  %lndop = load i64*, i64** %Hp_Var
  %lndoq = load i64, i64* %R1_Var
  %lndor = load i64, i64* %R2_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndon( i64* %Base_Arg, i64* %lndoo, i64* %lndop, i64 %lndoq, i64 %lndor, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ccum:
  %lndos = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 96, i64* %lndos, !tbaa !5
  %lndot = load i64, i64* %R1_Var
  store i64 %lndot, i64* %R1_Var
  %lndou = bitcast i8* @stg_gc_unpt_r1 to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndov = load i64*, i64** %Sp_Var
  %lndow = load i64*, i64** %Hp_Var
  %lndox = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndou( i64* %Base_Arg, i64* %lndov, i64* %lndow, i64 %lndox, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ccuz:
  %lndoy = load i64*, i64** %Sp_Var
  %lndoz = getelementptr inbounds i64, i64* %lndoy, i32 15
  %lndoA = bitcast i64* %lndoz to i64*
  %lndoB = load i64, i64* %lndoA, !tbaa !2
  store i64 %lndoB, i64* %R1_Var
  %lndoC = load i64*, i64** %Sp_Var
  %lndoD = getelementptr inbounds i64, i64* %lndoC, i32 17
  %lndoE = ptrtoint i64* %lndoD to i64
  %lndoF = inttoptr i64 %lndoE to i64*
  store i64* %lndoF, i64** %Sp_Var
  %lndoG = load i64*, i64** %Sp_Var
  %lndoH = getelementptr inbounds i64, i64* %lndoG, i32 0
  %lndoI = bitcast i64* %lndoH to i64*
  %lndoJ = load i64, i64* %lndoI, !tbaa !2
  %lndoK = inttoptr i64 %lndoJ to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndoL = load i64*, i64** %Sp_Var
  %lndoM = load i64*, i64** %Hp_Var
  %lndoN = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndoK( i64* %Base_Arg, i64* %lndoL, i64* %lndoM, i64 %lndoN, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@ccny_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccny_info$def to i8*)
define internal ghccc void @ccny_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 12304, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%ucuP_srt_struct* @ucuP_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccny_info$def to i64)) to i32),i32 0)}>
{
ccny:
  %lsaJw = alloca i64, i32 1
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %lsaI2 = alloca i64, i32 1
  %lccmX = alloca i64, i32 1
  %lccn1 = alloca i64, i32 1
  %lccnv = alloca i64, i32 1
  %lccnC = alloca i64, i32 1
  %lccnE = alloca i64, i32 1
  %lccnG = alloca i64, i32 1
  %lccnI = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lndoO = load i64*, i64** %Sp_Var
  %lndoP = getelementptr inbounds i64, i64* %lndoO, i32 13
  %lndoQ = bitcast i64* %lndoP to i64*
  %lndoR = load i64, i64* %lndoQ, !tbaa !2
  store i64 %lndoR, i64* %lsaJw
  %lndoS = load i64, i64* %R1_Var
  %lndoT = and i64 %lndoS, 7
  switch i64 %lndoT, label %ccuo [i64 1, label %ccuo
                                  i64 2, label %ccuv]
ccuo:
  %lndoU = load i64*, i64** %Hp_Var
  %lndoV = getelementptr inbounds i64, i64* %lndoU, i32 34
  %lndoW = ptrtoint i64* %lndoV to i64
  %lndoX = inttoptr i64 %lndoW to i64*
  store i64* %lndoX, i64** %Hp_Var
  %lndoY = load i64*, i64** %Hp_Var
  %lndoZ = ptrtoint i64* %lndoY to i64
  %lndp0 = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lndp1 = bitcast i64* %lndp0 to i64*
  %lndp2 = load i64, i64* %lndp1, !tbaa !5
  %lndp3 = icmp ugt i64 %lndoZ, %lndp2
  %lndp4 = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lndp3, i1 0 )
  br i1 %lndp4, label %ccur, label %ccuq
ccuq:
  %lndp6 = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saJE_info$def to i64
  %lndp5 = load i64*, i64** %Hp_Var
  %lndp7 = getelementptr inbounds i64, i64* %lndp5, i32 -33
  store i64 %lndp6, i64* %lndp7, !tbaa !3
  %lndp8 = load i64*, i64** %Sp_Var
  %lndp9 = getelementptr inbounds i64, i64* %lndp8, i32 16
  %lndpa = bitcast i64* %lndp9 to i64*
  %lndpb = load i64, i64* %lndpa, !tbaa !2
  store i64 %lndpb, i64* %lsaI2
  %lndpd = load i64, i64* %lsaI2
  %lndpc = load i64*, i64** %Hp_Var
  %lndpe = getelementptr inbounds i64, i64* %lndpc, i32 -31
  store i64 %lndpd, i64* %lndpe, !tbaa !3
  %lndpf = load i64*, i64** %Sp_Var
  %lndpg = getelementptr inbounds i64, i64* %lndpf, i32 14
  %lndph = bitcast i64* %lndpg to i64*
  %lndpi = load i64, i64* %lndph, !tbaa !2
  store i64 %lndpi, i64* %lccmX
  %lndpk = load i64, i64* %lccmX
  %lndpj = load i64*, i64** %Hp_Var
  %lndpl = getelementptr inbounds i64, i64* %lndpj, i32 -30
  store i64 %lndpk, i64* %lndpl, !tbaa !3
  %lndpn = load i64*, i64** %Sp_Var
  %lndpo = getelementptr inbounds i64, i64* %lndpn, i32 1
  %lndpp = bitcast i64* %lndpo to i64*
  %lndpq = load i64, i64* %lndpp, !tbaa !2
  %lndpm = load i64*, i64** %Hp_Var
  %lndpr = getelementptr inbounds i64, i64* %lndpm, i32 -29
  store i64 %lndpq, i64* %lndpr, !tbaa !3
  %lndps = load i64*, i64** %Sp_Var
  %lndpt = getelementptr inbounds i64, i64* %lndps, i32 2
  %lndpu = bitcast i64* %lndpt to i64*
  %lndpv = load i64, i64* %lndpu, !tbaa !2
  store i64 %lndpv, i64* %lccn1
  %lndpx = load i64, i64* %lccn1
  %lndpw = load i64*, i64** %Hp_Var
  %lndpy = getelementptr inbounds i64, i64* %lndpw, i32 -28
  store i64 %lndpx, i64* %lndpy, !tbaa !3
  %lndpA = load i64*, i64** %Sp_Var
  %lndpB = getelementptr inbounds i64, i64* %lndpA, i32 9
  %lndpC = bitcast i64* %lndpB to i64*
  %lndpD = load i64, i64* %lndpC, !tbaa !2
  %lndpz = load i64*, i64** %Hp_Var
  %lndpE = getelementptr inbounds i64, i64* %lndpz, i32 -27
  store i64 %lndpD, i64* %lndpE, !tbaa !3
  %lndpG = load i64*, i64** %Sp_Var
  %lndpH = getelementptr inbounds i64, i64* %lndpG, i32 10
  %lndpI = bitcast i64* %lndpH to i64*
  %lndpJ = load i64, i64* %lndpI, !tbaa !2
  %lndpF = load i64*, i64** %Hp_Var
  %lndpK = getelementptr inbounds i64, i64* %lndpF, i32 -26
  store i64 %lndpJ, i64* %lndpK, !tbaa !3
  %lndpM = load i64*, i64** %Sp_Var
  %lndpN = getelementptr inbounds i64, i64* %lndpM, i32 11
  %lndpO = bitcast i64* %lndpN to i64*
  %lndpP = load i64, i64* %lndpO, !tbaa !2
  %lndpL = load i64*, i64** %Hp_Var
  %lndpQ = getelementptr inbounds i64, i64* %lndpL, i32 -25
  store i64 %lndpP, i64* %lndpQ, !tbaa !3
  %lndpR = load i64*, i64** %Sp_Var
  %lndpS = getelementptr inbounds i64, i64* %lndpR, i32 12
  %lndpT = bitcast i64* %lndpS to i64*
  %lndpU = load i64, i64* %lndpT, !tbaa !2
  store i64 %lndpU, i64* %lccnv
  %lndpW = load i64, i64* %lccnv
  %lndpV = load i64*, i64** %Hp_Var
  %lndpX = getelementptr inbounds i64, i64* %lndpV, i32 -24
  store i64 %lndpW, i64* %lndpX, !tbaa !3
  %lndpZ = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saKr_info$def to i64
  %lndpY = load i64*, i64** %Hp_Var
  %lndq0 = getelementptr inbounds i64, i64* %lndpY, i32 -23
  store i64 %lndpZ, i64* %lndq0, !tbaa !3
  %lndq2 = load i64*, i64** %Sp_Var
  %lndq3 = getelementptr inbounds i64, i64* %lndq2, i32 6
  %lndq4 = bitcast i64* %lndq3 to i64*
  %lndq5 = load i64, i64* %lndq4, !tbaa !2
  %lndq1 = load i64*, i64** %Hp_Var
  %lndq6 = getelementptr inbounds i64, i64* %lndq1, i32 -21
  store i64 %lndq5, i64* %lndq6, !tbaa !3
  %lndq8 = load i64, i64* %lccmX
  %lndq7 = load i64*, i64** %Hp_Var
  %lndq9 = getelementptr inbounds i64, i64* %lndq7, i32 -20
  store i64 %lndq8, i64* %lndq9, !tbaa !3
  %lndqa = load i64*, i64** %Hp_Var
  %lndqb = getelementptr inbounds i64, i64* %lndqa, i32 -33
  %lndqc = ptrtoint i64* %lndqb to i64
  store i64 %lndqc, i64* %lccnC
  %lndqe = load i64, i64* %lccnC
  %lndqd = load i64*, i64** %Hp_Var
  %lndqf = getelementptr inbounds i64, i64* %lndqd, i32 -19
  store i64 %lndqe, i64* %lndqf, !tbaa !3
  %lndqh = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saKw_info$def to i64
  %lndqg = load i64*, i64** %Hp_Var
  %lndqi = getelementptr inbounds i64, i64* %lndqg, i32 -18
  store i64 %lndqh, i64* %lndqi, !tbaa !3
  %lndqk = load i64, i64* %lccmX
  %lndqj = load i64*, i64** %Hp_Var
  %lndql = getelementptr inbounds i64, i64* %lndqj, i32 -16
  store i64 %lndqk, i64* %lndql, !tbaa !3
  %lndqn = load i64, i64* %lccnC
  %lndqm = load i64*, i64** %Hp_Var
  %lndqo = getelementptr inbounds i64, i64* %lndqm, i32 -15
  store i64 %lndqn, i64* %lndqo, !tbaa !3
  %lndqp = load i64*, i64** %Hp_Var
  %lndqq = getelementptr inbounds i64, i64* %lndqp, i32 -23
  %lndqr = ptrtoint i64* %lndqq to i64
  store i64 %lndqr, i64* %lccnE
  %lndqt = load i64, i64* %lccnE
  %lndqs = load i64*, i64** %Hp_Var
  %lndqu = getelementptr inbounds i64, i64* %lndqs, i32 -14
  store i64 %lndqt, i64* %lndqu, !tbaa !3
  %lndqw = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saKN_info$def to i64
  %lndqv = load i64*, i64** %Hp_Var
  %lndqx = getelementptr inbounds i64, i64* %lndqv, i32 -13
  store i64 %lndqw, i64* %lndqx, !tbaa !3
  %lndqz = load i64, i64* %lccmX
  %lndqy = load i64*, i64** %Hp_Var
  %lndqA = getelementptr inbounds i64, i64* %lndqy, i32 -11
  store i64 %lndqz, i64* %lndqA, !tbaa !3
  %lndqC = load i64, i64* %lccn1
  %lndqB = load i64*, i64** %Hp_Var
  %lndqD = getelementptr inbounds i64, i64* %lndqB, i32 -10
  store i64 %lndqC, i64* %lndqD, !tbaa !3
  %lndqF = load i64, i64* %lccnv
  %lndqE = load i64*, i64** %Hp_Var
  %lndqG = getelementptr inbounds i64, i64* %lndqE, i32 -9
  store i64 %lndqF, i64* %lndqG, !tbaa !3
  %lndqI = load i64, i64* %lccnC
  %lndqH = load i64*, i64** %Hp_Var
  %lndqJ = getelementptr inbounds i64, i64* %lndqH, i32 -8
  store i64 %lndqI, i64* %lndqJ, !tbaa !3
  %lndqK = load i64*, i64** %Hp_Var
  %lndqL = getelementptr inbounds i64, i64* %lndqK, i32 -18
  %lndqM = ptrtoint i64* %lndqL to i64
  store i64 %lndqM, i64* %lccnG
  %lndqO = load i64, i64* %lccnG
  %lndqN = load i64*, i64** %Hp_Var
  %lndqP = getelementptr inbounds i64, i64* %lndqN, i32 -7
  store i64 %lndqO, i64* %lndqP, !tbaa !3
  %lndqR = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saL6_info$def to i64
  %lndqQ = load i64*, i64** %Hp_Var
  %lndqS = getelementptr inbounds i64, i64* %lndqQ, i32 -6
  store i64 %lndqR, i64* %lndqS, !tbaa !3
  %lndqU = load i64, i64* %lsaI2
  %lndqT = load i64*, i64** %Hp_Var
  %lndqV = getelementptr inbounds i64, i64* %lndqT, i32 -4
  store i64 %lndqU, i64* %lndqV, !tbaa !3
  %lndqX = load i64, i64* %lccmX
  %lndqW = load i64*, i64** %Hp_Var
  %lndqY = getelementptr inbounds i64, i64* %lndqW, i32 -3
  store i64 %lndqX, i64* %lndqY, !tbaa !3
  %lndr0 = load i64, i64* %lsaJw
  %lndqZ = load i64*, i64** %Hp_Var
  %lndr1 = getelementptr inbounds i64, i64* %lndqZ, i32 -2
  store i64 %lndr0, i64* %lndr1, !tbaa !3
  %lndr3 = load i64, i64* %lccnC
  %lndr2 = load i64*, i64** %Hp_Var
  %lndr4 = getelementptr inbounds i64, i64* %lndr2, i32 -1
  store i64 %lndr3, i64* %lndr4, !tbaa !3
  %lndr5 = load i64*, i64** %Hp_Var
  %lndr6 = getelementptr inbounds i64, i64* %lndr5, i32 -13
  %lndr7 = ptrtoint i64* %lndr6 to i64
  store i64 %lndr7, i64* %lccnI
  %lndr9 = load i64, i64* %lccnI
  %lndr8 = load i64*, i64** %Hp_Var
  %lndra = getelementptr inbounds i64, i64* %lndr8, i32 0
  store i64 %lndr9, i64* %lndra, !tbaa !3
  %lndrc = load i64*, i64** %Sp_Var
  %lndrd = getelementptr inbounds i64, i64* %lndrc, i32 7
  %lndre = bitcast i64* %lndrd to i64*
  %lndrf = load i64, i64* %lndre, !tbaa !2
  %lndrg = add i64 %lndrf, -1
  %lndrb = load i64*, i64** %Sp_Var
  %lndrh = getelementptr inbounds i64, i64* %lndrb, i32 7
  store i64 %lndrg, i64* %lndrh, !tbaa !2
  %lndrj = load i64, i64* %lccnv
  %lndri = load i64*, i64** %Sp_Var
  %lndrk = getelementptr inbounds i64, i64* %lndri, i32 8
  store i64 %lndrj, i64* %lndrk, !tbaa !2
  %lndrm = load i64, i64* %lccnC
  %lndrl = load i64*, i64** %Sp_Var
  %lndrn = getelementptr inbounds i64, i64* %lndrl, i32 9
  store i64 %lndrm, i64* %lndrn, !tbaa !2
  %lndrp = load i64, i64* %lccnE
  %lndro = load i64*, i64** %Sp_Var
  %lndrq = getelementptr inbounds i64, i64* %lndro, i32 10
  store i64 %lndrp, i64* %lndrq, !tbaa !2
  %lndrs = load i64, i64* %lccnG
  %lndrr = load i64*, i64** %Sp_Var
  %lndrt = getelementptr inbounds i64, i64* %lndrr, i32 11
  store i64 %lndrs, i64* %lndrt, !tbaa !2
  %lndrv = load i64, i64* %lccnI
  %lndru = load i64*, i64** %Sp_Var
  %lndrw = getelementptr inbounds i64, i64* %lndru, i32 12
  store i64 %lndrv, i64* %lndrw, !tbaa !2
  %lndry = load i64*, i64** %Hp_Var
  %lndrz = getelementptr inbounds i64, i64* %lndry, i32 -6
  %lndrA = ptrtoint i64* %lndrz to i64
  %lndrx = load i64*, i64** %Sp_Var
  %lndrB = getelementptr inbounds i64, i64* %lndrx, i32 13
  store i64 %lndrA, i64* %lndrB, !tbaa !2
  %lndrC = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ccnl_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndrD = load i64*, i64** %Sp_Var
  %lndrE = load i64*, i64** %Hp_Var
  %lndrF = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndrC( i64* %Base_Arg, i64* %lndrD, i64* %lndrE, i64 %lndrF, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ccur:
  %lndrG = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 272, i64* %lndrG, !tbaa !5
  %lndrH = load i64, i64* %R1_Var
  store i64 %lndrH, i64* %R1_Var
  %lndrI = bitcast i8* @stg_gc_unpt_r1 to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndrJ = load i64*, i64** %Sp_Var
  %lndrK = load i64*, i64** %Hp_Var
  %lndrL = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndrI( i64* %Base_Arg, i64* %lndrJ, i64* %lndrK, i64 %lndrL, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
ccuv:
  %lndrM = load i64, i64* %lsaJw
  %lndrN = and i64 %lndrM, -8
  store i64 %lndrN, i64* %R1_Var
  %lndrO = load i64*, i64** %Sp_Var
  %lndrP = getelementptr inbounds i64, i64* %lndrO, i32 17
  %lndrQ = ptrtoint i64* %lndrP to i64
  %lndrR = inttoptr i64 %lndrQ to i64*
  store i64* %lndrR, i64** %Sp_Var
  %lndrT = load i64, i64* %R1_Var
  %lndrU = inttoptr i64 %lndrT to i64*
  %lndrV = load i64, i64* %lndrU, !tbaa !4
  %lndrW = inttoptr i64 %lndrV to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndrX = load i64*, i64** %Sp_Var
  %lndrY = load i64*, i64** %Hp_Var
  %lndrZ = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndrW( i64* %Base_Arg, i64* %lndrX, i64* %lndrY, i64 %lndrZ, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
%Main_conjugateGradient_closure_struct = type <{i64, i64}>
@Main_conjugateGradient_closure$def = internal global %Main_conjugateGradient_closure_struct<{i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_conjugateGradient_info$def to i64), i64 0}>
@Main_conjugateGradient_closure = alias i8, bitcast (%Main_conjugateGradient_closure_struct* @Main_conjugateGradient_closure$def to i8*)



==================== LLVM Code ====================
@Main_conjugateGradient_slow = alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_conjugateGradient_slow$def to i8*)
define ghccc void @Main_conjugateGradient_slow$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind
{
cds1:
  %R6_Var = alloca i64, i32 1
  store i64 undef, i64* %R6_Var
  %R5_Var = alloca i64, i32 1
  store i64 undef, i64* %R5_Var
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lndsf = load i64*, i64** %Sp_Var
  %lndsg = getelementptr inbounds i64, i64* %lndsf, i32 4
  %lndsh = bitcast i64* %lndsg to i64*
  %lndsi = load i64, i64* %lndsh, !tbaa !2
  store i64 %lndsi, i64* %R6_Var
  %lndsj = load i64*, i64** %Sp_Var
  %lndsk = getelementptr inbounds i64, i64* %lndsj, i32 3
  %lndsl = bitcast i64* %lndsk to i64*
  %lndsm = load i64, i64* %lndsl, !tbaa !2
  store i64 %lndsm, i64* %R5_Var
  %lndsn = load i64*, i64** %Sp_Var
  %lndso = getelementptr inbounds i64, i64* %lndsn, i32 2
  %lndsp = bitcast i64* %lndso to i64*
  %lndsq = load i64, i64* %lndsp, !tbaa !2
  store i64 %lndsq, i64* %R4_Var
  %lndsr = load i64*, i64** %Sp_Var
  %lndss = getelementptr inbounds i64, i64* %lndsr, i32 1
  %lndst = bitcast i64* %lndss to i64*
  %lndsu = load i64, i64* %lndst, !tbaa !2
  store i64 %lndsu, i64* %R3_Var
  %lndsv = load i64*, i64** %Sp_Var
  %lndsw = getelementptr inbounds i64, i64* %lndsv, i32 0
  %lndsx = bitcast i64* %lndsw to i64*
  %lndsy = load i64, i64* %lndsx, !tbaa !2
  store i64 %lndsy, i64* %R2_Var
  %lndsz = load i64, i64* %R1_Var
  store i64 %lndsz, i64* %R1_Var
  %lndsA = load i64*, i64** %Sp_Var
  %lndsB = getelementptr inbounds i64, i64* %lndsA, i32 5
  %lndsC = ptrtoint i64* %lndsB to i64
  %lndsD = inttoptr i64 %lndsC to i64*
  store i64* %lndsD, i64** %Sp_Var
  %lndsE = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_conjugateGradient_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndsF = load i64*, i64** %Sp_Var
  %lndsG = load i64, i64* %R1_Var
  %lndsH = load i64, i64* %R2_Var
  %lndsI = load i64, i64* %R3_Var
  %lndsJ = load i64, i64* %R4_Var
  %lndsK = load i64, i64* %R5_Var
  %lndsL = load i64, i64* %R6_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndsE( i64* %Base_Arg, i64* %lndsF, i64* %Hp_Arg, i64 %lndsG, i64 %lndsH, i64 %lndsI, i64 %lndsJ, i64 %lndsK, i64 %lndsL, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@Main_conjugateGradient_info = alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_conjugateGradient_info$def to i8*)
define ghccc void @Main_conjugateGradient_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i64, i64, i64, i32, i32}><{i64 add (i64 sub (i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_conjugateGradient_slow$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_conjugateGradient_info$def to i64)),i64 0), i64 7, i64 30064771072, i64 0, i32 14, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%Main_zdwconjugateGradient_closure_struct* @Main_zdwconjugateGradient_closure$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_conjugateGradient_info$def to i64)) to i32),i32 0)}>
{
cds8:
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lndsM = load i64*, i64** %Sp_Var
  %lndsN = getelementptr inbounds i64, i64* %lndsM, i32 -4
  %lndsO = ptrtoint i64* %lndsN to i64
  %lndsP = icmp ult i64 %lndsO, %SpLim_Arg
  %lndsQ = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lndsP, i1 0 )
  br i1 %lndsQ, label %cds9, label %cdsa
cdsa:
  %lndsS = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cds5_info$def to i64
  %lndsR = load i64*, i64** %Sp_Var
  %lndsT = getelementptr inbounds i64, i64* %lndsR, i32 -4
  store i64 %lndsS, i64* %lndsT, !tbaa !2
  %lndsU = load i64*, i64** %Sp_Var
  %lndsV = getelementptr inbounds i64, i64* %lndsU, i32 0
  %lndsW = bitcast i64* %lndsV to i64*
  %lndsX = load i64, i64* %lndsW, !tbaa !2
  store i64 %lndsX, i64* %R1_Var
  %lndsY = load i64*, i64** %Sp_Var
  %lndsZ = getelementptr inbounds i64, i64* %lndsY, i32 -3
  store i64 %R4_Arg, i64* %lndsZ, !tbaa !2
  %lndt0 = load i64*, i64** %Sp_Var
  %lndt1 = getelementptr inbounds i64, i64* %lndt0, i32 -2
  store i64 %R5_Arg, i64* %lndt1, !tbaa !2
  %lndt2 = load i64*, i64** %Sp_Var
  %lndt3 = getelementptr inbounds i64, i64* %lndt2, i32 -1
  store i64 %R6_Arg, i64* %lndt3, !tbaa !2
  %lndt4 = load i64*, i64** %Sp_Var
  %lndt5 = getelementptr inbounds i64, i64* %lndt4, i32 0
  store i64 %R3_Arg, i64* %lndt5, !tbaa !2
  %lndt6 = load i64*, i64** %Sp_Var
  %lndt7 = getelementptr inbounds i64, i64* %lndt6, i32 -4
  %lndt8 = ptrtoint i64* %lndt7 to i64
  %lndt9 = inttoptr i64 %lndt8 to i64*
  store i64* %lndt9, i64** %Sp_Var
  %lndta = load i64, i64* %R1_Var
  %lndtb = and i64 %lndta, 7
  %lndtc = icmp ne i64 %lndtb, 0
  br i1 %lndtc, label %udse, label %cds6
cds6:
  %lndte = load i64, i64* %R1_Var
  %lndtf = inttoptr i64 %lndte to i64*
  %lndtg = load i64, i64* %lndtf, !tbaa !4
  %lndth = inttoptr i64 %lndtg to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndti = load i64*, i64** %Sp_Var
  %lndtj = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndth( i64* %Base_Arg, i64* %lndti, i64* %Hp_Arg, i64 %lndtj, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
udse:
  %lndtk = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cds5_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndtl = load i64*, i64** %Sp_Var
  %lndtm = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndtk( i64* %Base_Arg, i64* %lndtl, i64* %Hp_Arg, i64 %lndtm, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cds9:
  %lndtn = ptrtoint %Main_conjugateGradient_closure_struct* @Main_conjugateGradient_closure$def to i64
  store i64 %lndtn, i64* %R1_Var
  %lndto = load i64*, i64** %Sp_Var
  %lndtp = getelementptr inbounds i64, i64* %lndto, i32 -5
  store i64 %R2_Arg, i64* %lndtp, !tbaa !2
  %lndtq = load i64*, i64** %Sp_Var
  %lndtr = getelementptr inbounds i64, i64* %lndtq, i32 -4
  store i64 %R3_Arg, i64* %lndtr, !tbaa !2
  %lndts = load i64*, i64** %Sp_Var
  %lndtt = getelementptr inbounds i64, i64* %lndts, i32 -3
  store i64 %R4_Arg, i64* %lndtt, !tbaa !2
  %lndtu = load i64*, i64** %Sp_Var
  %lndtv = getelementptr inbounds i64, i64* %lndtu, i32 -2
  store i64 %R5_Arg, i64* %lndtv, !tbaa !2
  %lndtw = load i64*, i64** %Sp_Var
  %lndtx = getelementptr inbounds i64, i64* %lndtw, i32 -1
  store i64 %R6_Arg, i64* %lndtx, !tbaa !2
  %lndty = load i64*, i64** %Sp_Var
  %lndtz = getelementptr inbounds i64, i64* %lndty, i32 -5
  %lndtA = ptrtoint i64* %lndtz to i64
  %lndtB = inttoptr i64 %lndtA to i64*
  store i64* %lndtB, i64** %Sp_Var
  %lndtC = getelementptr inbounds i64, i64* %Base_Arg, i32 -1
  %lndtD = bitcast i64* %lndtC to i64*
  %lndtE = load i64, i64* %lndtD, !tbaa !5
  %lndtF = inttoptr i64 %lndtE to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndtG = load i64*, i64** %Sp_Var
  %lndtH = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndtF( i64* %Base_Arg, i64* %lndtG, i64* %Hp_Arg, i64 %lndtH, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cds5_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cds5_info$def to i8*)
define internal ghccc void @cds5_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 5, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%Main_zdwconjugateGradient_closure_struct* @Main_zdwconjugateGradient_closure$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cds5_info$def to i64)) to i32),i32 0)}>
{
cds5:
  %R6_Var = alloca i64, i32 1
  store i64 undef, i64* %R6_Var
  %R5_Var = alloca i64, i32 1
  store i64 undef, i64* %R5_Var
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lndtI = add i64 %R1_Arg, 15
  %lndtJ = inttoptr i64 %lndtI to i64*
  %lndtK = load i64, i64* %lndtJ, !tbaa !4
  store i64 %lndtK, i64* %R6_Var
  %lndtL = load i64*, i64** %Sp_Var
  %lndtM = getelementptr inbounds i64, i64* %lndtL, i32 3
  %lndtN = bitcast i64* %lndtM to i64*
  %lndtO = load i64, i64* %lndtN, !tbaa !2
  store i64 %lndtO, i64* %R5_Var
  %lndtP = load i64*, i64** %Sp_Var
  %lndtQ = getelementptr inbounds i64, i64* %lndtP, i32 2
  %lndtR = bitcast i64* %lndtQ to i64*
  %lndtS = load i64, i64* %lndtR, !tbaa !2
  store i64 %lndtS, i64* %R4_Var
  %lndtT = load i64*, i64** %Sp_Var
  %lndtU = getelementptr inbounds i64, i64* %lndtT, i32 1
  %lndtV = bitcast i64* %lndtU to i64*
  %lndtW = load i64, i64* %lndtV, !tbaa !2
  store i64 %lndtW, i64* %R3_Var
  %lndtX = load i64*, i64** %Sp_Var
  %lndtY = getelementptr inbounds i64, i64* %lndtX, i32 4
  %lndtZ = bitcast i64* %lndtY to i64*
  %lndu0 = load i64, i64* %lndtZ, !tbaa !2
  store i64 %lndu0, i64* %R2_Var
  %lndu2 = add i64 %R1_Arg, 23
  %lndu3 = inttoptr i64 %lndu2 to i64*
  %lndu4 = load i64, i64* %lndu3, !tbaa !4
  %lndu1 = load i64*, i64** %Sp_Var
  %lndu5 = getelementptr inbounds i64, i64* %lndu1, i32 3
  store i64 %lndu4, i64* %lndu5, !tbaa !2
  %lndu7 = add i64 %R1_Arg, 7
  %lndu8 = inttoptr i64 %lndu7 to i64*
  %lndu9 = load i64, i64* %lndu8, !tbaa !4
  %lndu6 = load i64*, i64** %Sp_Var
  %lndua = getelementptr inbounds i64, i64* %lndu6, i32 4
  store i64 %lndu9, i64* %lndua, !tbaa !2
  %lndub = load i64*, i64** %Sp_Var
  %lnduc = getelementptr inbounds i64, i64* %lndub, i32 3
  %lndud = ptrtoint i64* %lnduc to i64
  %lndue = inttoptr i64 %lndud to i64*
  store i64* %lndue, i64** %Sp_Var
  %lnduf = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_zdwconjugateGradient_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndug = load i64*, i64** %Sp_Var
  %lnduh = load i64, i64* %R2_Var
  %lndui = load i64, i64* %R3_Var
  %lnduj = load i64, i64* %R4_Var
  %lnduk = load i64, i64* %R5_Var
  %lndul = load i64, i64* %R6_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnduf( i64* %Base_Arg, i64* %lndug, i64* %Hp_Arg, i64 %R1_Arg, i64 %lnduh, i64 %lndui, i64 %lnduj, i64 %lnduk, i64 %lndul, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
%Main_zdtrModule4_bytes_struct = type <{[5 x i8]}>
@Main_zdtrModule4_bytes$def = internal constant %Main_zdtrModule4_bytes_struct<{[5 x i8] [i8 109, i8 97, i8 105, i8 110, i8 0]}>, align 1
@Main_zdtrModule4_bytes = alias i8, bitcast (%Main_zdtrModule4_bytes_struct* @Main_zdtrModule4_bytes$def to i8*)



==================== LLVM Code ====================
%Main_zdtrModule3_closure_struct = type <{i64, i64}>
@Main_zdtrModule3_closure$def = internal global %Main_zdtrModule3_closure_struct<{i64 ptrtoint (i8* @ghczmprim_GHCziTypes_TrNameS_con_info to i64), i64 ptrtoint (%Main_zdtrModule4_bytes_struct* @Main_zdtrModule4_bytes$def to i64)}>
@Main_zdtrModule3_closure = alias i8, bitcast (%Main_zdtrModule3_closure_struct* @Main_zdtrModule3_closure$def to i8*)



==================== LLVM Code ====================
%Main_zdtrModule2_bytes_struct = type <{[5 x i8]}>
@Main_zdtrModule2_bytes$def = internal constant %Main_zdtrModule2_bytes_struct<{[5 x i8] [i8 77, i8 97, i8 105, i8 110, i8 0]}>, align 1
@Main_zdtrModule2_bytes = alias i8, bitcast (%Main_zdtrModule2_bytes_struct* @Main_zdtrModule2_bytes$def to i8*)



==================== LLVM Code ====================
%Main_zdtrModule1_closure_struct = type <{i64, i64}>
@Main_zdtrModule1_closure$def = internal global %Main_zdtrModule1_closure_struct<{i64 ptrtoint (i8* @ghczmprim_GHCziTypes_TrNameS_con_info to i64), i64 ptrtoint (%Main_zdtrModule2_bytes_struct* @Main_zdtrModule2_bytes$def to i64)}>
@Main_zdtrModule1_closure = alias i8, bitcast (%Main_zdtrModule1_closure_struct* @Main_zdtrModule1_closure$def to i8*)



==================== LLVM Code ====================
%Main_zdtrModule_closure_struct = type <{i64, i64, i64, i64}>
@Main_zdtrModule_closure$def = internal global %Main_zdtrModule_closure_struct<{i64 ptrtoint (i8* @ghczmprim_GHCziTypes_Module_con_info to i64), i64 add (i64 ptrtoint (%Main_zdtrModule3_closure_struct* @Main_zdtrModule3_closure$def to i64),i64 1), i64 add (i64 ptrtoint (%Main_zdtrModule1_closure_struct* @Main_zdtrModule1_closure$def to i64),i64 1), i64 3}>
@Main_zdtrModule_closure = alias i8, bitcast (%Main_zdtrModule_closure_struct* @Main_zdtrModule_closure$def to i8*)



==================== LLVM Code ====================
%uduv_srt_struct = type <{i64, i64, i64}>
%raBR_closure_struct = type <{i64, i64, i64, i64}>
@uduv_srt$def = internal global %uduv_srt_struct<{i64 ptrtoint (i8* @stg_SRT_1_info to i64), i64 ptrtoint (i8* @hblaszm0zi0zi0zi0zminplace_HBLASziIOziVector_zdwcreateSymSq_closure to i64), i64 0}>
@uduv_srt = internal alias i8, bitcast (%uduv_srt_struct* @uduv_srt$def to i8*)
@raBR_closure$def = internal global %raBR_closure_struct<{i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @raBR_info$def to i64), i64 0, i64 0, i64 0}>
@raBR_closure = internal alias i8, bitcast (%raBR_closure_struct* @raBR_closure$def to i8*)



==================== LLVM Code ====================
@raBR_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @raBR_info$def to i8*)
define internal ghccc void @raBR_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 0, i32 21, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%uduv_srt_struct* @uduv_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @raBR_info$def to i64)) to i32),i32 0)}>
{
cdus:
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R5_Var = alloca i64, i32 1
  store i64 undef, i64* %R5_Var
  %R6_Var = alloca i64, i32 1
  store i64 undef, i64* %R6_Var
  %F1_Var = alloca float, i32 1
  store float undef, float* %F1_Var
  %D1_Var = alloca double, i32 1
  store double undef, double* %D1_Var
  %F2_Var = alloca float, i32 1
  store float undef, float* %F2_Var
  %D2_Var = alloca double, i32 1
  store double undef, double* %D2_Var
  %F3_Var = alloca float, i32 1
  store float undef, float* %F3_Var
  %D3_Var = alloca double, i32 1
  store double undef, double* %D3_Var
  %F4_Var = alloca float, i32 1
  store float undef, float* %F4_Var
  %D4_Var = alloca double, i32 1
  store double undef, double* %D4_Var
  %F5_Var = alloca float, i32 1
  store float undef, float* %F5_Var
  %D5_Var = alloca double, i32 1
  store double undef, double* %D5_Var
  %F6_Var = alloca float, i32 1
  store float undef, float* %F6_Var
  %D6_Var = alloca double, i32 1
  store double undef, double* %D6_Var
  %lcdup = alloca i64, i32 1
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lnduw = load i64*, i64** %Sp_Var
  %lndux = getelementptr inbounds i64, i64* %lnduw, i32 -2
  %lnduy = ptrtoint i64* %lndux to i64
  %lnduz = icmp ult i64 %lnduy, %SpLim_Arg
  %lnduA = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lnduz, i1 0 )
  br i1 %lnduA, label %cdut, label %cduu
cduu:
  %lnduB = ptrtoint i64* %Base_Arg to i64
  %lnduC = inttoptr i64 %lnduB to i8*
  %lnduD = load i64, i64* %R1_Var
  %lnduE = inttoptr i64 %lnduD to i8*
  %lnduF = bitcast i8* @newCAF to i8* (i8*, i8*)*
  store i64 undef, i64* %R3_Var
  store i64 undef, i64* %R4_Var
  store i64 undef, i64* %R5_Var
  store i64 undef, i64* %R6_Var
  store float undef, float* %F1_Var
  store double undef, double* %D1_Var
  store float undef, float* %F2_Var
  store double undef, double* %D2_Var
  store float undef, float* %F3_Var
  store double undef, double* %D3_Var
  store float undef, float* %F4_Var
  store double undef, double* %D4_Var
  store float undef, float* %F5_Var
  store double undef, double* %D5_Var
  store float undef, float* %F6_Var
  store double undef, double* %D6_Var
  %lnduG = call ccc i8* (i8*, i8*) %lnduF( i8* %lnduC, i8* %lnduE ) nounwind
  %lnduH = ptrtoint i8* %lnduG to i64
  store i64 %lnduH, i64* %lcdup
  %lnduI = load i64, i64* %lcdup
  %lnduJ = icmp eq i64 %lnduI, 0
  br i1 %lnduJ, label %cdur, label %cduq
cduq:
  %lnduL = ptrtoint i8* @stg_bh_upd_frame_info to i64
  %lnduK = load i64*, i64** %Sp_Var
  %lnduM = getelementptr inbounds i64, i64* %lnduK, i32 -2
  store i64 %lnduL, i64* %lnduM, !tbaa !2
  %lnduO = load i64, i64* %lcdup
  %lnduN = load i64*, i64** %Sp_Var
  %lnduP = getelementptr inbounds i64, i64* %lnduN, i32 -1
  store i64 %lnduO, i64* %lnduP, !tbaa !2
  store i64 1000, i64* %R4_Var
  store i64 0, i64* %R3_Var
  %lnduQ = ptrtoint i8* @base_GHCziFloat_zdfNumDouble_closure to i64
  store i64 %lnduQ, i64* %R2_Var
  %lnduR = load i64*, i64** %Sp_Var
  %lnduS = getelementptr inbounds i64, i64* %lnduR, i32 -2
  %lnduT = ptrtoint i64* %lnduS to i64
  %lnduU = inttoptr i64 %lnduT to i64*
  store i64* %lnduU, i64** %Sp_Var
  %lnduV = bitcast i8* @hblaszm0zi0zi0zi0zminplace_HBLASziIOziVector_zdwcreateSymSq_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lnduW = load i64*, i64** %Sp_Var
  %lnduX = load i64, i64* %R1_Var
  %lnduY = load i64, i64* %R2_Var
  %lnduZ = load i64, i64* %R3_Var
  %lndv0 = load i64, i64* %R4_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lnduV( i64* %Base_Arg, i64* %lnduW, i64* %Hp_Arg, i64 %lnduX, i64 %lnduY, i64 %lnduZ, i64 %lndv0, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cdur:
  %lndv2 = load i64, i64* %R1_Var
  %lndv3 = inttoptr i64 %lndv2 to i64*
  %lndv4 = load i64, i64* %lndv3, !tbaa !4
  %lndv5 = inttoptr i64 %lndv4 to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndv6 = load i64*, i64** %Sp_Var
  %lndv7 = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndv5( i64* %Base_Arg, i64* %lndv6, i64* %Hp_Arg, i64 %lndv7, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cdut:
  %lndv8 = load i64, i64* %R1_Var
  store i64 %lndv8, i64* %R1_Var
  %lndv9 = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lndva = bitcast i64* %lndv9 to i64*
  %lndvb = load i64, i64* %lndva, !tbaa !5
  %lndvc = inttoptr i64 %lndvb to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndvd = load i64*, i64** %Sp_Var
  %lndve = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndvc( i64* %Base_Arg, i64* %lndvd, i64* %Hp_Arg, i64 %lndve, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
%udvo_srt_struct = type <{i64, i64, i64}>
%raBS_closure_struct = type <{i64, i64, i64, i64}>
@udvo_srt$def = internal global %udvo_srt_struct<{i64 ptrtoint (i8* @stg_SRT_1_info to i64), i64 ptrtoint (i8* @hblaszm0zi0zi0zi0zminplace_HBLASziIOziVector_zdwcreateVecXzq_closure to i64), i64 0}>
@udvo_srt = internal alias i8, bitcast (%udvo_srt_struct* @udvo_srt$def to i8*)
@raBS_closure$def = internal global %raBS_closure_struct<{i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @raBS_info$def to i64), i64 0, i64 0, i64 0}>
@raBS_closure = internal alias i8, bitcast (%raBS_closure_struct* @raBS_closure$def to i8*)



==================== LLVM Code ====================
@raBS_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @raBS_info$def to i8*)
define internal ghccc void @raBS_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 0, i32 21, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%udvo_srt_struct* @udvo_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @raBS_info$def to i64)) to i32),i32 0)}>
{
cdvl:
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R5_Var = alloca i64, i32 1
  store i64 undef, i64* %R5_Var
  %R6_Var = alloca i64, i32 1
  store i64 undef, i64* %R6_Var
  %F1_Var = alloca float, i32 1
  store float undef, float* %F1_Var
  %D1_Var = alloca double, i32 1
  store double undef, double* %D1_Var
  %F2_Var = alloca float, i32 1
  store float undef, float* %F2_Var
  %D2_Var = alloca double, i32 1
  store double undef, double* %D2_Var
  %F3_Var = alloca float, i32 1
  store float undef, float* %F3_Var
  %D3_Var = alloca double, i32 1
  store double undef, double* %D3_Var
  %F4_Var = alloca float, i32 1
  store float undef, float* %F4_Var
  %D4_Var = alloca double, i32 1
  store double undef, double* %D4_Var
  %F5_Var = alloca float, i32 1
  store float undef, float* %F5_Var
  %D5_Var = alloca double, i32 1
  store double undef, double* %D5_Var
  %F6_Var = alloca float, i32 1
  store float undef, float* %F6_Var
  %D6_Var = alloca double, i32 1
  store double undef, double* %D6_Var
  %lcdvi = alloca i64, i32 1
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lndvp = load i64*, i64** %Sp_Var
  %lndvq = getelementptr inbounds i64, i64* %lndvp, i32 -2
  %lndvr = ptrtoint i64* %lndvq to i64
  %lndvs = icmp ult i64 %lndvr, %SpLim_Arg
  %lndvt = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lndvs, i1 0 )
  br i1 %lndvt, label %cdvm, label %cdvn
cdvn:
  %lndvu = ptrtoint i64* %Base_Arg to i64
  %lndvv = inttoptr i64 %lndvu to i8*
  %lndvw = load i64, i64* %R1_Var
  %lndvx = inttoptr i64 %lndvw to i8*
  %lndvy = bitcast i8* @newCAF to i8* (i8*, i8*)*
  store i64 undef, i64* %R3_Var
  store i64 undef, i64* %R4_Var
  store i64 undef, i64* %R5_Var
  store i64 undef, i64* %R6_Var
  store float undef, float* %F1_Var
  store double undef, double* %D1_Var
  store float undef, float* %F2_Var
  store double undef, double* %D2_Var
  store float undef, float* %F3_Var
  store double undef, double* %D3_Var
  store float undef, float* %F4_Var
  store double undef, double* %D4_Var
  store float undef, float* %F5_Var
  store double undef, double* %D5_Var
  store float undef, float* %F6_Var
  store double undef, double* %D6_Var
  %lndvz = call ccc i8* (i8*, i8*) %lndvy( i8* %lndvv, i8* %lndvx ) nounwind
  %lndvA = ptrtoint i8* %lndvz to i64
  store i64 %lndvA, i64* %lcdvi
  %lndvB = load i64, i64* %lcdvi
  %lndvC = icmp eq i64 %lndvB, 0
  br i1 %lndvC, label %cdvk, label %cdvj
cdvj:
  %lndvE = ptrtoint i8* @stg_bh_upd_frame_info to i64
  %lndvD = load i64*, i64** %Sp_Var
  %lndvF = getelementptr inbounds i64, i64* %lndvD, i32 -2
  store i64 %lndvE, i64* %lndvF, !tbaa !2
  %lndvH = load i64, i64* %lcdvi
  %lndvG = load i64*, i64** %Sp_Var
  %lndvI = getelementptr inbounds i64, i64* %lndvG, i32 -1
  store i64 %lndvH, i64* %lndvI, !tbaa !2
  store i64 1000, i64* %R3_Var
  %lndvJ = ptrtoint i8* @base_GHCziFloat_zdfNumDouble_closure to i64
  store i64 %lndvJ, i64* %R2_Var
  %lndvK = load i64*, i64** %Sp_Var
  %lndvL = getelementptr inbounds i64, i64* %lndvK, i32 -2
  %lndvM = ptrtoint i64* %lndvL to i64
  %lndvN = inttoptr i64 %lndvM to i64*
  store i64* %lndvN, i64** %Sp_Var
  %lndvO = bitcast i8* @hblaszm0zi0zi0zi0zminplace_HBLASziIOziVector_zdwcreateVecXzq_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndvP = load i64*, i64** %Sp_Var
  %lndvQ = load i64, i64* %R1_Var
  %lndvR = load i64, i64* %R2_Var
  %lndvS = load i64, i64* %R3_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndvO( i64* %Base_Arg, i64* %lndvP, i64* %Hp_Arg, i64 %lndvQ, i64 %lndvR, i64 %lndvS, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cdvk:
  %lndvU = load i64, i64* %R1_Var
  %lndvV = inttoptr i64 %lndvU to i64*
  %lndvW = load i64, i64* %lndvV, !tbaa !4
  %lndvX = inttoptr i64 %lndvW to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndvY = load i64*, i64** %Sp_Var
  %lndvZ = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndvX( i64* %Base_Arg, i64* %lndvY, i64* %Hp_Arg, i64 %lndvZ, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cdvm:
  %lndw0 = load i64, i64* %R1_Var
  store i64 %lndw0, i64* %R1_Var
  %lndw1 = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lndw2 = bitcast i64* %lndw1 to i64*
  %lndw3 = load i64, i64* %lndw2, !tbaa !5
  %lndw4 = inttoptr i64 %lndw3 to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndw5 = load i64*, i64** %Sp_Var
  %lndw6 = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndw4( i64* %Base_Arg, i64* %lndw5, i64* %Hp_Arg, i64 %lndw6, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
%udwl_srt_struct = type <{i64, i64, i64}>
%udwm_srt_struct = type <{i64, i64, i64, i64}>
%raBT_closure_struct = type <{i64, i64, i64, i64}>
@udwl_srt$def = internal global %udwl_srt_struct<{i64 ptrtoint (i8* @stg_SRT_1_info to i64), i64 ptrtoint (i8* @base_GHCziFloat_zdfShowDouble2_closure to i64), i64 0}>
@udwl_srt = internal alias i8, bitcast (%udwl_srt_struct* @udwl_srt$def to i8*)
@udwm_srt$def = internal global %udwm_srt_struct<{i64 ptrtoint (i8* @stg_SRT_2_info to i64), i64 ptrtoint (%Main_zdwzdsround4dp_closure_struct* @Main_zdwzdsround4dp_closure$def to i64), i64 ptrtoint (i8* @udwl_srt to i64), i64 0}>
@udwm_srt = internal alias i8, bitcast (%udwm_srt_struct* @udwm_srt$def to i8*)
@raBT_closure$def = internal global %raBT_closure_struct<{i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @raBT_info$def to i64), i64 0, i64 0, i64 0}>
@raBT_closure = internal alias i8, bitcast (%raBT_closure_struct* @raBT_closure$def to i8*)



==================== LLVM Code ====================
@raBT_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @raBT_info$def to i8*)
define internal ghccc void @raBT_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 0, i32 21, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%udwm_srt_struct* @udwm_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @raBT_info$def to i64)) to i32),i32 0)}>
{
cdwf:
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R5_Var = alloca i64, i32 1
  store i64 undef, i64* %R5_Var
  %R6_Var = alloca i64, i32 1
  store i64 undef, i64* %R6_Var
  %F1_Var = alloca float, i32 1
  store float undef, float* %F1_Var
  %D1_Var = alloca double, i32 1
  store double undef, double* %D1_Var
  %F2_Var = alloca float, i32 1
  store float undef, float* %F2_Var
  %D2_Var = alloca double, i32 1
  store double undef, double* %D2_Var
  %F3_Var = alloca float, i32 1
  store float undef, float* %F3_Var
  %D3_Var = alloca double, i32 1
  store double undef, double* %D3_Var
  %F4_Var = alloca float, i32 1
  store float undef, float* %F4_Var
  %D4_Var = alloca double, i32 1
  store double undef, double* %D4_Var
  %F5_Var = alloca float, i32 1
  store float undef, float* %F5_Var
  %D5_Var = alloca double, i32 1
  store double undef, double* %D5_Var
  %F6_Var = alloca float, i32 1
  store float undef, float* %F6_Var
  %D6_Var = alloca double, i32 1
  store double undef, double* %D6_Var
  %lcdwa = alloca i64, i32 1
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lndwn = load i64*, i64** %Sp_Var
  %lndwo = getelementptr inbounds i64, i64* %lndwn, i32 -4
  %lndwp = ptrtoint i64* %lndwo to i64
  %lndwq = icmp ult i64 %lndwp, %SpLim_Arg
  %lndwr = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lndwq, i1 0 )
  br i1 %lndwr, label %cdwg, label %cdwh
cdwh:
  %lndws = ptrtoint i64* %Base_Arg to i64
  %lndwt = inttoptr i64 %lndws to i8*
  %lndwu = load i64, i64* %R1_Var
  %lndwv = inttoptr i64 %lndwu to i8*
  %lndww = bitcast i8* @newCAF to i8* (i8*, i8*)*
  store i64 undef, i64* %R3_Var
  store i64 undef, i64* %R4_Var
  store i64 undef, i64* %R5_Var
  store i64 undef, i64* %R6_Var
  store float undef, float* %F1_Var
  store double undef, double* %D1_Var
  store float undef, float* %F2_Var
  store double undef, double* %D2_Var
  store float undef, float* %F3_Var
  store double undef, double* %D3_Var
  store float undef, float* %F4_Var
  store double undef, double* %D4_Var
  store float undef, float* %F5_Var
  store double undef, double* %D5_Var
  store float undef, float* %F6_Var
  store double undef, double* %D6_Var
  %lndwx = call ccc i8* (i8*, i8*) %lndww( i8* %lndwt, i8* %lndwv ) nounwind
  %lndwy = ptrtoint i8* %lndwx to i64
  store i64 %lndwy, i64* %lcdwa
  %lndwz = load i64, i64* %lcdwa
  %lndwA = icmp eq i64 %lndwz, 0
  br i1 %lndwA, label %cdwc, label %cdwb
cdwb:
  %lndwC = ptrtoint i8* @stg_bh_upd_frame_info to i64
  %lndwB = load i64*, i64** %Sp_Var
  %lndwD = getelementptr inbounds i64, i64* %lndwB, i32 -2
  store i64 %lndwC, i64* %lndwD, !tbaa !2
  %lndwF = load i64, i64* %lcdwa
  %lndwE = load i64*, i64** %Sp_Var
  %lndwG = getelementptr inbounds i64, i64* %lndwE, i32 -1
  store i64 %lndwF, i64* %lndwG, !tbaa !2
  %lndwI = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64, double)* @cdwd_info$def to i64
  %lndwH = load i64*, i64** %Sp_Var
  %lndwJ = getelementptr inbounds i64, i64* %lndwH, i32 -3
  store i64 %lndwI, i64* %lndwJ, !tbaa !2
  store double 0x400921FB54442D18, double* %D1_Var
  %lndwK = load i64*, i64** %Sp_Var
  %lndwL = getelementptr inbounds i64, i64* %lndwK, i32 -3
  %lndwM = ptrtoint i64* %lndwL to i64
  %lndwN = inttoptr i64 %lndwM to i64*
  store i64* %lndwN, i64** %Sp_Var
  %lndwO = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64, double)* @Main_zdwzdsround4dp_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64, double)*
  %lndwP = load i64*, i64** %Sp_Var
  %lndwQ = load i64, i64* %R1_Var
  %lndwR = load double, double* %D1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64, double) %lndwO( i64* %Base_Arg, i64* %lndwP, i64* %Hp_Arg, i64 %lndwQ, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg, double %lndwR ) nounwind
  ret void
cdwc:
  %lndwT = load i64, i64* %R1_Var
  %lndwU = inttoptr i64 %lndwT to i64*
  %lndwV = load i64, i64* %lndwU, !tbaa !4
  %lndwW = inttoptr i64 %lndwV to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndwX = load i64*, i64** %Sp_Var
  %lndwY = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndwW( i64* %Base_Arg, i64* %lndwX, i64* %Hp_Arg, i64 %lndwY, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cdwg:
  %lndwZ = load i64, i64* %R1_Var
  store i64 %lndwZ, i64* %R1_Var
  %lndx0 = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lndx1 = bitcast i64* %lndx0 to i64*
  %lndx2 = load i64, i64* %lndx1, !tbaa !5
  %lndx3 = inttoptr i64 %lndx2 to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndx4 = load i64*, i64** %Sp_Var
  %lndx5 = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndx3( i64* %Base_Arg, i64* %lndx4, i64* %Hp_Arg, i64 %lndx5, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cdwd_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64, double)* @cdwd_info$def to i8*)
define internal ghccc void @cdwd_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg, double %D1_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 0, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%udwl_srt_struct* @udwl_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64, double)* @cdwd_info$def to i64)) to i32),i32 0)}>
{
cdwd:
  %D1_Var = alloca double, i32 1
  store double %D1_Arg, double* %D1_Var
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lndx6 = load double, double* %D1_Var
  store double %lndx6, double* %D1_Var
  %lndx7 = ptrtoint i8* @base_GHCziFloat_minExpt_closure to i64
  store i64 %lndx7, i64* %R3_Var
  %lndx8 = ptrtoint i8* @base_GHCziFloat_zdfShowDouble2_closure to i64
  %lndx9 = add i64 %lndx8, 1
  store i64 %lndx9, i64* %R2_Var
  %lndxb = ptrtoint i8* @stg_ap_p_info to i64
  %lndxa = load i64*, i64** %Sp_Var
  %lndxc = getelementptr inbounds i64, i64* %lndxa, i32 -1
  store i64 %lndxb, i64* %lndxc, !tbaa !2
  %lndxe = ptrtoint i8* @ghczmprim_GHCziTypes_ZMZN_closure to i64
  %lndxf = add i64 %lndxe, 1
  %lndxd = load i64*, i64** %Sp_Var
  %lndxg = getelementptr inbounds i64, i64* %lndxd, i32 0
  store i64 %lndxf, i64* %lndxg, !tbaa !2
  %lndxh = load i64*, i64** %Sp_Var
  %lndxi = getelementptr inbounds i64, i64* %lndxh, i32 -1
  %lndxj = ptrtoint i64* %lndxi to i64
  %lndxk = inttoptr i64 %lndxj to i64*
  store i64* %lndxk, i64** %Sp_Var
  %lndxl = bitcast i8* @base_GHCziFloat_zdwzdsshowSignedFloat_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64, double)*
  %lndxm = load i64*, i64** %Sp_Var
  %lndxn = load i64, i64* %R2_Var
  %lndxo = load i64, i64* %R3_Var
  %lndxp = load double, double* %D1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64, double) %lndxl( i64* %Base_Arg, i64* %lndxm, i64* %Hp_Arg, i64 %R1_Arg, i64 %lndxn, i64 %lndxo, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg, double %lndxp ) nounwind
  ret void
}



==================== LLVM Code ====================
%raBU_bytes_struct = type <{[13 x i8]}>
@raBU_bytes$def = internal constant %raBU_bytes_struct<{[13 x i8] [i8 77, i8 97, i8 116, i8 114, i8 105, i8 120, i8 32, i8 115, i8 105, i8 122, i8 101, i8 32, i8 0]}>, align 1
@raBU_bytes = internal alias i8, bitcast (%raBU_bytes_struct* @raBU_bytes$def to i8*)



==================== LLVM Code ====================
%raBV_bytes_struct = type <{[2 x i8]}>
@raBV_bytes$def = internal constant %raBV_bytes_struct<{[2 x i8] [i8 88, i8 0]}>, align 1
@raBV_bytes = internal alias i8, bitcast (%raBV_bytes_struct* @raBV_bytes$def to i8*)



==================== LLVM Code ====================
%raBW_bytes_struct = type <{[3 x i8]}>
@raBW_bytes$def = internal constant %raBW_bytes_struct<{[3 x i8] [i8 58, i8 32, i8 0]}>, align 1
@raBW_bytes = internal alias i8, bitcast (%raBW_bytes_struct* @raBW_bytes$def to i8*)



==================== LLVM Code ====================
%raBX_closure_struct = type <{i64, i64}>
@raBX_closure$def = internal global %raBX_closure_struct<{i64 ptrtoint (i8* @integerzmgmp_GHCziIntegerziType_Szh_con_info to i64), i64 1000000000000000000}>
@raBX_closure = internal alias i8, bitcast (%raBX_closure_struct* @raBX_closure$def to i8*)



==================== LLVM Code ====================
%udxz_srt_struct = type <{i64, i64, i64}>
%raBY_closure_struct = type <{i64, i64, i64, i64}>
@udxz_srt$def = internal global %udxz_srt_struct<{i64 ptrtoint (i8* @stg_SRT_1_info to i64), i64 ptrtoint (i8* @hblaszm0zi0zi0zi0zminplace_HBLASziIOziVector_zdwcreateVec0_closure to i64), i64 0}>
@udxz_srt = internal alias i8, bitcast (%udxz_srt_struct* @udxz_srt$def to i8*)
@raBY_closure$def = internal global %raBY_closure_struct<{i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @raBY_info$def to i64), i64 0, i64 0, i64 0}>
@raBY_closure = internal alias i8, bitcast (%raBY_closure_struct* @raBY_closure$def to i8*)



==================== LLVM Code ====================
@raBY_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @raBY_info$def to i8*)
define internal ghccc void @raBY_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 0, i32 21, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%udxz_srt_struct* @udxz_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @raBY_info$def to i64)) to i32),i32 0)}>
{
cdxw:
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R5_Var = alloca i64, i32 1
  store i64 undef, i64* %R5_Var
  %R6_Var = alloca i64, i32 1
  store i64 undef, i64* %R6_Var
  %F1_Var = alloca float, i32 1
  store float undef, float* %F1_Var
  %D1_Var = alloca double, i32 1
  store double undef, double* %D1_Var
  %F2_Var = alloca float, i32 1
  store float undef, float* %F2_Var
  %D2_Var = alloca double, i32 1
  store double undef, double* %D2_Var
  %F3_Var = alloca float, i32 1
  store float undef, float* %F3_Var
  %D3_Var = alloca double, i32 1
  store double undef, double* %D3_Var
  %F4_Var = alloca float, i32 1
  store float undef, float* %F4_Var
  %D4_Var = alloca double, i32 1
  store double undef, double* %D4_Var
  %F5_Var = alloca float, i32 1
  store float undef, float* %F5_Var
  %D5_Var = alloca double, i32 1
  store double undef, double* %D5_Var
  %F6_Var = alloca float, i32 1
  store float undef, float* %F6_Var
  %D6_Var = alloca double, i32 1
  store double undef, double* %D6_Var
  %lcdxt = alloca i64, i32 1
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lndxA = load i64*, i64** %Sp_Var
  %lndxB = getelementptr inbounds i64, i64* %lndxA, i32 -2
  %lndxC = ptrtoint i64* %lndxB to i64
  %lndxD = icmp ult i64 %lndxC, %SpLim_Arg
  %lndxE = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lndxD, i1 0 )
  br i1 %lndxE, label %cdxx, label %cdxy
cdxy:
  %lndxF = ptrtoint i64* %Base_Arg to i64
  %lndxG = inttoptr i64 %lndxF to i8*
  %lndxH = load i64, i64* %R1_Var
  %lndxI = inttoptr i64 %lndxH to i8*
  %lndxJ = bitcast i8* @newCAF to i8* (i8*, i8*)*
  store i64 undef, i64* %R3_Var
  store i64 undef, i64* %R4_Var
  store i64 undef, i64* %R5_Var
  store i64 undef, i64* %R6_Var
  store float undef, float* %F1_Var
  store double undef, double* %D1_Var
  store float undef, float* %F2_Var
  store double undef, double* %D2_Var
  store float undef, float* %F3_Var
  store double undef, double* %D3_Var
  store float undef, float* %F4_Var
  store double undef, double* %D4_Var
  store float undef, float* %F5_Var
  store double undef, double* %D5_Var
  store float undef, float* %F6_Var
  store double undef, double* %D6_Var
  %lndxK = call ccc i8* (i8*, i8*) %lndxJ( i8* %lndxG, i8* %lndxI ) nounwind
  %lndxL = ptrtoint i8* %lndxK to i64
  store i64 %lndxL, i64* %lcdxt
  %lndxM = load i64, i64* %lcdxt
  %lndxN = icmp eq i64 %lndxM, 0
  br i1 %lndxN, label %cdxv, label %cdxu
cdxu:
  %lndxP = ptrtoint i8* @stg_bh_upd_frame_info to i64
  %lndxO = load i64*, i64** %Sp_Var
  %lndxQ = getelementptr inbounds i64, i64* %lndxO, i32 -2
  store i64 %lndxP, i64* %lndxQ, !tbaa !2
  %lndxS = load i64, i64* %lcdxt
  %lndxR = load i64*, i64** %Sp_Var
  %lndxT = getelementptr inbounds i64, i64* %lndxR, i32 -1
  store i64 %lndxS, i64* %lndxT, !tbaa !2
  store i64 1000, i64* %R3_Var
  %lndxU = ptrtoint i8* @base_GHCziFloat_zdfNumDouble_closure to i64
  store i64 %lndxU, i64* %R2_Var
  %lndxV = load i64*, i64** %Sp_Var
  %lndxW = getelementptr inbounds i64, i64* %lndxV, i32 -2
  %lndxX = ptrtoint i64* %lndxW to i64
  %lndxY = inttoptr i64 %lndxX to i64*
  store i64* %lndxY, i64** %Sp_Var
  %lndxZ = bitcast i8* @hblaszm0zi0zi0zi0zminplace_HBLASziIOziVector_zdwcreateVec0_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndy0 = load i64*, i64** %Sp_Var
  %lndy1 = load i64, i64* %R1_Var
  %lndy2 = load i64, i64* %R2_Var
  %lndy3 = load i64, i64* %R3_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndxZ( i64* %Base_Arg, i64* %lndy0, i64* %Hp_Arg, i64 %lndy1, i64 %lndy2, i64 %lndy3, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cdxv:
  %lndy5 = load i64, i64* %R1_Var
  %lndy6 = inttoptr i64 %lndy5 to i64*
  %lndy7 = load i64, i64* %lndy6, !tbaa !4
  %lndy8 = inttoptr i64 %lndy7 to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndy9 = load i64*, i64** %Sp_Var
  %lndya = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndy8( i64* %Base_Arg, i64* %lndy9, i64* %Hp_Arg, i64 %lndya, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cdxx:
  %lndyb = load i64, i64* %R1_Var
  store i64 %lndyb, i64* %R1_Var
  %lndyc = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lndyd = bitcast i64* %lndyc to i64*
  %lndye = load i64, i64* %lndyd, !tbaa !5
  %lndyf = inttoptr i64 %lndye to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndyg = load i64*, i64** %Sp_Var
  %lndyh = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndyf( i64* %Base_Arg, i64* %lndyg, i64* %Hp_Arg, i64 %lndyh, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
%raBZ_closure_struct = type <{i64, i64, i64, i64}>
@raBZ_closure$def = internal global %raBZ_closure_struct<{i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @raBZ_info$def to i64), i64 0, i64 0, i64 0}>
@raBZ_closure = internal alias i8, bitcast (%raBZ_closure_struct* @raBZ_closure$def to i8*)



==================== LLVM Code ====================
@raBZ_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @raBZ_info$def to i8*)
define internal ghccc void @raBZ_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 0, i32 21, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%raBR_closure_struct* @raBR_closure$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @raBZ_info$def to i64)) to i32),i32 0)}>
{
cdyr:
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R5_Var = alloca i64, i32 1
  store i64 undef, i64* %R5_Var
  %R6_Var = alloca i64, i32 1
  store i64 undef, i64* %R6_Var
  %F1_Var = alloca float, i32 1
  store float undef, float* %F1_Var
  %D1_Var = alloca double, i32 1
  store double undef, double* %D1_Var
  %F2_Var = alloca float, i32 1
  store float undef, float* %F2_Var
  %D2_Var = alloca double, i32 1
  store double undef, double* %D2_Var
  %F3_Var = alloca float, i32 1
  store float undef, float* %F3_Var
  %D3_Var = alloca double, i32 1
  store double undef, double* %D3_Var
  %F4_Var = alloca float, i32 1
  store float undef, float* %F4_Var
  %D4_Var = alloca double, i32 1
  store double undef, double* %D4_Var
  %F5_Var = alloca float, i32 1
  store float undef, float* %F5_Var
  %D5_Var = alloca double, i32 1
  store double undef, double* %D5_Var
  %F6_Var = alloca float, i32 1
  store float undef, float* %F6_Var
  %D6_Var = alloca double, i32 1
  store double undef, double* %D6_Var
  %lcdyl = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lndyE = load i64*, i64** %Sp_Var
  %lndyF = getelementptr inbounds i64, i64* %lndyE, i32 -3
  %lndyG = ptrtoint i64* %lndyF to i64
  %lndyH = icmp ult i64 %lndyG, %SpLim_Arg
  %lndyI = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lndyH, i1 0 )
  br i1 %lndyI, label %cdyx, label %cdyy
cdyy:
  %lndyJ = ptrtoint i64* %Base_Arg to i64
  %lndyK = inttoptr i64 %lndyJ to i8*
  %lndyL = load i64, i64* %R1_Var
  %lndyM = inttoptr i64 %lndyL to i8*
  %lndyN = bitcast i8* @newCAF to i8* (i8*, i8*)*
  store i64 undef, i64* %R3_Var
  store i64 undef, i64* %R4_Var
  store i64 undef, i64* %R5_Var
  store i64 undef, i64* %R6_Var
  store float undef, float* %F1_Var
  store double undef, double* %D1_Var
  store float undef, float* %F2_Var
  store double undef, double* %D2_Var
  store float undef, float* %F3_Var
  store double undef, double* %D3_Var
  store float undef, float* %F4_Var
  store double undef, double* %D4_Var
  store float undef, float* %F5_Var
  store double undef, double* %D5_Var
  store float undef, float* %F6_Var
  store double undef, double* %D6_Var
  %lndyO = call ccc i8* (i8*, i8*) %lndyN( i8* %lndyK, i8* %lndyM ) nounwind
  %lndyP = ptrtoint i8* %lndyO to i64
  store i64 %lndyP, i64* %lcdyl
  %lndyQ = load i64, i64* %lcdyl
  %lndyR = icmp eq i64 %lndyQ, 0
  br i1 %lndyR, label %cdyn, label %cdym
cdym:
  %lndyT = ptrtoint i8* @stg_bh_upd_frame_info to i64
  %lndyS = load i64*, i64** %Sp_Var
  %lndyU = getelementptr inbounds i64, i64* %lndyS, i32 -2
  store i64 %lndyT, i64* %lndyU, !tbaa !2
  %lndyW = load i64, i64* %lcdyl
  %lndyV = load i64*, i64** %Sp_Var
  %lndyX = getelementptr inbounds i64, i64* %lndyV, i32 -1
  store i64 %lndyW, i64* %lndyX, !tbaa !2
  %lndyZ = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdyo_info$def to i64
  %lndyY = load i64*, i64** %Sp_Var
  %lndz0 = getelementptr inbounds i64, i64* %lndyY, i32 -3
  store i64 %lndyZ, i64* %lndz0, !tbaa !2
  %lndz1 = ptrtoint %raBR_closure_struct* @raBR_closure$def to i64
  store i64 %lndz1, i64* %R1_Var
  %lndz2 = load i64*, i64** %Sp_Var
  %lndz3 = getelementptr inbounds i64, i64* %lndz2, i32 -3
  %lndz4 = ptrtoint i64* %lndz3 to i64
  %lndz5 = inttoptr i64 %lndz4 to i64*
  store i64* %lndz5, i64** %Sp_Var
  %lndz6 = load i64, i64* %R1_Var
  %lndz7 = and i64 %lndz6, 7
  %lndz8 = icmp ne i64 %lndz7, 0
  br i1 %lndz8, label %udyD, label %cdyp
cdyp:
  %lndza = load i64, i64* %R1_Var
  %lndzb = inttoptr i64 %lndza to i64*
  %lndzc = load i64, i64* %lndzb, !tbaa !4
  %lndzd = inttoptr i64 %lndzc to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndze = load i64*, i64** %Sp_Var
  %lndzf = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndzd( i64* %Base_Arg, i64* %lndze, i64* %Hp_Arg, i64 %lndzf, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
udyD:
  %lndzg = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdyo_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndzh = load i64*, i64** %Sp_Var
  %lndzi = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndzg( i64* %Base_Arg, i64* %lndzh, i64* %Hp_Arg, i64 %lndzi, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cdyn:
  %lndzk = load i64, i64* %R1_Var
  %lndzl = inttoptr i64 %lndzk to i64*
  %lndzm = load i64, i64* %lndzl, !tbaa !4
  %lndzn = inttoptr i64 %lndzm to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndzo = load i64*, i64** %Sp_Var
  %lndzp = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndzn( i64* %Base_Arg, i64* %lndzo, i64* %Hp_Arg, i64 %lndzp, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cdyx:
  %lndzq = load i64, i64* %R1_Var
  store i64 %lndzq, i64* %R1_Var
  %lndzr = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lndzs = bitcast i64* %lndzr to i64*
  %lndzt = load i64, i64* %lndzs, !tbaa !5
  %lndzu = inttoptr i64 %lndzt to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndzv = load i64*, i64** %Sp_Var
  %lndzw = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndzu( i64* %Base_Arg, i64* %lndzv, i64* %Hp_Arg, i64 %lndzw, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cdyo_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdyo_info$def to i8*)
define internal ghccc void @cdyo_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 0, i32 30, i32 0}>
{
cdyo:
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %lndzx = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdyu_info$def to i64
  %lndzy = getelementptr inbounds i64, i64* %Sp_Arg, i32 0
  store i64 %lndzx, i64* %lndzy, !tbaa !2
  %lndzz = ptrtoint i8* @ghczmprim_GHCziTypes_ZMZN_closure to i64
  %lndzA = add i64 %lndzz, 1
  store i64 %lndzA, i64* %R4_Var
  %lndzB = add i64 %R1_Arg, 23
  %lndzC = inttoptr i64 %lndzB to i64*
  %lndzD = load i64, i64* %lndzC, !tbaa !4
  store i64 %lndzD, i64* %R3_Var
  store i64 0, i64* %R2_Var
  %lndzE = bitcast i8* @base_GHCziShow_zdwshowSignedInt_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndzF = load i64, i64* %R2_Var
  %lndzG = load i64, i64* %R3_Var
  %lndzH = load i64, i64* %R4_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndzE( i64* %Base_Arg, i64* %Sp_Arg, i64* %Hp_Arg, i64 %R1_Arg, i64 %lndzF, i64 %lndzG, i64 %lndzH, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cdyu_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdyu_info$def to i8*)
define internal ghccc void @cdyu_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 0, i32 30, i32 0}>
{
cdyu:
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %R2_Var = alloca i64, i32 1
  store i64 %R2_Arg, i64* %R2_Var
  %lndzI = load i64*, i64** %Hp_Var
  %lndzJ = getelementptr inbounds i64, i64* %lndzI, i32 3
  %lndzK = ptrtoint i64* %lndzJ to i64
  %lndzL = inttoptr i64 %lndzK to i64*
  store i64* %lndzL, i64** %Hp_Var
  %lndzM = load i64*, i64** %Hp_Var
  %lndzN = ptrtoint i64* %lndzM to i64
  %lndzO = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lndzP = bitcast i64* %lndzO to i64*
  %lndzQ = load i64, i64* %lndzP, !tbaa !5
  %lndzR = icmp ugt i64 %lndzN, %lndzQ
  %lndzS = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lndzR, i1 0 )
  br i1 %lndzS, label %cdyC, label %cdyB
cdyB:
  %lndzU = ptrtoint i8* @ghczmprim_GHCziTypes_ZC_con_info to i64
  %lndzT = load i64*, i64** %Hp_Var
  %lndzV = getelementptr inbounds i64, i64* %lndzT, i32 -2
  store i64 %lndzU, i64* %lndzV, !tbaa !3
  %lndzX = load i64, i64* %R1_Var
  %lndzW = load i64*, i64** %Hp_Var
  %lndzY = getelementptr inbounds i64, i64* %lndzW, i32 -1
  store i64 %lndzX, i64* %lndzY, !tbaa !3
  %lndA0 = load i64, i64* %R2_Var
  %lndzZ = load i64*, i64** %Hp_Var
  %lndA1 = getelementptr inbounds i64, i64* %lndzZ, i32 0
  store i64 %lndA0, i64* %lndA1, !tbaa !3
  %lndA3 = load i64*, i64** %Hp_Var
  %lndA4 = ptrtoint i64* %lndA3 to i64
  %lndA5 = add i64 %lndA4, -14
  store i64 %lndA5, i64* %R1_Var
  %lndA6 = load i64*, i64** %Sp_Var
  %lndA7 = getelementptr inbounds i64, i64* %lndA6, i32 1
  %lndA8 = ptrtoint i64* %lndA7 to i64
  %lndA9 = inttoptr i64 %lndA8 to i64*
  store i64* %lndA9, i64** %Sp_Var
  %lndAa = load i64*, i64** %Sp_Var
  %lndAb = getelementptr inbounds i64, i64* %lndAa, i32 0
  %lndAc = bitcast i64* %lndAb to i64*
  %lndAd = load i64, i64* %lndAc, !tbaa !2
  %lndAe = inttoptr i64 %lndAd to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndAf = load i64*, i64** %Sp_Var
  %lndAg = load i64*, i64** %Hp_Var
  %lndAh = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndAe( i64* %Base_Arg, i64* %lndAf, i64* %lndAg, i64 %lndAh, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cdyC:
  %lndAi = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 24, i64* %lndAi, !tbaa !5
  %lndAj = load i64, i64* %R2_Var
  store i64 %lndAj, i64* %R2_Var
  %lndAk = load i64, i64* %R1_Var
  store i64 %lndAk, i64* %R1_Var
  %lndAl = bitcast i8* @stg_gc_pp to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndAm = load i64*, i64** %Sp_Var
  %lndAn = load i64*, i64** %Hp_Var
  %lndAo = load i64, i64* %R1_Var
  %lndAp = load i64, i64* %R2_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndAl( i64* %Base_Arg, i64* %lndAm, i64* %lndAn, i64 %lndAo, i64 %lndAp, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
%raC0_closure_struct = type <{i64, i64, i64, i64}>
@raC0_closure$def = internal global %raC0_closure_struct<{i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @raC0_info$def to i64), i64 0, i64 0, i64 0}>
@raC0_closure = internal alias i8, bitcast (%raC0_closure_struct* @raC0_closure$def to i8*)



==================== LLVM Code ====================
@raC0_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @raC0_info$def to i8*)
define internal ghccc void @raC0_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 0, i32 21, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%raBS_closure_struct* @raBS_closure$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @raC0_info$def to i64)) to i32),i32 0)}>
{
cdAz:
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R5_Var = alloca i64, i32 1
  store i64 undef, i64* %R5_Var
  %R6_Var = alloca i64, i32 1
  store i64 undef, i64* %R6_Var
  %F1_Var = alloca float, i32 1
  store float undef, float* %F1_Var
  %D1_Var = alloca double, i32 1
  store double undef, double* %D1_Var
  %F2_Var = alloca float, i32 1
  store float undef, float* %F2_Var
  %D2_Var = alloca double, i32 1
  store double undef, double* %D2_Var
  %F3_Var = alloca float, i32 1
  store float undef, float* %F3_Var
  %D3_Var = alloca double, i32 1
  store double undef, double* %D3_Var
  %F4_Var = alloca float, i32 1
  store float undef, float* %F4_Var
  %D4_Var = alloca double, i32 1
  store double undef, double* %D4_Var
  %F5_Var = alloca float, i32 1
  store float undef, float* %F5_Var
  %D5_Var = alloca double, i32 1
  store double undef, double* %D5_Var
  %F6_Var = alloca float, i32 1
  store float undef, float* %F6_Var
  %D6_Var = alloca double, i32 1
  store double undef, double* %D6_Var
  %lcdAt = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lndAM = load i64*, i64** %Sp_Var
  %lndAN = getelementptr inbounds i64, i64* %lndAM, i32 -3
  %lndAO = ptrtoint i64* %lndAN to i64
  %lndAP = icmp ult i64 %lndAO, %SpLim_Arg
  %lndAQ = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lndAP, i1 0 )
  br i1 %lndAQ, label %cdAF, label %cdAG
cdAG:
  %lndAR = ptrtoint i64* %Base_Arg to i64
  %lndAS = inttoptr i64 %lndAR to i8*
  %lndAT = load i64, i64* %R1_Var
  %lndAU = inttoptr i64 %lndAT to i8*
  %lndAV = bitcast i8* @newCAF to i8* (i8*, i8*)*
  store i64 undef, i64* %R3_Var
  store i64 undef, i64* %R4_Var
  store i64 undef, i64* %R5_Var
  store i64 undef, i64* %R6_Var
  store float undef, float* %F1_Var
  store double undef, double* %D1_Var
  store float undef, float* %F2_Var
  store double undef, double* %D2_Var
  store float undef, float* %F3_Var
  store double undef, double* %D3_Var
  store float undef, float* %F4_Var
  store double undef, double* %D4_Var
  store float undef, float* %F5_Var
  store double undef, double* %D5_Var
  store float undef, float* %F6_Var
  store double undef, double* %D6_Var
  %lndAW = call ccc i8* (i8*, i8*) %lndAV( i8* %lndAS, i8* %lndAU ) nounwind
  %lndAX = ptrtoint i8* %lndAW to i64
  store i64 %lndAX, i64* %lcdAt
  %lndAY = load i64, i64* %lcdAt
  %lndAZ = icmp eq i64 %lndAY, 0
  br i1 %lndAZ, label %cdAv, label %cdAu
cdAu:
  %lndB1 = ptrtoint i8* @stg_bh_upd_frame_info to i64
  %lndB0 = load i64*, i64** %Sp_Var
  %lndB2 = getelementptr inbounds i64, i64* %lndB0, i32 -2
  store i64 %lndB1, i64* %lndB2, !tbaa !2
  %lndB4 = load i64, i64* %lcdAt
  %lndB3 = load i64*, i64** %Sp_Var
  %lndB5 = getelementptr inbounds i64, i64* %lndB3, i32 -1
  store i64 %lndB4, i64* %lndB5, !tbaa !2
  %lndB7 = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdAw_info$def to i64
  %lndB6 = load i64*, i64** %Sp_Var
  %lndB8 = getelementptr inbounds i64, i64* %lndB6, i32 -3
  store i64 %lndB7, i64* %lndB8, !tbaa !2
  %lndB9 = ptrtoint %raBS_closure_struct* @raBS_closure$def to i64
  store i64 %lndB9, i64* %R1_Var
  %lndBa = load i64*, i64** %Sp_Var
  %lndBb = getelementptr inbounds i64, i64* %lndBa, i32 -3
  %lndBc = ptrtoint i64* %lndBb to i64
  %lndBd = inttoptr i64 %lndBc to i64*
  store i64* %lndBd, i64** %Sp_Var
  %lndBe = load i64, i64* %R1_Var
  %lndBf = and i64 %lndBe, 7
  %lndBg = icmp ne i64 %lndBf, 0
  br i1 %lndBg, label %udAL, label %cdAx
cdAx:
  %lndBi = load i64, i64* %R1_Var
  %lndBj = inttoptr i64 %lndBi to i64*
  %lndBk = load i64, i64* %lndBj, !tbaa !4
  %lndBl = inttoptr i64 %lndBk to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndBm = load i64*, i64** %Sp_Var
  %lndBn = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndBl( i64* %Base_Arg, i64* %lndBm, i64* %Hp_Arg, i64 %lndBn, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
udAL:
  %lndBo = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdAw_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndBp = load i64*, i64** %Sp_Var
  %lndBq = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndBo( i64* %Base_Arg, i64* %lndBp, i64* %Hp_Arg, i64 %lndBq, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cdAv:
  %lndBs = load i64, i64* %R1_Var
  %lndBt = inttoptr i64 %lndBs to i64*
  %lndBu = load i64, i64* %lndBt, !tbaa !4
  %lndBv = inttoptr i64 %lndBu to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndBw = load i64*, i64** %Sp_Var
  %lndBx = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndBv( i64* %Base_Arg, i64* %lndBw, i64* %Hp_Arg, i64 %lndBx, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cdAF:
  %lndBy = load i64, i64* %R1_Var
  store i64 %lndBy, i64* %R1_Var
  %lndBz = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lndBA = bitcast i64* %lndBz to i64*
  %lndBB = load i64, i64* %lndBA, !tbaa !5
  %lndBC = inttoptr i64 %lndBB to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndBD = load i64*, i64** %Sp_Var
  %lndBE = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndBC( i64* %Base_Arg, i64* %lndBD, i64* %Hp_Arg, i64 %lndBE, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cdAw_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdAw_info$def to i8*)
define internal ghccc void @cdAw_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 0, i32 30, i32 0}>
{
cdAw:
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %lndBF = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdAC_info$def to i64
  %lndBG = getelementptr inbounds i64, i64* %Sp_Arg, i32 0
  store i64 %lndBF, i64* %lndBG, !tbaa !2
  %lndBH = ptrtoint i8* @ghczmprim_GHCziTypes_ZMZN_closure to i64
  %lndBI = add i64 %lndBH, 1
  store i64 %lndBI, i64* %R4_Var
  %lndBJ = add i64 %R1_Arg, 23
  %lndBK = inttoptr i64 %lndBJ to i64*
  %lndBL = load i64, i64* %lndBK, !tbaa !4
  store i64 %lndBL, i64* %R3_Var
  store i64 0, i64* %R2_Var
  %lndBM = bitcast i8* @base_GHCziShow_zdwshowSignedInt_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndBN = load i64, i64* %R2_Var
  %lndBO = load i64, i64* %R3_Var
  %lndBP = load i64, i64* %R4_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndBM( i64* %Base_Arg, i64* %Sp_Arg, i64* %Hp_Arg, i64 %R1_Arg, i64 %lndBN, i64 %lndBO, i64 %lndBP, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cdAC_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdAC_info$def to i8*)
define internal ghccc void @cdAC_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 0, i32 30, i32 0}>
{
cdAC:
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %R2_Var = alloca i64, i32 1
  store i64 %R2_Arg, i64* %R2_Var
  %lndBQ = load i64*, i64** %Hp_Var
  %lndBR = getelementptr inbounds i64, i64* %lndBQ, i32 3
  %lndBS = ptrtoint i64* %lndBR to i64
  %lndBT = inttoptr i64 %lndBS to i64*
  store i64* %lndBT, i64** %Hp_Var
  %lndBU = load i64*, i64** %Hp_Var
  %lndBV = ptrtoint i64* %lndBU to i64
  %lndBW = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lndBX = bitcast i64* %lndBW to i64*
  %lndBY = load i64, i64* %lndBX, !tbaa !5
  %lndBZ = icmp ugt i64 %lndBV, %lndBY
  %lndC0 = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lndBZ, i1 0 )
  br i1 %lndC0, label %cdAK, label %cdAJ
cdAJ:
  %lndC2 = ptrtoint i8* @ghczmprim_GHCziTypes_ZC_con_info to i64
  %lndC1 = load i64*, i64** %Hp_Var
  %lndC3 = getelementptr inbounds i64, i64* %lndC1, i32 -2
  store i64 %lndC2, i64* %lndC3, !tbaa !3
  %lndC5 = load i64, i64* %R1_Var
  %lndC4 = load i64*, i64** %Hp_Var
  %lndC6 = getelementptr inbounds i64, i64* %lndC4, i32 -1
  store i64 %lndC5, i64* %lndC6, !tbaa !3
  %lndC8 = load i64, i64* %R2_Var
  %lndC7 = load i64*, i64** %Hp_Var
  %lndC9 = getelementptr inbounds i64, i64* %lndC7, i32 0
  store i64 %lndC8, i64* %lndC9, !tbaa !3
  %lndCb = load i64*, i64** %Hp_Var
  %lndCc = ptrtoint i64* %lndCb to i64
  %lndCd = add i64 %lndCc, -14
  store i64 %lndCd, i64* %R1_Var
  %lndCe = load i64*, i64** %Sp_Var
  %lndCf = getelementptr inbounds i64, i64* %lndCe, i32 1
  %lndCg = ptrtoint i64* %lndCf to i64
  %lndCh = inttoptr i64 %lndCg to i64*
  store i64* %lndCh, i64** %Sp_Var
  %lndCi = load i64*, i64** %Sp_Var
  %lndCj = getelementptr inbounds i64, i64* %lndCi, i32 0
  %lndCk = bitcast i64* %lndCj to i64*
  %lndCl = load i64, i64* %lndCk, !tbaa !2
  %lndCm = inttoptr i64 %lndCl to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndCn = load i64*, i64** %Sp_Var
  %lndCo = load i64*, i64** %Hp_Var
  %lndCp = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndCm( i64* %Base_Arg, i64* %lndCn, i64* %lndCo, i64 %lndCp, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cdAK:
  %lndCq = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 24, i64* %lndCq, !tbaa !5
  %lndCr = load i64, i64* %R2_Var
  store i64 %lndCr, i64* %R2_Var
  %lndCs = load i64, i64* %R1_Var
  store i64 %lndCs, i64* %R1_Var
  %lndCt = bitcast i8* @stg_gc_pp to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndCu = load i64*, i64** %Sp_Var
  %lndCv = load i64*, i64** %Hp_Var
  %lndCw = load i64, i64* %R1_Var
  %lndCx = load i64, i64* %R2_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndCt( i64* %Base_Arg, i64* %lndCu, i64* %lndCv, i64 %lndCw, i64 %lndCx, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
%raC1_bytes_struct = type <{[29 x i8]}>
@raC1_bytes$def = internal constant %raC1_bytes_struct<{[29 x i8] [i8 10, i8 67, i8 111, i8 110, i8 106, i8 117, i8 103, i8 97, i8 116, i8 101, i8 32, i8 71, i8 114, i8 97, i8 100, i8 105, i8 101, i8 110, i8 116, i8 32, i8 77, i8 101, i8 116, i8 104, i8 111, i8 100, i8 58, i8 32, i8 0]}>, align 1
@raC1_bytes = internal alias i8, bitcast (%raC1_bytes_struct* @raC1_bytes$def to i8*)



==================== LLVM Code ====================
%raC2_closure_struct = type <{i64, i64, i64, i64}>
@raC2_closure$def = internal global %raC2_closure_struct<{i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @raC2_info$def to i64), i64 0, i64 0, i64 0}>
@raC2_closure = internal alias i8, bitcast (%raC2_closure_struct* @raC2_closure$def to i8*)



==================== LLVM Code ====================
@raC2_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @raC2_info$def to i8*)
define internal ghccc void @raC2_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 0, i32 21, i32 0}>
{
cdCE:
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R5_Var = alloca i64, i32 1
  store i64 undef, i64* %R5_Var
  %R6_Var = alloca i64, i32 1
  store i64 undef, i64* %R6_Var
  %F1_Var = alloca float, i32 1
  store float undef, float* %F1_Var
  %D1_Var = alloca double, i32 1
  store double undef, double* %D1_Var
  %F2_Var = alloca float, i32 1
  store float undef, float* %F2_Var
  %D2_Var = alloca double, i32 1
  store double undef, double* %D2_Var
  %F3_Var = alloca float, i32 1
  store float undef, float* %F3_Var
  %D3_Var = alloca double, i32 1
  store double undef, double* %D3_Var
  %F4_Var = alloca float, i32 1
  store float undef, float* %F4_Var
  %D4_Var = alloca double, i32 1
  store double undef, double* %D4_Var
  %F5_Var = alloca float, i32 1
  store float undef, float* %F5_Var
  %D5_Var = alloca double, i32 1
  store double undef, double* %D5_Var
  %F6_Var = alloca float, i32 1
  store float undef, float* %F6_Var
  %D6_Var = alloca double, i32 1
  store double undef, double* %D6_Var
  %lcdCB = alloca i64, i32 1
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lndCH = load i64*, i64** %Sp_Var
  %lndCI = getelementptr inbounds i64, i64* %lndCH, i32 -2
  %lndCJ = ptrtoint i64* %lndCI to i64
  %lndCK = icmp ult i64 %lndCJ, %SpLim_Arg
  %lndCL = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lndCK, i1 0 )
  br i1 %lndCL, label %cdCF, label %cdCG
cdCG:
  %lndCM = ptrtoint i64* %Base_Arg to i64
  %lndCN = inttoptr i64 %lndCM to i8*
  %lndCO = load i64, i64* %R1_Var
  %lndCP = inttoptr i64 %lndCO to i8*
  %lndCQ = bitcast i8* @newCAF to i8* (i8*, i8*)*
  store i64 undef, i64* %R3_Var
  store i64 undef, i64* %R4_Var
  store i64 undef, i64* %R5_Var
  store i64 undef, i64* %R6_Var
  store float undef, float* %F1_Var
  store double undef, double* %D1_Var
  store float undef, float* %F2_Var
  store double undef, double* %D2_Var
  store float undef, float* %F3_Var
  store double undef, double* %D3_Var
  store float undef, float* %F4_Var
  store double undef, double* %D4_Var
  store float undef, float* %F5_Var
  store double undef, double* %D5_Var
  store float undef, float* %F6_Var
  store double undef, double* %D6_Var
  %lndCR = call ccc i8* (i8*, i8*) %lndCQ( i8* %lndCN, i8* %lndCP ) nounwind
  %lndCS = ptrtoint i8* %lndCR to i64
  store i64 %lndCS, i64* %lcdCB
  %lndCT = load i64, i64* %lcdCB
  %lndCU = icmp eq i64 %lndCT, 0
  br i1 %lndCU, label %cdCD, label %cdCC
cdCC:
  %lndCW = ptrtoint i8* @stg_bh_upd_frame_info to i64
  %lndCV = load i64*, i64** %Sp_Var
  %lndCX = getelementptr inbounds i64, i64* %lndCV, i32 -2
  store i64 %lndCW, i64* %lndCX, !tbaa !2
  %lndCZ = load i64, i64* %lcdCB
  %lndCY = load i64*, i64** %Sp_Var
  %lndD0 = getelementptr inbounds i64, i64* %lndCY, i32 -1
  store i64 %lndCZ, i64* %lndD0, !tbaa !2
  %lndD1 = ptrtoint %raC1_bytes_struct* @raC1_bytes$def to i64
  store i64 %lndD1, i64* %R2_Var
  %lndD2 = load i64*, i64** %Sp_Var
  %lndD3 = getelementptr inbounds i64, i64* %lndD2, i32 -2
  %lndD4 = ptrtoint i64* %lndD3 to i64
  %lndD5 = inttoptr i64 %lndD4 to i64*
  store i64* %lndD5, i64** %Sp_Var
  %lndD6 = bitcast i8* @ghczmprim_GHCziCString_unpackCStringzh_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndD7 = load i64*, i64** %Sp_Var
  %lndD8 = load i64, i64* %R1_Var
  %lndD9 = load i64, i64* %R2_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndD6( i64* %Base_Arg, i64* %lndD7, i64* %Hp_Arg, i64 %lndD8, i64 %lndD9, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cdCD:
  %lndDb = load i64, i64* %R1_Var
  %lndDc = inttoptr i64 %lndDb to i64*
  %lndDd = load i64, i64* %lndDc, !tbaa !4
  %lndDe = inttoptr i64 %lndDd to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndDf = load i64*, i64** %Sp_Var
  %lndDg = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndDe( i64* %Base_Arg, i64* %lndDf, i64* %Hp_Arg, i64 %lndDg, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cdCF:
  %lndDh = load i64, i64* %R1_Var
  store i64 %lndDh, i64* %R1_Var
  %lndDi = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lndDj = bitcast i64* %lndDi to i64*
  %lndDk = load i64, i64* %lndDj, !tbaa !5
  %lndDl = inttoptr i64 %lndDk to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndDm = load i64*, i64** %Sp_Var
  %lndDn = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndDl( i64* %Base_Arg, i64* %lndDm, i64* %Hp_Arg, i64 %lndDn, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
%udGm_srt_struct = type <{i64, i64, i64, i64, i64}>
%udGn_srt_struct = type <{i64, i64, i64}>
%udGo_srt_struct = type <{i64, i64, i64, i64}>
%udGp_srt_struct = type <{i64, i64, i64, i64}>
%udGq_srt_struct = type <{i64, i64, i64, i64}>
%udGr_srt_struct = type <{i64, i64, i64, i64}>
%udGs_srt_struct = type <{i64, i64, i64, i64}>
%udGt_srt_struct = type <{i64, i64, i64}>
%udGu_srt_struct = type <{i64, i64, i64, i64}>
%udGv_srt_struct = type <{i64, i64, i64}>
%udGw_srt_struct = type <{i64, i64, i64}>
%udGx_srt_struct = type <{i64, i64, i64}>
%udGy_srt_struct = type <{i64, i64, i64}>
%udGz_srt_struct = type <{i64, i64, i64}>
%udGA_srt_struct = type <{i64, i64, i64}>
%udGB_srt_struct = type <{i64, i64, i64}>
%udGC_srt_struct = type <{i64, i64, i64}>
%udGD_srt_struct = type <{i64, i64, i64}>
%udGE_srt_struct = type <{i64, i64, i64}>
%udGF_srt_struct = type <{i64, i64, i64}>
%udGG_srt_struct = type <{i64, i64, i64}>
%udGH_srt_struct = type <{i64, i64, i64}>
%udGI_srt_struct = type <{i64, i64, i64, i64}>
%udGJ_srt_struct = type <{i64, i64, i64, i64}>
%udGK_srt_struct = type <{i64, i64, i64, i64, i64, i64}>
%udGL_srt_struct = type <{i64, i64, i64, i64}>
%udGM_srt_struct = type <{i64, i64, i64}>
%udGN_srt_struct = type <{i64, i64, i64, i64}>
%udGO_srt_struct = type <{i64, i64, i64, i64}>
%Main_main1_closure_struct = type <{i64, i64, i64, i64}>
@udGm_srt$def = internal global %udGm_srt_struct<{i64 ptrtoint (i8* @stg_SRT_3_info to i64), i64 ptrtoint (i8* @base_GHCziIOziHandleziFD_stdout_closure to i64), i64 ptrtoint (i8* @base_GHCziIOziHandleziText_hPutStrzq_closure to i64), i64 ptrtoint (%raBT_closure_struct* @raBT_closure$def to i64), i64 0}>
@udGm_srt = internal alias i8, bitcast (%udGm_srt_struct* @udGm_srt$def to i8*)
@udGn_srt$def = internal global %udGn_srt_struct<{i64 ptrtoint (i8* @stg_SRT_1_info to i64), i64 ptrtoint (i8* @timezm1zi8zi0zi2_DataziTimeziClockziInternalziNominalDiffTime_zdfShowNominalDiffTime3_closure to i64), i64 0}>
@udGn_srt = internal alias i8, bitcast (%udGn_srt_struct* @udGn_srt$def to i8*)
@udGo_srt$def = internal global %udGo_srt_struct<{i64 ptrtoint (i8* @stg_SRT_2_info to i64), i64 ptrtoint (i8* @base_DataziFixed_showFixed_closure to i64), i64 ptrtoint (i8* @udGn_srt to i64), i64 0}>
@udGo_srt = internal alias i8, bitcast (%udGo_srt_struct* @udGo_srt$def to i8*)
@udGp_srt$def = internal global %udGp_srt_struct<{i64 ptrtoint (i8* @stg_SRT_2_info to i64), i64 ptrtoint (i8* @integerzmgmp_GHCziIntegerziType_divInteger_closure to i64), i64 ptrtoint (i8* @udGo_srt to i64), i64 0}>
@udGp_srt = internal alias i8, bitcast (%udGp_srt_struct* @udGp_srt$def to i8*)
@udGq_srt$def = internal global %udGq_srt_struct<{i64 ptrtoint (i8* @stg_SRT_2_info to i64), i64 ptrtoint (i8* @integerzmgmp_GHCziIntegerziType_timesInteger_closure to i64), i64 ptrtoint (i8* @udGp_srt to i64), i64 0}>
@udGq_srt = internal alias i8, bitcast (%udGq_srt_struct* @udGq_srt$def to i8*)
@udGr_srt$def = internal global %udGr_srt_struct<{i64 ptrtoint (i8* @stg_SRT_2_info to i64), i64 ptrtoint (i8* @integerzmgmp_GHCziIntegerziType_minusInteger_closure to i64), i64 ptrtoint (i8* @udGq_srt to i64), i64 0}>
@udGr_srt = internal alias i8, bitcast (%udGr_srt_struct* @udGr_srt$def to i8*)
@udGs_srt$def = internal global %udGs_srt_struct<{i64 ptrtoint (i8* @stg_SRT_2_info to i64), i64 ptrtoint (i8* @timezm1zi8zi0zi2_DataziTimeziClockziPOSIX_zdwutcTimeToPOSIXSeconds_closure to i64), i64 ptrtoint (i8* @udGr_srt to i64), i64 0}>
@udGs_srt = internal alias i8, bitcast (%udGs_srt_struct* @udGs_srt$def to i8*)
@udGt_srt$def = internal global %udGt_srt_struct<{i64 ptrtoint (i8* @stg_SRT_1_info to i64), i64 ptrtoint (i8* @udGs_srt to i64), i64 0}>
@udGt_srt = internal alias i8, bitcast (%udGt_srt_struct* @udGt_srt$def to i8*)
@udGu_srt$def = internal global %udGu_srt_struct<{i64 ptrtoint (i8* @stg_SRT_2_info to i64), i64 ptrtoint (i8* @timezm1zi8zi0zi2_DataziTimeziClockziSystem_zdwsystemToUTCTime_closure to i64), i64 ptrtoint (i8* @udGt_srt to i64), i64 0}>
@udGu_srt = internal alias i8, bitcast (%udGu_srt_struct* @udGu_srt$def to i8*)
@udGv_srt$def = internal global %udGv_srt_struct<{i64 ptrtoint (i8* @stg_SRT_1_info to i64), i64 ptrtoint (i8* @udGu_srt to i64), i64 0}>
@udGv_srt = internal alias i8, bitcast (%udGv_srt_struct* @udGv_srt$def to i8*)
@udGw_srt$def = internal global %udGw_srt_struct<{i64 ptrtoint (i8* @stg_SRT_1_info to i64), i64 ptrtoint (i8* @udGv_srt to i64), i64 0}>
@udGw_srt = internal alias i8, bitcast (%udGw_srt_struct* @udGw_srt$def to i8*)
@udGx_srt$def = internal global %udGx_srt_struct<{i64 ptrtoint (i8* @stg_SRT_1_info to i64), i64 ptrtoint (i8* @udGw_srt to i64), i64 0}>
@udGx_srt = internal alias i8, bitcast (%udGx_srt_struct* @udGx_srt$def to i8*)
@udGy_srt$def = internal global %udGy_srt_struct<{i64 ptrtoint (i8* @stg_SRT_1_info to i64), i64 ptrtoint (i8* @udGx_srt to i64), i64 0}>
@udGy_srt = internal alias i8, bitcast (%udGy_srt_struct* @udGy_srt$def to i8*)
@udGz_srt$def = internal global %udGz_srt_struct<{i64 ptrtoint (i8* @stg_SRT_1_info to i64), i64 ptrtoint (i8* @udGy_srt to i64), i64 0}>
@udGz_srt = internal alias i8, bitcast (%udGz_srt_struct* @udGz_srt$def to i8*)
@udGA_srt$def = internal global %udGA_srt_struct<{i64 ptrtoint (i8* @stg_SRT_1_info to i64), i64 ptrtoint (i8* @udGz_srt to i64), i64 0}>
@udGA_srt = internal alias i8, bitcast (%udGA_srt_struct* @udGA_srt$def to i8*)
@udGB_srt$def = internal global %udGB_srt_struct<{i64 ptrtoint (i8* @stg_SRT_1_info to i64), i64 ptrtoint (i8* @udGA_srt to i64), i64 0}>
@udGB_srt = internal alias i8, bitcast (%udGB_srt_struct* @udGB_srt$def to i8*)
@udGC_srt$def = internal global %udGC_srt_struct<{i64 ptrtoint (i8* @stg_SRT_1_info to i64), i64 ptrtoint (i8* @udGB_srt to i64), i64 0}>
@udGC_srt = internal alias i8, bitcast (%udGC_srt_struct* @udGC_srt$def to i8*)
@udGD_srt$def = internal global %udGD_srt_struct<{i64 ptrtoint (i8* @stg_SRT_1_info to i64), i64 ptrtoint (i8* @udGC_srt to i64), i64 0}>
@udGD_srt = internal alias i8, bitcast (%udGD_srt_struct* @udGD_srt$def to i8*)
@udGE_srt$def = internal global %udGE_srt_struct<{i64 ptrtoint (i8* @stg_SRT_1_info to i64), i64 ptrtoint (i8* @udGD_srt to i64), i64 0}>
@udGE_srt = internal alias i8, bitcast (%udGE_srt_struct* @udGE_srt$def to i8*)
@udGF_srt$def = internal global %udGF_srt_struct<{i64 ptrtoint (i8* @stg_SRT_1_info to i64), i64 ptrtoint (i8* @udGE_srt to i64), i64 0}>
@udGF_srt = internal alias i8, bitcast (%udGF_srt_struct* @udGF_srt$def to i8*)
@udGG_srt$def = internal global %udGG_srt_struct<{i64 ptrtoint (i8* @stg_SRT_1_info to i64), i64 ptrtoint (i8* @udGF_srt to i64), i64 0}>
@udGG_srt = internal alias i8, bitcast (%udGG_srt_struct* @udGG_srt$def to i8*)
@udGH_srt$def = internal global %udGH_srt_struct<{i64 ptrtoint (i8* @stg_SRT_1_info to i64), i64 ptrtoint (i8* @udGG_srt to i64), i64 0}>
@udGH_srt = internal alias i8, bitcast (%udGH_srt_struct* @udGH_srt$def to i8*)
@udGI_srt$def = internal global %udGI_srt_struct<{i64 ptrtoint (i8* @stg_SRT_2_info to i64), i64 ptrtoint (i8* @udGm_srt to i64), i64 ptrtoint (i8* @udGH_srt to i64), i64 0}>
@udGI_srt = internal alias i8, bitcast (%udGI_srt_struct* @udGI_srt$def to i8*)
@udGJ_srt$def = internal global %udGJ_srt_struct<{i64 ptrtoint (i8* @stg_SRT_2_info to i64), i64 ptrtoint (i8* @timezm1zi8zi0zi2_DataziTimeziClockziInternalziCTimespec_zdwclockGetTime_closure to i64), i64 ptrtoint (i8* @udGI_srt to i64), i64 0}>
@udGJ_srt = internal alias i8, bitcast (%udGJ_srt_struct* @udGJ_srt$def to i8*)
@udGK_srt$def = internal global %udGK_srt_struct<{i64 ptrtoint (i8* @stg_SRT_4_info to i64), i64 ptrtoint (%Main_zdwzdsconjugateGradient_closure_struct* @Main_zdwzdsconjugateGradient_closure$def to i64), i64 ptrtoint (%raBR_closure_struct* @raBR_closure$def to i64), i64 ptrtoint (%raBY_closure_struct* @raBY_closure$def to i64), i64 ptrtoint (i8* @udGJ_srt to i64), i64 0}>
@udGK_srt = internal alias i8, bitcast (%udGK_srt_struct* @udGK_srt$def to i8*)
@udGL_srt$def = internal global %udGL_srt_struct<{i64 ptrtoint (i8* @stg_SRT_2_info to i64), i64 ptrtoint (%raBS_closure_struct* @raBS_closure$def to i64), i64 ptrtoint (i8* @udGK_srt to i64), i64 0}>
@udGL_srt = internal alias i8, bitcast (%udGL_srt_struct* @udGL_srt$def to i8*)
@udGM_srt$def = internal global %udGM_srt_struct<{i64 ptrtoint (i8* @stg_SRT_1_info to i64), i64 ptrtoint (i8* @udGL_srt to i64), i64 0}>
@udGM_srt = internal alias i8, bitcast (%udGM_srt_struct* @udGM_srt$def to i8*)
@udGN_srt$def = internal global %udGN_srt_struct<{i64 ptrtoint (i8* @stg_SRT_2_info to i64), i64 ptrtoint (%raBZ_closure_struct* @raBZ_closure$def to i64), i64 ptrtoint (i8* @udGM_srt to i64), i64 0}>
@udGN_srt = internal alias i8, bitcast (%udGN_srt_struct* @udGN_srt$def to i8*)
@udGO_srt$def = internal global %udGO_srt_struct<{i64 ptrtoint (i8* @stg_SRT_2_info to i64), i64 ptrtoint (%raC0_closure_struct* @raC0_closure$def to i64), i64 ptrtoint (i8* @udGN_srt to i64), i64 0}>
@udGO_srt = internal alias i8, bitcast (%udGO_srt_struct* @udGO_srt$def to i8*)
@Main_main1_closure$def = internal global %Main_main1_closure_struct<{i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_main1_info$def to i64), i64 ptrtoint (%raC2_closure_struct* @raC2_closure$def to i64), i64 ptrtoint (i8* @udGO_srt to i64), i64 0}>
@Main_main1_closure = alias i8, bitcast (%Main_main1_closure_struct* @Main_main1_closure$def to i8*)



==================== LLVM Code ====================
@saMt_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saMt_info$def to i8*)
define internal ghccc void @saMt_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 2, i32 18, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%udGB_srt_struct* @udGB_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saMt_info$def to i64)) to i32),i32 0)}>
{
cdEe:
  %lsaLK = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lndGP = load i64*, i64** %Sp_Var
  %lndGQ = getelementptr inbounds i64, i64* %lndGP, i32 -6
  %lndGR = ptrtoint i64* %lndGQ to i64
  %lndGS = icmp ult i64 %lndGR, %SpLim_Arg
  %lndGT = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lndGS, i1 0 )
  br i1 %lndGT, label %cdFh, label %cdFi
cdFi:
  %lndGV = ptrtoint i8* @stg_upd_frame_info to i64
  %lndGU = load i64*, i64** %Sp_Var
  %lndGW = getelementptr inbounds i64, i64* %lndGU, i32 -2
  store i64 %lndGV, i64* %lndGW, !tbaa !2
  %lndGY = load i64, i64* %R1_Var
  %lndGX = load i64*, i64** %Sp_Var
  %lndGZ = getelementptr inbounds i64, i64* %lndGX, i32 -1
  store i64 %lndGY, i64* %lndGZ, !tbaa !2
  %lndH1 = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdEb_info$def to i64
  %lndH0 = load i64*, i64** %Sp_Var
  %lndH2 = getelementptr inbounds i64, i64* %lndH0, i32 -4
  store i64 %lndH1, i64* %lndH2, !tbaa !2
  %lndH5 = load i64, i64* %R1_Var
  %lndH6 = add i64 %lndH5, 16
  %lndH7 = inttoptr i64 %lndH6 to i64*
  %lndH8 = load i64, i64* %lndH7, !tbaa !4
  store i64 %lndH8, i64* %lsaLK
  %lndHb = load i64, i64* %R1_Var
  %lndHc = add i64 %lndHb, 24
  %lndHd = inttoptr i64 %lndHc to i64*
  %lndHe = load i64, i64* %lndHd, !tbaa !4
  store i64 %lndHe, i64* %R1_Var
  %lndHg = load i64, i64* %lsaLK
  %lndHf = load i64*, i64** %Sp_Var
  %lndHh = getelementptr inbounds i64, i64* %lndHf, i32 -3
  store i64 %lndHg, i64* %lndHh, !tbaa !2
  %lndHi = load i64*, i64** %Sp_Var
  %lndHj = getelementptr inbounds i64, i64* %lndHi, i32 -4
  %lndHk = ptrtoint i64* %lndHj to i64
  %lndHl = inttoptr i64 %lndHk to i64*
  store i64* %lndHl, i64** %Sp_Var
  %lndHm = load i64, i64* %R1_Var
  %lndHn = and i64 %lndHm, 7
  %lndHo = icmp ne i64 %lndHn, 0
  br i1 %lndHo, label %udFB, label %cdEc
cdEc:
  %lndHq = load i64, i64* %R1_Var
  %lndHr = inttoptr i64 %lndHq to i64*
  %lndHs = load i64, i64* %lndHr, !tbaa !4
  %lndHt = inttoptr i64 %lndHs to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndHu = load i64*, i64** %Sp_Var
  %lndHv = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndHt( i64* %Base_Arg, i64* %lndHu, i64* %Hp_Arg, i64 %lndHv, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
udFB:
  %lndHw = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdEb_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndHx = load i64*, i64** %Sp_Var
  %lndHy = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndHw( i64* %Base_Arg, i64* %lndHx, i64* %Hp_Arg, i64 %lndHy, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cdFh:
  %lndHz = load i64, i64* %R1_Var
  store i64 %lndHz, i64* %R1_Var
  %lndHA = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lndHB = bitcast i64* %lndHA to i64*
  %lndHC = load i64, i64* %lndHB, !tbaa !5
  %lndHD = inttoptr i64 %lndHC to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndHE = load i64*, i64** %Sp_Var
  %lndHF = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndHD( i64* %Base_Arg, i64* %lndHE, i64* %Hp_Arg, i64 %lndHF, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cdEb_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdEb_info$def to i8*)
define internal ghccc void @cdEb_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 1, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%udGA_srt_struct* @udGA_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdEb_info$def to i64)) to i32),i32 0)}>
{
cdEb:
  %lsaM1 = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lndHH = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdEh_info$def to i64
  %lndHG = load i64*, i64** %Sp_Var
  %lndHI = getelementptr inbounds i64, i64* %lndHG, i32 -1
  store i64 %lndHH, i64* %lndHI, !tbaa !2
  %lndHL = load i64, i64* %R1_Var
  %lndHM = add i64 %lndHL, 15
  %lndHN = inttoptr i64 %lndHM to i64*
  %lndHO = load i64, i64* %lndHN, !tbaa !4
  store i64 %lndHO, i64* %lsaM1
  %lndHR = load i64, i64* %R1_Var
  %lndHS = add i64 %lndHR, 7
  %lndHT = inttoptr i64 %lndHS to i64*
  %lndHU = load i64, i64* %lndHT, !tbaa !4
  store i64 %lndHU, i64* %R1_Var
  %lndHW = load i64, i64* %lsaM1
  %lndHV = load i64*, i64** %Sp_Var
  %lndHX = getelementptr inbounds i64, i64* %lndHV, i32 0
  store i64 %lndHW, i64* %lndHX, !tbaa !2
  %lndHY = load i64*, i64** %Sp_Var
  %lndHZ = getelementptr inbounds i64, i64* %lndHY, i32 -1
  %lndI0 = ptrtoint i64* %lndHZ to i64
  %lndI1 = inttoptr i64 %lndI0 to i64*
  store i64* %lndI1, i64** %Sp_Var
  %lndI2 = load i64, i64* %R1_Var
  %lndI3 = and i64 %lndI2, 7
  %lndI4 = icmp ne i64 %lndI3, 0
  br i1 %lndI4, label %udFA, label %cdEi
cdEi:
  %lndI6 = load i64, i64* %R1_Var
  %lndI7 = inttoptr i64 %lndI6 to i64*
  %lndI8 = load i64, i64* %lndI7, !tbaa !4
  %lndI9 = inttoptr i64 %lndI8 to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndIa = load i64*, i64** %Sp_Var
  %lndIb = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndI9( i64* %Base_Arg, i64* %lndIa, i64* %Hp_Arg, i64 %lndIb, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
udFA:
  %lndIc = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdEh_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndId = load i64*, i64** %Sp_Var
  %lndIe = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndIc( i64* %Base_Arg, i64* %lndId, i64* %Hp_Arg, i64 %lndIe, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cdEh_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdEh_info$def to i8*)
define internal ghccc void @cdEh_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 2, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%udGz_srt_struct* @udGz_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdEh_info$def to i64)) to i32),i32 0)}>
{
cdEh:
  %lsaM3 = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lndIf = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdEm_info$def to i64
  %lndIg = getelementptr inbounds i64, i64* %Sp_Arg, i32 0
  store i64 %lndIf, i64* %lndIg, !tbaa !2
  %lndIj = load i64, i64* %R1_Var
  %lndIk = add i64 %lndIj, 7
  %lndIl = inttoptr i64 %lndIk to i64*
  %lndIm = load i64, i64* %lndIl, !tbaa !4
  store i64 %lndIm, i64* %lsaM3
  %lndIn = getelementptr inbounds i64, i64* %Sp_Arg, i32 1
  %lndIo = bitcast i64* %lndIn to i64*
  %lndIp = load i64, i64* %lndIo, !tbaa !2
  store i64 %lndIp, i64* %R1_Var
  %lndIq = load i64, i64* %lsaM3
  %lndIr = getelementptr inbounds i64, i64* %Sp_Arg, i32 1
  store i64 %lndIq, i64* %lndIr, !tbaa !2
  %lndIs = load i64, i64* %R1_Var
  %lndIt = and i64 %lndIs, 7
  %lndIu = icmp ne i64 %lndIt, 0
  br i1 %lndIu, label %udFC, label %cdEn
cdEn:
  %lndIw = load i64, i64* %R1_Var
  %lndIx = inttoptr i64 %lndIw to i64*
  %lndIy = load i64, i64* %lndIx, !tbaa !4
  %lndIz = inttoptr i64 %lndIy to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndIA = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndIz( i64* %Base_Arg, i64* %Sp_Arg, i64* %Hp_Arg, i64 %lndIA, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
udFC:
  %lndIB = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdEm_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndIC = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndIB( i64* %Base_Arg, i64* %Sp_Arg, i64* %Hp_Arg, i64 %lndIC, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cdEm_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdEm_info$def to i8*)
define internal ghccc void @cdEm_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 66, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%udGy_srt_struct* @udGy_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdEm_info$def to i64)) to i32),i32 0)}>
{
cdEm:
  %lsaM3 = alloca i64, i32 1
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lndID = load i64*, i64** %Sp_Var
  %lndIE = getelementptr inbounds i64, i64* %lndID, i32 1
  %lndIF = bitcast i64* %lndIE to i64*
  %lndIG = load i64, i64* %lndIF, !tbaa !2
  store i64 %lndIG, i64* %lsaM3
  %lndII = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdEx_info$def to i64
  %lndIH = load i64*, i64** %Sp_Var
  %lndIJ = getelementptr inbounds i64, i64* %lndIH, i32 1
  store i64 %lndII, i64* %lndIJ, !tbaa !2
  %lndIK = add i64 %R1_Arg, 7
  %lndIL = inttoptr i64 %lndIK to i64*
  %lndIM = load i64, i64* %lndIL, !tbaa !4
  %lndIN = trunc i64 %lndIM to i32
  %lndIO = zext i32 %lndIN to i64
  store i64 %lndIO, i64* %R3_Var
  %lndIP = load i64, i64* %lsaM3
  store i64 %lndIP, i64* %R2_Var
  %lndIQ = load i64*, i64** %Sp_Var
  %lndIR = getelementptr inbounds i64, i64* %lndIQ, i32 1
  %lndIS = ptrtoint i64* %lndIR to i64
  %lndIT = inttoptr i64 %lndIS to i64*
  store i64* %lndIT, i64** %Sp_Var
  %lndIU = bitcast i8* @timezm1zi8zi0zi2_DataziTimeziClockziSystem_zdwsystemToUTCTime_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndIV = load i64*, i64** %Sp_Var
  %lndIW = load i64, i64* %R2_Var
  %lndIX = load i64, i64* %R3_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndIU( i64* %Base_Arg, i64* %lndIV, i64* %Hp_Arg, i64 %R1_Arg, i64 %lndIW, i64 %lndIX, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cdEx_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdEx_info$def to i8*)
define internal ghccc void @cdEx_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 1, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%udGx_srt_struct* @udGx_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdEx_info$def to i64)) to i32),i32 0)}>
{
cdEx:
  %lsaM9 = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lndIZ = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdEz_info$def to i64
  %lndIY = load i64*, i64** %Sp_Var
  %lndJ0 = getelementptr inbounds i64, i64* %lndIY, i32 -1
  store i64 %lndIZ, i64* %lndJ0, !tbaa !2
  %lndJ1 = load i64, i64* %R1_Var
  store i64 %lndJ1, i64* %lsaM9
  %lndJ2 = load i64*, i64** %Sp_Var
  %lndJ3 = getelementptr inbounds i64, i64* %lndJ2, i32 1
  %lndJ4 = bitcast i64* %lndJ3 to i64*
  %lndJ5 = load i64, i64* %lndJ4, !tbaa !2
  store i64 %lndJ5, i64* %R1_Var
  %lndJ6 = load i64*, i64** %Sp_Var
  %lndJ7 = getelementptr inbounds i64, i64* %lndJ6, i32 0
  store i64 %R2_Arg, i64* %lndJ7, !tbaa !2
  %lndJ9 = load i64, i64* %lsaM9
  %lndJ8 = load i64*, i64** %Sp_Var
  %lndJa = getelementptr inbounds i64, i64* %lndJ8, i32 1
  store i64 %lndJ9, i64* %lndJa, !tbaa !2
  %lndJb = load i64*, i64** %Sp_Var
  %lndJc = getelementptr inbounds i64, i64* %lndJb, i32 -1
  %lndJd = ptrtoint i64* %lndJc to i64
  %lndJe = inttoptr i64 %lndJd to i64*
  store i64* %lndJe, i64** %Sp_Var
  %lndJf = load i64, i64* %R1_Var
  %lndJg = and i64 %lndJf, 7
  %lndJh = icmp ne i64 %lndJg, 0
  br i1 %lndJh, label %udFD, label %cdEA
cdEA:
  %lndJj = load i64, i64* %R1_Var
  %lndJk = inttoptr i64 %lndJj to i64*
  %lndJl = load i64, i64* %lndJk, !tbaa !4
  %lndJm = inttoptr i64 %lndJl to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndJn = load i64*, i64** %Sp_Var
  %lndJo = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndJm( i64* %Base_Arg, i64* %lndJn, i64* %Hp_Arg, i64 %lndJo, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
udFD:
  %lndJp = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdEz_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndJq = load i64*, i64** %Sp_Var
  %lndJr = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndJp( i64* %Base_Arg, i64* %lndJq, i64* %Hp_Arg, i64 %lndJr, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cdEz_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdEz_info$def to i8*)
define internal ghccc void @cdEz_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 2, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%udGw_srt_struct* @udGw_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdEz_info$def to i64)) to i32),i32 0)}>
{
cdEz:
  %lsaMd = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lndJt = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdEE_info$def to i64
  %lndJs = load i64*, i64** %Sp_Var
  %lndJu = getelementptr inbounds i64, i64* %lndJs, i32 -1
  store i64 %lndJt, i64* %lndJu, !tbaa !2
  %lndJx = load i64, i64* %R1_Var
  %lndJy = add i64 %lndJx, 15
  %lndJz = inttoptr i64 %lndJy to i64*
  %lndJA = load i64, i64* %lndJz, !tbaa !4
  store i64 %lndJA, i64* %lsaMd
  %lndJD = load i64, i64* %R1_Var
  %lndJE = add i64 %lndJD, 7
  %lndJF = inttoptr i64 %lndJE to i64*
  %lndJG = load i64, i64* %lndJF, !tbaa !4
  store i64 %lndJG, i64* %R1_Var
  %lndJI = load i64, i64* %lsaMd
  %lndJH = load i64*, i64** %Sp_Var
  %lndJJ = getelementptr inbounds i64, i64* %lndJH, i32 0
  store i64 %lndJI, i64* %lndJJ, !tbaa !2
  %lndJK = load i64*, i64** %Sp_Var
  %lndJL = getelementptr inbounds i64, i64* %lndJK, i32 -1
  %lndJM = ptrtoint i64* %lndJL to i64
  %lndJN = inttoptr i64 %lndJM to i64*
  store i64* %lndJN, i64** %Sp_Var
  %lndJO = load i64, i64* %R1_Var
  %lndJP = and i64 %lndJO, 7
  %lndJQ = icmp ne i64 %lndJP, 0
  br i1 %lndJQ, label %udFE, label %cdEF
cdEF:
  %lndJS = load i64, i64* %R1_Var
  %lndJT = inttoptr i64 %lndJS to i64*
  %lndJU = load i64, i64* %lndJT, !tbaa !4
  %lndJV = inttoptr i64 %lndJU to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndJW = load i64*, i64** %Sp_Var
  %lndJX = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndJV( i64* %Base_Arg, i64* %lndJW, i64* %Hp_Arg, i64 %lndJX, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
udFE:
  %lndJY = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdEE_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndJZ = load i64*, i64** %Sp_Var
  %lndK0 = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndJY( i64* %Base_Arg, i64* %lndJZ, i64* %Hp_Arg, i64 %lndK0, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cdEE_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdEE_info$def to i8*)
define internal ghccc void @cdEE_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 3, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%udGv_srt_struct* @udGv_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdEE_info$def to i64)) to i32),i32 0)}>
{
cdEE:
  %lsaMf = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lndK1 = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdEJ_info$def to i64
  %lndK2 = getelementptr inbounds i64, i64* %Sp_Arg, i32 0
  store i64 %lndK1, i64* %lndK2, !tbaa !2
  %lndK5 = load i64, i64* %R1_Var
  %lndK6 = add i64 %lndK5, 7
  %lndK7 = inttoptr i64 %lndK6 to i64*
  %lndK8 = load i64, i64* %lndK7, !tbaa !4
  store i64 %lndK8, i64* %lsaMf
  %lndK9 = getelementptr inbounds i64, i64* %Sp_Arg, i32 1
  %lndKa = bitcast i64* %lndK9 to i64*
  %lndKb = load i64, i64* %lndKa, !tbaa !2
  store i64 %lndKb, i64* %R1_Var
  %lndKc = load i64, i64* %lsaMf
  %lndKd = getelementptr inbounds i64, i64* %Sp_Arg, i32 1
  store i64 %lndKc, i64* %lndKd, !tbaa !2
  %lndKe = load i64, i64* %R1_Var
  %lndKf = and i64 %lndKe, 7
  %lndKg = icmp ne i64 %lndKf, 0
  br i1 %lndKg, label %udFF, label %cdEK
cdEK:
  %lndKi = load i64, i64* %R1_Var
  %lndKj = inttoptr i64 %lndKi to i64*
  %lndKk = load i64, i64* %lndKj, !tbaa !4
  %lndKl = inttoptr i64 %lndKk to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndKm = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndKl( i64* %Base_Arg, i64* %Sp_Arg, i64* %Hp_Arg, i64 %lndKm, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
udFF:
  %lndKn = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdEJ_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndKo = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndKn( i64* %Base_Arg, i64* %Sp_Arg, i64* %Hp_Arg, i64 %lndKo, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cdEJ_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdEJ_info$def to i8*)
define internal ghccc void @cdEJ_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 67, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%udGu_srt_struct* @udGu_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdEJ_info$def to i64)) to i32),i32 0)}>
{
cdEJ:
  %lsaMf = alloca i64, i32 1
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lndKp = load i64*, i64** %Sp_Var
  %lndKq = getelementptr inbounds i64, i64* %lndKp, i32 1
  %lndKr = bitcast i64* %lndKq to i64*
  %lndKs = load i64, i64* %lndKr, !tbaa !2
  store i64 %lndKs, i64* %lsaMf
  %lndKu = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdEU_info$def to i64
  %lndKt = load i64*, i64** %Sp_Var
  %lndKv = getelementptr inbounds i64, i64* %lndKt, i32 1
  store i64 %lndKu, i64* %lndKv, !tbaa !2
  %lndKw = add i64 %R1_Arg, 7
  %lndKx = inttoptr i64 %lndKw to i64*
  %lndKy = load i64, i64* %lndKx, !tbaa !4
  %lndKz = trunc i64 %lndKy to i32
  %lndKA = zext i32 %lndKz to i64
  store i64 %lndKA, i64* %R3_Var
  %lndKB = load i64, i64* %lsaMf
  store i64 %lndKB, i64* %R2_Var
  %lndKC = load i64*, i64** %Sp_Var
  %lndKD = getelementptr inbounds i64, i64* %lndKC, i32 1
  %lndKE = ptrtoint i64* %lndKD to i64
  %lndKF = inttoptr i64 %lndKE to i64*
  store i64* %lndKF, i64** %Sp_Var
  %lndKG = bitcast i8* @timezm1zi8zi0zi2_DataziTimeziClockziSystem_zdwsystemToUTCTime_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndKH = load i64*, i64** %Sp_Var
  %lndKI = load i64, i64* %R2_Var
  %lndKJ = load i64, i64* %R3_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndKG( i64* %Base_Arg, i64* %lndKH, i64* %Hp_Arg, i64 %R1_Arg, i64 %lndKI, i64 %lndKJ, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cdEU_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdEU_info$def to i8*)
define internal ghccc void @cdEU_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 2, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%udGt_srt_struct* @udGt_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdEU_info$def to i64)) to i32),i32 0)}>
{
cdEU:
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 %R2_Arg, i64* %R2_Var
  %lndKK = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdEW_info$def to i64
  %lndKL = getelementptr inbounds i64, i64* %Sp_Arg, i32 0
  store i64 %lndKK, i64* %lndKL, !tbaa !2
  %lndKM = load i64, i64* %R2_Var
  store i64 %lndKM, i64* %R3_Var
  store i64 %R1_Arg, i64* %R2_Var
  %lndKN = bitcast i8* @timezm1zi8zi0zi2_DataziTimeziClockziPOSIX_zdwutcTimeToPOSIXSeconds_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndKO = load i64, i64* %R2_Var
  %lndKP = load i64, i64* %R3_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndKN( i64* %Base_Arg, i64* %Sp_Arg, i64* %Hp_Arg, i64 %R1_Arg, i64 %lndKO, i64 %lndKP, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cdEW_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdEW_info$def to i8*)
define internal ghccc void @cdEW_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 2, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%udGs_srt_struct* @udGs_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdEW_info$def to i64)) to i32),i32 0)}>
{
cdEW:
  %lsaMa = alloca i64, i32 1
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lndKQ = load i64*, i64** %Sp_Var
  %lndKR = getelementptr inbounds i64, i64* %lndKQ, i32 1
  %lndKS = bitcast i64* %lndKR to i64*
  %lndKT = load i64, i64* %lndKS, !tbaa !2
  store i64 %lndKT, i64* %lsaMa
  %lndKV = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdF0_info$def to i64
  %lndKU = load i64*, i64** %Sp_Var
  %lndKW = getelementptr inbounds i64, i64* %lndKU, i32 1
  store i64 %lndKV, i64* %lndKW, !tbaa !2
  %lndKX = load i64, i64* %lsaMa
  store i64 %lndKX, i64* %R3_Var
  %lndKY = load i64*, i64** %Sp_Var
  %lndKZ = getelementptr inbounds i64, i64* %lndKY, i32 2
  %lndL0 = bitcast i64* %lndKZ to i64*
  %lndL1 = load i64, i64* %lndL0, !tbaa !2
  store i64 %lndL1, i64* %R2_Var
  %lndL2 = load i64*, i64** %Sp_Var
  %lndL3 = getelementptr inbounds i64, i64* %lndL2, i32 2
  store i64 %R1_Arg, i64* %lndL3, !tbaa !2
  %lndL4 = load i64*, i64** %Sp_Var
  %lndL5 = getelementptr inbounds i64, i64* %lndL4, i32 1
  %lndL6 = ptrtoint i64* %lndL5 to i64
  %lndL7 = inttoptr i64 %lndL6 to i64*
  store i64* %lndL7, i64** %Sp_Var
  %lndL8 = bitcast i8* @timezm1zi8zi0zi2_DataziTimeziClockziPOSIX_zdwutcTimeToPOSIXSeconds_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndL9 = load i64*, i64** %Sp_Var
  %lndLa = load i64, i64* %R2_Var
  %lndLb = load i64, i64* %R3_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndL8( i64* %Base_Arg, i64* %lndL9, i64* %Hp_Arg, i64 %R1_Arg, i64 %lndLa, i64 %lndLb, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cdF0_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdF0_info$def to i8*)
define internal ghccc void @cdF0_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 1, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%udGr_srt_struct* @udGr_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdF0_info$def to i64)) to i32),i32 0)}>
{
cdF0:
  %lsaMo = alloca i64, i32 1
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lndLc = load i64*, i64** %Sp_Var
  %lndLd = getelementptr inbounds i64, i64* %lndLc, i32 1
  %lndLe = bitcast i64* %lndLd to i64*
  %lndLf = load i64, i64* %lndLe, !tbaa !2
  store i64 %lndLf, i64* %lsaMo
  %lndLh = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdF4_info$def to i64
  %lndLg = load i64*, i64** %Sp_Var
  %lndLi = getelementptr inbounds i64, i64* %lndLg, i32 1
  store i64 %lndLh, i64* %lndLi, !tbaa !2
  %lndLj = load i64, i64* %lsaMo
  store i64 %lndLj, i64* %R3_Var
  store i64 %R1_Arg, i64* %R2_Var
  %lndLk = load i64*, i64** %Sp_Var
  %lndLl = getelementptr inbounds i64, i64* %lndLk, i32 1
  %lndLm = ptrtoint i64* %lndLl to i64
  %lndLn = inttoptr i64 %lndLm to i64*
  store i64* %lndLn, i64** %Sp_Var
  %lndLo = bitcast i8* @integerzmgmp_GHCziIntegerziType_minusInteger_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndLp = load i64*, i64** %Sp_Var
  %lndLq = load i64, i64* %R2_Var
  %lndLr = load i64, i64* %R3_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndLo( i64* %Base_Arg, i64* %lndLp, i64* %Hp_Arg, i64 %R1_Arg, i64 %lndLq, i64 %lndLr, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cdF4_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdF4_info$def to i8*)
define internal ghccc void @cdF4_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 0, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%udGq_srt_struct* @udGq_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdF4_info$def to i64)) to i32),i32 0)}>
{
cdF4:
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %lndLs = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdF8_info$def to i64
  %lndLt = getelementptr inbounds i64, i64* %Sp_Arg, i32 0
  store i64 %lndLs, i64* %lndLt, !tbaa !2
  %lndLu = ptrtoint %raBX_closure_struct* @raBX_closure$def to i64
  %lndLv = add i64 %lndLu, 1
  store i64 %lndLv, i64* %R3_Var
  store i64 %R1_Arg, i64* %R2_Var
  %lndLw = bitcast i8* @integerzmgmp_GHCziIntegerziType_timesInteger_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndLx = load i64, i64* %R2_Var
  %lndLy = load i64, i64* %R3_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndLw( i64* %Base_Arg, i64* %Sp_Arg, i64* %Hp_Arg, i64 %R1_Arg, i64 %lndLx, i64 %lndLy, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cdF8_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdF8_info$def to i8*)
define internal ghccc void @cdF8_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 0, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%udGp_srt_struct* @udGp_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdF8_info$def to i64)) to i32),i32 0)}>
{
cdF8:
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %lndLz = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdFc_info$def to i64
  %lndLA = getelementptr inbounds i64, i64* %Sp_Arg, i32 0
  store i64 %lndLz, i64* %lndLA, !tbaa !2
  %lndLB = ptrtoint i8* @base_DataziFixed_zdfHasResolutionE5_closure to i64
  store i64 %lndLB, i64* %R3_Var
  store i64 %R1_Arg, i64* %R2_Var
  %lndLC = bitcast i8* @integerzmgmp_GHCziIntegerziType_divInteger_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndLD = load i64, i64* %R2_Var
  %lndLE = load i64, i64* %R3_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndLC( i64* %Base_Arg, i64* %Sp_Arg, i64* %Hp_Arg, i64 %R1_Arg, i64 %lndLD, i64 %lndLE, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cdFc_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdFc_info$def to i8*)
define internal ghccc void @cdFc_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 0, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%udGo_srt_struct* @udGo_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdFc_info$def to i64)) to i32),i32 0)}>
{
cdFc:
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %lndLF = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdFg_info$def to i64
  %lndLG = getelementptr inbounds i64, i64* %Sp_Arg, i32 0
  store i64 %lndLF, i64* %lndLG, !tbaa !2
  store i64 %R1_Arg, i64* %R4_Var
  %lndLH = ptrtoint i8* @ghczmprim_GHCziTypes_True_closure to i64
  %lndLI = add i64 %lndLH, 2
  store i64 %lndLI, i64* %R3_Var
  %lndLJ = ptrtoint i8* @base_DataziFixed_zdfHasResolutionE12zuzdcresolution_closure to i64
  %lndLK = add i64 %lndLJ, 1
  store i64 %lndLK, i64* %R2_Var
  %lndLL = bitcast i8* @base_DataziFixed_showFixed_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndLM = load i64, i64* %R2_Var
  %lndLN = load i64, i64* %R3_Var
  %lndLO = load i64, i64* %R4_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndLL( i64* %Base_Arg, i64* %Sp_Arg, i64* %Hp_Arg, i64 %R1_Arg, i64 %lndLM, i64 %lndLN, i64 %lndLO, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cdFg_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdFg_info$def to i8*)
define internal ghccc void @cdFg_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 0, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%udGn_srt_struct* @udGn_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdFg_info$def to i64)) to i32),i32 0)}>
{
cdFg:
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lndLP = ptrtoint i8* @timezm1zi8zi0zi2_DataziTimeziClockziInternalziNominalDiffTime_zdfShowNominalDiffTime3_closure to i64
  store i64 %lndLP, i64* %R3_Var
  store i64 %R1_Arg, i64* %R2_Var
  %lndLQ = load i64*, i64** %Sp_Var
  %lndLR = getelementptr inbounds i64, i64* %lndLQ, i32 1
  %lndLS = ptrtoint i64* %lndLR to i64
  %lndLT = inttoptr i64 %lndLS to i64*
  store i64* %lndLT, i64** %Sp_Var
  %lndLU = bitcast i8* @base_GHCziBase_zpzp_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndLV = load i64*, i64** %Sp_Var
  %lndLW = load i64, i64* %R2_Var
  %lndLX = load i64, i64* %R3_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndLU( i64* %Base_Arg, i64* %lndLV, i64* %Hp_Arg, i64 %R1_Arg, i64 %lndLW, i64 %lndLX, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saMu_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saMu_info$def to i8*)
define internal ghccc void @saMu_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 2, i32 18, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%udGC_srt_struct* @udGC_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saMu_info$def to i64)) to i32),i32 0)}>
{
cdFG:
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %lsaLK = alloca i64, i32 1
  %lsaLV = alloca i64, i32 1
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lndLY = load i64*, i64** %Hp_Var
  %lndLZ = getelementptr inbounds i64, i64* %lndLY, i32 4
  %lndM0 = ptrtoint i64* %lndLZ to i64
  %lndM1 = inttoptr i64 %lndM0 to i64*
  store i64* %lndM1, i64** %Hp_Var
  %lndM2 = load i64*, i64** %Hp_Var
  %lndM3 = ptrtoint i64* %lndM2 to i64
  %lndM4 = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lndM5 = bitcast i64* %lndM4 to i64*
  %lndM6 = load i64, i64* %lndM5, !tbaa !5
  %lndM7 = icmp ugt i64 %lndM3, %lndM6
  %lndM8 = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lndM7, i1 0 )
  br i1 %lndM8, label %cdFK, label %cdFJ
cdFJ:
  %lndMb = load i64, i64* %R1_Var
  %lndMc = add i64 %lndMb, 16
  %lndMd = inttoptr i64 %lndMc to i64*
  %lndMe = load i64, i64* %lndMd, !tbaa !4
  store i64 %lndMe, i64* %lsaLK
  %lndMh = load i64, i64* %R1_Var
  %lndMi = add i64 %lndMh, 24
  %lndMj = inttoptr i64 %lndMi to i64*
  %lndMk = load i64, i64* %lndMj, !tbaa !4
  store i64 %lndMk, i64* %lsaLV
  %lndMm = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saMt_info$def to i64
  %lndMl = load i64*, i64** %Hp_Var
  %lndMn = getelementptr inbounds i64, i64* %lndMl, i32 -3
  store i64 %lndMm, i64* %lndMn, !tbaa !3
  %lndMp = load i64, i64* %lsaLK
  %lndMo = load i64*, i64** %Hp_Var
  %lndMq = getelementptr inbounds i64, i64* %lndMo, i32 -1
  store i64 %lndMp, i64* %lndMq, !tbaa !3
  %lndMs = load i64, i64* %lsaLV
  %lndMr = load i64*, i64** %Hp_Var
  %lndMt = getelementptr inbounds i64, i64* %lndMr, i32 0
  store i64 %lndMs, i64* %lndMt, !tbaa !3
  %lndMu = load i64*, i64** %Hp_Var
  %lndMv = getelementptr inbounds i64, i64* %lndMu, i32 -3
  %lndMw = ptrtoint i64* %lndMv to i64
  store i64 %lndMw, i64* %R3_Var
  %lndMx = ptrtoint %raBW_bytes_struct* @raBW_bytes$def to i64
  store i64 %lndMx, i64* %R2_Var
  %lndMy = bitcast i8* @ghczmprim_GHCziCString_unpackAppendCStringzh_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndMz = load i64*, i64** %Hp_Var
  %lndMA = load i64, i64* %R1_Var
  %lndMB = load i64, i64* %R2_Var
  %lndMC = load i64, i64* %R3_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndMy( i64* %Base_Arg, i64* %Sp_Arg, i64* %lndMz, i64 %lndMA, i64 %lndMB, i64 %lndMC, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cdFK:
  %lndMD = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 32, i64* %lndMD, !tbaa !5
  %lndME = load i64, i64* %R1_Var
  store i64 %lndME, i64* %R1_Var
  %lndMF = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lndMG = bitcast i64* %lndMF to i64*
  %lndMH = load i64, i64* %lndMG, !tbaa !5
  %lndMI = inttoptr i64 %lndMH to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndMJ = load i64*, i64** %Hp_Var
  %lndMK = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndMI( i64* %Base_Arg, i64* %Sp_Arg, i64* %lndMJ, i64 %lndMK, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saMv_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saMv_info$def to i8*)
define internal ghccc void @saMv_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 4, i32 15, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%udGD_srt_struct* @udGD_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saMv_info$def to i64)) to i32),i32 0)}>
{
cdFL:
  %lsaMv = alloca i64, i32 1
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %lsaLK = alloca i64, i32 1
  %lsaLV = alloca i64, i32 1
  %lsaLX = alloca i64, i32 1
  %lsaLY = alloca i64, i32 1
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lndML = load i64, i64* %R1_Var
  store i64 %lndML, i64* %lsaMv
  %lndMM = load i64*, i64** %Sp_Var
  %lndMN = getelementptr inbounds i64, i64* %lndMM, i32 -2
  %lndMO = ptrtoint i64* %lndMN to i64
  %lndMP = icmp ult i64 %lndMO, %SpLim_Arg
  %lndMQ = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lndMP, i1 0 )
  br i1 %lndMQ, label %cdFM, label %cdFN
cdFN:
  %lndMR = load i64*, i64** %Hp_Var
  %lndMS = getelementptr inbounds i64, i64* %lndMR, i32 4
  %lndMT = ptrtoint i64* %lndMS to i64
  %lndMU = inttoptr i64 %lndMT to i64*
  store i64* %lndMU, i64** %Hp_Var
  %lndMV = load i64*, i64** %Hp_Var
  %lndMW = ptrtoint i64* %lndMV to i64
  %lndMX = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lndMY = bitcast i64* %lndMX to i64*
  %lndMZ = load i64, i64* %lndMY, !tbaa !5
  %lndN0 = icmp ugt i64 %lndMW, %lndMZ
  %lndN1 = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lndN0, i1 0 )
  br i1 %lndN1, label %cdFP, label %cdFO
cdFO:
  %lndN3 = ptrtoint i8* @stg_upd_frame_info to i64
  %lndN2 = load i64*, i64** %Sp_Var
  %lndN4 = getelementptr inbounds i64, i64* %lndN2, i32 -2
  store i64 %lndN3, i64* %lndN4, !tbaa !2
  %lndN6 = load i64, i64* %lsaMv
  %lndN5 = load i64*, i64** %Sp_Var
  %lndN7 = getelementptr inbounds i64, i64* %lndN5, i32 -1
  store i64 %lndN6, i64* %lndN7, !tbaa !2
  %lndN8 = load i64, i64* %lsaMv
  %lndN9 = add i64 %lndN8, 16
  %lndNa = inttoptr i64 %lndN9 to i64*
  %lndNb = load i64, i64* %lndNa, !tbaa !1
  store i64 %lndNb, i64* %lsaLK
  %lndNc = load i64, i64* %lsaMv
  %lndNd = add i64 %lndNc, 24
  %lndNe = inttoptr i64 %lndNd to i64*
  %lndNf = load i64, i64* %lndNe, !tbaa !1
  store i64 %lndNf, i64* %lsaLV
  %lndNg = load i64, i64* %lsaMv
  %lndNh = add i64 %lndNg, 32
  %lndNi = inttoptr i64 %lndNh to i64*
  %lndNj = load i64, i64* %lndNi, !tbaa !1
  store i64 %lndNj, i64* %lsaLX
  %lndNk = load i64, i64* %lsaMv
  %lndNl = add i64 %lndNk, 40
  %lndNm = inttoptr i64 %lndNl to i64*
  %lndNn = load i64, i64* %lndNm, !tbaa !1
  store i64 %lndNn, i64* %lsaLY
  %lndNp = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saMu_info$def to i64
  %lndNo = load i64*, i64** %Hp_Var
  %lndNq = getelementptr inbounds i64, i64* %lndNo, i32 -3
  store i64 %lndNp, i64* %lndNq, !tbaa !3
  %lndNs = load i64, i64* %lsaLK
  %lndNr = load i64*, i64** %Hp_Var
  %lndNt = getelementptr inbounds i64, i64* %lndNr, i32 -1
  store i64 %lndNs, i64* %lndNt, !tbaa !3
  %lndNv = load i64, i64* %lsaLV
  %lndNu = load i64*, i64** %Hp_Var
  %lndNw = getelementptr inbounds i64, i64* %lndNu, i32 0
  store i64 %lndNv, i64* %lndNw, !tbaa !3
  %lndNx = load i64, i64* %lsaLY
  store i64 %lndNx, i64* %R4_Var
  %lndNy = load i64, i64* %lsaLX
  store i64 %lndNy, i64* %R3_Var
  %lndNz = load i64*, i64** %Hp_Var
  %lndNA = getelementptr inbounds i64, i64* %lndNz, i32 -3
  %lndNB = ptrtoint i64* %lndNA to i64
  store i64 %lndNB, i64* %R2_Var
  %lndNC = load i64*, i64** %Sp_Var
  %lndND = getelementptr inbounds i64, i64* %lndNC, i32 -2
  %lndNE = ptrtoint i64* %lndND to i64
  %lndNF = inttoptr i64 %lndNE to i64*
  store i64* %lndNF, i64** %Sp_Var
  %lndNG = bitcast i8* @base_GHCziBase_zpzpzuzdszpzp_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndNH = load i64*, i64** %Sp_Var
  %lndNI = load i64*, i64** %Hp_Var
  %lndNJ = load i64, i64* %R1_Var
  %lndNK = load i64, i64* %R2_Var
  %lndNL = load i64, i64* %R3_Var
  %lndNM = load i64, i64* %R4_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndNG( i64* %Base_Arg, i64* %lndNH, i64* %lndNI, i64 %lndNJ, i64 %lndNK, i64 %lndNL, i64 %lndNM, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cdFP:
  %lndNN = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 32, i64* %lndNN, !tbaa !5
  br label %cdFM
cdFM:
  %lndNO = load i64, i64* %lsaMv
  store i64 %lndNO, i64* %R1_Var
  %lndNP = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lndNQ = bitcast i64* %lndNP to i64*
  %lndNR = load i64, i64* %lndNQ, !tbaa !5
  %lndNS = inttoptr i64 %lndNR to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndNT = load i64*, i64** %Sp_Var
  %lndNU = load i64*, i64** %Hp_Var
  %lndNV = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndNS( i64* %Base_Arg, i64* %lndNT, i64* %lndNU, i64 %lndNV, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saMw_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saMw_info$def to i8*)
define internal ghccc void @saMw_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 4, i32 15, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%udGE_srt_struct* @udGE_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saMw_info$def to i64)) to i32),i32 0)}>
{
cdFQ:
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %lsaLK = alloca i64, i32 1
  %lsaLV = alloca i64, i32 1
  %lsaLX = alloca i64, i32 1
  %lsaLY = alloca i64, i32 1
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lndNW = load i64*, i64** %Hp_Var
  %lndNX = getelementptr inbounds i64, i64* %lndNW, i32 6
  %lndNY = ptrtoint i64* %lndNX to i64
  %lndNZ = inttoptr i64 %lndNY to i64*
  store i64* %lndNZ, i64** %Hp_Var
  %lndO0 = load i64*, i64** %Hp_Var
  %lndO1 = ptrtoint i64* %lndO0 to i64
  %lndO2 = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lndO3 = bitcast i64* %lndO2 to i64*
  %lndO4 = load i64, i64* %lndO3, !tbaa !5
  %lndO5 = icmp ugt i64 %lndO1, %lndO4
  %lndO6 = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lndO5, i1 0 )
  br i1 %lndO6, label %cdFU, label %cdFT
cdFT:
  %lndO9 = load i64, i64* %R1_Var
  %lndOa = add i64 %lndO9, 16
  %lndOb = inttoptr i64 %lndOa to i64*
  %lndOc = load i64, i64* %lndOb, !tbaa !4
  store i64 %lndOc, i64* %lsaLK
  %lndOf = load i64, i64* %R1_Var
  %lndOg = add i64 %lndOf, 24
  %lndOh = inttoptr i64 %lndOg to i64*
  %lndOi = load i64, i64* %lndOh, !tbaa !4
  store i64 %lndOi, i64* %lsaLV
  %lndOl = load i64, i64* %R1_Var
  %lndOm = add i64 %lndOl, 32
  %lndOn = inttoptr i64 %lndOm to i64*
  %lndOo = load i64, i64* %lndOn, !tbaa !4
  store i64 %lndOo, i64* %lsaLX
  %lndOr = load i64, i64* %R1_Var
  %lndOs = add i64 %lndOr, 40
  %lndOt = inttoptr i64 %lndOs to i64*
  %lndOu = load i64, i64* %lndOt, !tbaa !4
  store i64 %lndOu, i64* %lsaLY
  %lndOw = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saMv_info$def to i64
  %lndOv = load i64*, i64** %Hp_Var
  %lndOx = getelementptr inbounds i64, i64* %lndOv, i32 -5
  store i64 %lndOw, i64* %lndOx, !tbaa !3
  %lndOz = load i64, i64* %lsaLK
  %lndOy = load i64*, i64** %Hp_Var
  %lndOA = getelementptr inbounds i64, i64* %lndOy, i32 -3
  store i64 %lndOz, i64* %lndOA, !tbaa !3
  %lndOC = load i64, i64* %lsaLV
  %lndOB = load i64*, i64** %Hp_Var
  %lndOD = getelementptr inbounds i64, i64* %lndOB, i32 -2
  store i64 %lndOC, i64* %lndOD, !tbaa !3
  %lndOF = load i64, i64* %lsaLX
  %lndOE = load i64*, i64** %Hp_Var
  %lndOG = getelementptr inbounds i64, i64* %lndOE, i32 -1
  store i64 %lndOF, i64* %lndOG, !tbaa !3
  %lndOI = load i64, i64* %lsaLY
  %lndOH = load i64*, i64** %Hp_Var
  %lndOJ = getelementptr inbounds i64, i64* %lndOH, i32 0
  store i64 %lndOI, i64* %lndOJ, !tbaa !3
  %lndOK = load i64*, i64** %Hp_Var
  %lndOL = getelementptr inbounds i64, i64* %lndOK, i32 -5
  %lndOM = ptrtoint i64* %lndOL to i64
  store i64 %lndOM, i64* %R3_Var
  %lndON = ptrtoint %raBV_bytes_struct* @raBV_bytes$def to i64
  store i64 %lndON, i64* %R2_Var
  %lndOO = bitcast i8* @ghczmprim_GHCziCString_unpackAppendCStringzh_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndOP = load i64*, i64** %Hp_Var
  %lndOQ = load i64, i64* %R1_Var
  %lndOR = load i64, i64* %R2_Var
  %lndOS = load i64, i64* %R3_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndOO( i64* %Base_Arg, i64* %Sp_Arg, i64* %lndOP, i64 %lndOQ, i64 %lndOR, i64 %lndOS, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cdFU:
  %lndOT = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 48, i64* %lndOT, !tbaa !5
  %lndOU = load i64, i64* %R1_Var
  store i64 %lndOU, i64* %R1_Var
  %lndOV = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lndOW = bitcast i64* %lndOV to i64*
  %lndOX = load i64, i64* %lndOW, !tbaa !5
  %lndOY = inttoptr i64 %lndOX to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndOZ = load i64*, i64** %Hp_Var
  %lndP0 = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndOY( i64* %Base_Arg, i64* %Sp_Arg, i64* %lndOZ, i64 %lndP0, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saMx_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saMx_info$def to i8*)
define internal ghccc void @saMx_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 2, i32 18, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%udGG_srt_struct* @udGG_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saMx_info$def to i64)) to i32),i32 0)}>
{
cdFV:
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lndP1 = load i64*, i64** %Sp_Var
  %lndP2 = getelementptr inbounds i64, i64* %lndP1, i32 -5
  %lndP3 = ptrtoint i64* %lndP2 to i64
  %lndP4 = icmp ult i64 %lndP3, %SpLim_Arg
  %lndP5 = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lndP4, i1 0 )
  br i1 %lndP5, label %cdFW, label %cdFX
cdFX:
  %lndP7 = ptrtoint i8* @stg_upd_frame_info to i64
  %lndP6 = load i64*, i64** %Sp_Var
  %lndP8 = getelementptr inbounds i64, i64* %lndP6, i32 -2
  store i64 %lndP7, i64* %lndP8, !tbaa !2
  %lndPa = load i64, i64* %R1_Var
  %lndP9 = load i64*, i64** %Sp_Var
  %lndPb = getelementptr inbounds i64, i64* %lndP9, i32 -1
  store i64 %lndPa, i64* %lndPb, !tbaa !2
  %lndPd = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdDT_info$def to i64
  %lndPc = load i64*, i64** %Sp_Var
  %lndPe = getelementptr inbounds i64, i64* %lndPc, i32 -5
  store i64 %lndPd, i64* %lndPe, !tbaa !2
  %lndPf = ptrtoint i8* @ghczmprim_GHCziTypes_ZMZN_closure to i64
  %lndPg = add i64 %lndPf, 1
  store i64 %lndPg, i64* %R4_Var
  store i64 1000, i64* %R3_Var
  store i64 0, i64* %R2_Var
  %lndPk = load i64, i64* %R1_Var
  %lndPl = add i64 %lndPk, 16
  %lndPm = inttoptr i64 %lndPl to i64*
  %lndPn = load i64, i64* %lndPm, !tbaa !4
  %lndPh = load i64*, i64** %Sp_Var
  %lndPo = getelementptr inbounds i64, i64* %lndPh, i32 -4
  store i64 %lndPn, i64* %lndPo, !tbaa !2
  %lndPs = load i64, i64* %R1_Var
  %lndPt = add i64 %lndPs, 24
  %lndPu = inttoptr i64 %lndPt to i64*
  %lndPv = load i64, i64* %lndPu, !tbaa !4
  %lndPp = load i64*, i64** %Sp_Var
  %lndPw = getelementptr inbounds i64, i64* %lndPp, i32 -3
  store i64 %lndPv, i64* %lndPw, !tbaa !2
  %lndPx = load i64*, i64** %Sp_Var
  %lndPy = getelementptr inbounds i64, i64* %lndPx, i32 -5
  %lndPz = ptrtoint i64* %lndPy to i64
  %lndPA = inttoptr i64 %lndPz to i64*
  store i64* %lndPA, i64** %Sp_Var
  %lndPB = bitcast i8* @base_GHCziShow_zdwshowSignedInt_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndPC = load i64*, i64** %Sp_Var
  %lndPD = load i64, i64* %R1_Var
  %lndPE = load i64, i64* %R2_Var
  %lndPF = load i64, i64* %R3_Var
  %lndPG = load i64, i64* %R4_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndPB( i64* %Base_Arg, i64* %lndPC, i64* %Hp_Arg, i64 %lndPD, i64 %lndPE, i64 %lndPF, i64 %lndPG, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cdFW:
  %lndPH = load i64, i64* %R1_Var
  store i64 %lndPH, i64* %R1_Var
  %lndPI = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lndPJ = bitcast i64* %lndPI to i64*
  %lndPK = load i64, i64* %lndPJ, !tbaa !5
  %lndPL = inttoptr i64 %lndPK to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndPM = load i64*, i64** %Sp_Var
  %lndPN = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndPL( i64* %Base_Arg, i64* %lndPM, i64* %Hp_Arg, i64 %lndPN, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cdDT_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdDT_info$def to i8*)
define internal ghccc void @cdDT_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 2, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%udGF_srt_struct* @udGF_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdDT_info$def to i64)) to i32),i32 0)}>
{
cdDT:
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 %R2_Arg, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lndPO = load i64*, i64** %Hp_Var
  %lndPP = getelementptr inbounds i64, i64* %lndPO, i32 6
  %lndPQ = ptrtoint i64* %lndPP to i64
  %lndPR = inttoptr i64 %lndPQ to i64*
  store i64* %lndPR, i64** %Hp_Var
  %lndPS = load i64*, i64** %Hp_Var
  %lndPT = ptrtoint i64* %lndPS to i64
  %lndPU = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lndPV = bitcast i64* %lndPU to i64*
  %lndPW = load i64, i64* %lndPV, !tbaa !5
  %lndPX = icmp ugt i64 %lndPT, %lndPW
  %lndPY = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lndPX, i1 0 )
  br i1 %lndPY, label %cdG0, label %cdFZ
cdFZ:
  %lndQ0 = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saMw_info$def to i64
  %lndPZ = load i64*, i64** %Hp_Var
  %lndQ1 = getelementptr inbounds i64, i64* %lndPZ, i32 -5
  store i64 %lndQ0, i64* %lndQ1, !tbaa !3
  %lndQ3 = load i64*, i64** %Sp_Var
  %lndQ4 = getelementptr inbounds i64, i64* %lndQ3, i32 1
  %lndQ5 = bitcast i64* %lndQ4 to i64*
  %lndQ6 = load i64, i64* %lndQ5, !tbaa !2
  %lndQ2 = load i64*, i64** %Hp_Var
  %lndQ7 = getelementptr inbounds i64, i64* %lndQ2, i32 -3
  store i64 %lndQ6, i64* %lndQ7, !tbaa !3
  %lndQ9 = load i64*, i64** %Sp_Var
  %lndQa = getelementptr inbounds i64, i64* %lndQ9, i32 2
  %lndQb = bitcast i64* %lndQa to i64*
  %lndQc = load i64, i64* %lndQb, !tbaa !2
  %lndQ8 = load i64*, i64** %Hp_Var
  %lndQd = getelementptr inbounds i64, i64* %lndQ8, i32 -2
  store i64 %lndQc, i64* %lndQd, !tbaa !3
  %lndQf = load i64, i64* %R1_Var
  %lndQe = load i64*, i64** %Hp_Var
  %lndQg = getelementptr inbounds i64, i64* %lndQe, i32 -1
  store i64 %lndQf, i64* %lndQg, !tbaa !3
  %lndQi = load i64, i64* %R2_Var
  %lndQh = load i64*, i64** %Hp_Var
  %lndQj = getelementptr inbounds i64, i64* %lndQh, i32 0
  store i64 %lndQi, i64* %lndQj, !tbaa !3
  %lndQk = load i64, i64* %R2_Var
  store i64 %lndQk, i64* %R4_Var
  %lndQl = load i64, i64* %R1_Var
  store i64 %lndQl, i64* %R3_Var
  %lndQm = load i64*, i64** %Hp_Var
  %lndQn = getelementptr inbounds i64, i64* %lndQm, i32 -5
  %lndQo = ptrtoint i64* %lndQn to i64
  store i64 %lndQo, i64* %R2_Var
  %lndQp = load i64*, i64** %Sp_Var
  %lndQq = getelementptr inbounds i64, i64* %lndQp, i32 3
  %lndQr = ptrtoint i64* %lndQq to i64
  %lndQs = inttoptr i64 %lndQr to i64*
  store i64* %lndQs, i64** %Sp_Var
  %lndQt = bitcast i8* @base_GHCziBase_zpzpzuzdszpzp_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndQu = load i64*, i64** %Sp_Var
  %lndQv = load i64*, i64** %Hp_Var
  %lndQw = load i64, i64* %R1_Var
  %lndQx = load i64, i64* %R2_Var
  %lndQy = load i64, i64* %R3_Var
  %lndQz = load i64, i64* %R4_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndQt( i64* %Base_Arg, i64* %lndQu, i64* %lndQv, i64 %lndQw, i64 %lndQx, i64 %lndQy, i64 %lndQz, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cdG0:
  %lndQA = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 48, i64* %lndQA, !tbaa !5
  %lndQB = load i64, i64* %R2_Var
  store i64 %lndQB, i64* %R2_Var
  %lndQC = load i64, i64* %R1_Var
  store i64 %lndQC, i64* %R1_Var
  %lndQD = bitcast i8* @stg_gc_pp to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndQE = load i64*, i64** %Sp_Var
  %lndQF = load i64*, i64** %Hp_Var
  %lndQG = load i64, i64* %R1_Var
  %lndQH = load i64, i64* %R2_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndQD( i64* %Base_Arg, i64* %lndQE, i64* %lndQF, i64 %lndQG, i64 %lndQH, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@saMy_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saMy_info$def to i8*)
define internal ghccc void @saMy_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 2, i32 18, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%udGH_srt_struct* @udGH_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saMy_info$def to i64)) to i32),i32 0)}>
{
cdG1:
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %lsaLK = alloca i64, i32 1
  %lsaLV = alloca i64, i32 1
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lndQI = load i64*, i64** %Hp_Var
  %lndQJ = getelementptr inbounds i64, i64* %lndQI, i32 4
  %lndQK = ptrtoint i64* %lndQJ to i64
  %lndQL = inttoptr i64 %lndQK to i64*
  store i64* %lndQL, i64** %Hp_Var
  %lndQM = load i64*, i64** %Hp_Var
  %lndQN = ptrtoint i64* %lndQM to i64
  %lndQO = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lndQP = bitcast i64* %lndQO to i64*
  %lndQQ = load i64, i64* %lndQP, !tbaa !5
  %lndQR = icmp ugt i64 %lndQN, %lndQQ
  %lndQS = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lndQR, i1 0 )
  br i1 %lndQS, label %cdG5, label %cdG4
cdG4:
  %lndQV = load i64, i64* %R1_Var
  %lndQW = add i64 %lndQV, 16
  %lndQX = inttoptr i64 %lndQW to i64*
  %lndQY = load i64, i64* %lndQX, !tbaa !4
  store i64 %lndQY, i64* %lsaLK
  %lndR1 = load i64, i64* %R1_Var
  %lndR2 = add i64 %lndR1, 24
  %lndR3 = inttoptr i64 %lndR2 to i64*
  %lndR4 = load i64, i64* %lndR3, !tbaa !4
  store i64 %lndR4, i64* %lsaLV
  %lndR6 = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saMx_info$def to i64
  %lndR5 = load i64*, i64** %Hp_Var
  %lndR7 = getelementptr inbounds i64, i64* %lndR5, i32 -3
  store i64 %lndR6, i64* %lndR7, !tbaa !3
  %lndR9 = load i64, i64* %lsaLK
  %lndR8 = load i64*, i64** %Hp_Var
  %lndRa = getelementptr inbounds i64, i64* %lndR8, i32 -1
  store i64 %lndR9, i64* %lndRa, !tbaa !3
  %lndRc = load i64, i64* %lsaLV
  %lndRb = load i64*, i64** %Hp_Var
  %lndRd = getelementptr inbounds i64, i64* %lndRb, i32 0
  store i64 %lndRc, i64* %lndRd, !tbaa !3
  %lndRe = load i64*, i64** %Hp_Var
  %lndRf = getelementptr inbounds i64, i64* %lndRe, i32 -3
  %lndRg = ptrtoint i64* %lndRf to i64
  store i64 %lndRg, i64* %R3_Var
  %lndRh = ptrtoint %raBU_bytes_struct* @raBU_bytes$def to i64
  store i64 %lndRh, i64* %R2_Var
  %lndRi = bitcast i8* @ghczmprim_GHCziCString_unpackAppendCStringzh_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndRj = load i64*, i64** %Hp_Var
  %lndRk = load i64, i64* %R1_Var
  %lndRl = load i64, i64* %R2_Var
  %lndRm = load i64, i64* %R3_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndRi( i64* %Base_Arg, i64* %Sp_Arg, i64* %lndRj, i64 %lndRk, i64 %lndRl, i64 %lndRm, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cdG5:
  %lndRn = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 32, i64* %lndRn, !tbaa !5
  %lndRo = load i64, i64* %R1_Var
  store i64 %lndRo, i64* %R1_Var
  %lndRp = getelementptr inbounds i64, i64* %Base_Arg, i32 -2
  %lndRq = bitcast i64* %lndRp to i64*
  %lndRr = load i64, i64* %lndRq, !tbaa !5
  %lndRs = inttoptr i64 %lndRr to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndRt = load i64*, i64** %Hp_Var
  %lndRu = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndRs( i64* %Base_Arg, i64* %Sp_Arg, i64* %lndRt, i64 %lndRu, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@Main_main1_info = alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_main1_info$def to i8*)
define ghccc void @Main_main1_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i64, i32, i32}><{i64 4294967299, i64 2, i32 14, i32 0}>
{
cdG6:
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lndRv = load i64*, i64** %Sp_Var
  %lndRw = getelementptr inbounds i64, i64* %lndRv, i32 -2
  %lndRx = ptrtoint i64* %lndRw to i64
  %lndRy = icmp ult i64 %lndRx, %SpLim_Arg
  %lndRz = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lndRy, i1 0 )
  br i1 %lndRz, label %cdG8, label %cdG9
cdG9:
  %lndRB = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdDs_info$def to i64
  %lndRA = load i64*, i64** %Sp_Var
  %lndRC = getelementptr inbounds i64, i64* %lndRA, i32 -1
  store i64 %lndRB, i64* %lndRC, !tbaa !2
  %lndRD = ptrtoint i8* @ghczmprim_GHCziTypes_True_closure to i64
  %lndRE = add i64 %lndRD, 2
  store i64 %lndRE, i64* %R4_Var
  %lndRF = ptrtoint %raC2_closure_struct* @raC2_closure$def to i64
  store i64 %lndRF, i64* %R3_Var
  %lndRG = ptrtoint i8* @base_GHCziIOziHandleziFD_stdout_closure to i64
  store i64 %lndRG, i64* %R2_Var
  %lndRH = load i64*, i64** %Sp_Var
  %lndRI = getelementptr inbounds i64, i64* %lndRH, i32 -1
  %lndRJ = ptrtoint i64* %lndRI to i64
  %lndRK = inttoptr i64 %lndRJ to i64*
  store i64* %lndRK, i64** %Sp_Var
  %lndRL = bitcast i8* @base_GHCziIOziHandleziText_hPutStrzq_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndRM = load i64*, i64** %Sp_Var
  %lndRN = load i64, i64* %R1_Var
  %lndRO = load i64, i64* %R2_Var
  %lndRP = load i64, i64* %R3_Var
  %lndRQ = load i64, i64* %R4_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndRL( i64* %Base_Arg, i64* %lndRM, i64* %Hp_Arg, i64 %lndRN, i64 %lndRO, i64 %lndRP, i64 %lndRQ, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cdG8:
  %lndRR = ptrtoint %Main_main1_closure_struct* @Main_main1_closure$def to i64
  store i64 %lndRR, i64* %R1_Var
  %lndRS = getelementptr inbounds i64, i64* %Base_Arg, i32 -1
  %lndRT = bitcast i64* %lndRS to i64*
  %lndRU = load i64, i64* %lndRT, !tbaa !5
  %lndRV = inttoptr i64 %lndRU to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndRW = load i64*, i64** %Sp_Var
  %lndRX = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndRV( i64* %Base_Arg, i64* %lndRW, i64* %Hp_Arg, i64 %lndRX, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cdDs_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdDs_info$def to i8*)
define internal ghccc void @cdDs_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 0, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%udGO_srt_struct* @udGO_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdDs_info$def to i64)) to i32),i32 0)}>
{
cdDs:
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %lndRY = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdDu_info$def to i64
  %lndRZ = getelementptr inbounds i64, i64* %Sp_Arg, i32 0
  store i64 %lndRY, i64* %lndRZ, !tbaa !2
  %lndS0 = ptrtoint i8* @ghczmprim_GHCziTypes_True_closure to i64
  %lndS1 = add i64 %lndS0, 2
  store i64 %lndS1, i64* %R4_Var
  %lndS2 = ptrtoint %raC0_closure_struct* @raC0_closure$def to i64
  store i64 %lndS2, i64* %R3_Var
  %lndS3 = ptrtoint i8* @base_GHCziIOziHandleziFD_stdout_closure to i64
  store i64 %lndS3, i64* %R2_Var
  %lndS4 = bitcast i8* @base_GHCziIOziHandleziText_hPutStrzq_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndS5 = load i64, i64* %R2_Var
  %lndS6 = load i64, i64* %R3_Var
  %lndS7 = load i64, i64* %R4_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndS4( i64* %Base_Arg, i64* %Sp_Arg, i64* %Hp_Arg, i64 %R1_Arg, i64 %lndS5, i64 %lndS6, i64 %lndS7, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cdDu_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdDu_info$def to i8*)
define internal ghccc void @cdDu_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 0, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%udGN_srt_struct* @udGN_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdDu_info$def to i64)) to i32),i32 0)}>
{
cdDu:
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %lndS8 = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdDw_info$def to i64
  %lndS9 = getelementptr inbounds i64, i64* %Sp_Arg, i32 0
  store i64 %lndS8, i64* %lndS9, !tbaa !2
  %lndSa = ptrtoint i8* @ghczmprim_GHCziTypes_True_closure to i64
  %lndSb = add i64 %lndSa, 2
  store i64 %lndSb, i64* %R4_Var
  %lndSc = ptrtoint %raBZ_closure_struct* @raBZ_closure$def to i64
  store i64 %lndSc, i64* %R3_Var
  %lndSd = ptrtoint i8* @base_GHCziIOziHandleziFD_stdout_closure to i64
  store i64 %lndSd, i64* %R2_Var
  %lndSe = bitcast i8* @base_GHCziIOziHandleziText_hPutStrzq_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndSf = load i64, i64* %R2_Var
  %lndSg = load i64, i64* %R3_Var
  %lndSh = load i64, i64* %R4_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndSe( i64* %Base_Arg, i64* %Sp_Arg, i64* %Hp_Arg, i64 %R1_Arg, i64 %lndSf, i64 %lndSg, i64 %lndSh, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cdDw_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdDw_info$def to i8*)
define internal ghccc void @cdDw_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 0, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%udGM_srt_struct* @udGM_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdDw_info$def to i64)) to i32),i32 0)}>
{
cdDw:
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %lndSi = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdDy_info$def to i64
  %lndSj = getelementptr inbounds i64, i64* %Sp_Arg, i32 0
  store i64 %lndSi, i64* %lndSj, !tbaa !2
  store i64 0, i64* %R2_Var
  %lndSk = bitcast i8* @timezm1zi8zi0zi2_DataziTimeziClockziInternalziCTimespec_zdwclockGetTime_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndSl = load i64, i64* %R2_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndSk( i64* %Base_Arg, i64* %Sp_Arg, i64* %Hp_Arg, i64 %R1_Arg, i64 %lndSl, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cdDy_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdDy_info$def to i8*)
define internal ghccc void @cdDy_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 0, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%udGL_srt_struct* @udGL_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdDy_info$def to i64)) to i32),i32 0)}>
{
cdDy:
  %lsaLK = alloca i64, i32 1
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lndSn = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdDA_info$def to i64
  %lndSm = load i64*, i64** %Sp_Var
  %lndSo = getelementptr inbounds i64, i64* %lndSm, i32 -1
  store i64 %lndSn, i64* %lndSo, !tbaa !2
  %lndSp = load i64, i64* %R1_Var
  store i64 %lndSp, i64* %lsaLK
  %lndSq = ptrtoint %raBS_closure_struct* @raBS_closure$def to i64
  store i64 %lndSq, i64* %R1_Var
  %lndSs = load i64, i64* %lsaLK
  %lndSr = load i64*, i64** %Sp_Var
  %lndSt = getelementptr inbounds i64, i64* %lndSr, i32 0
  store i64 %lndSs, i64* %lndSt, !tbaa !2
  %lndSu = load i64*, i64** %Sp_Var
  %lndSv = getelementptr inbounds i64, i64* %lndSu, i32 -1
  %lndSw = ptrtoint i64* %lndSv to i64
  %lndSx = inttoptr i64 %lndSw to i64*
  store i64* %lndSx, i64** %Sp_Var
  %lndSy = load i64, i64* %R1_Var
  %lndSz = and i64 %lndSy, 7
  %lndSA = icmp ne i64 %lndSz, 0
  br i1 %lndSA, label %udGl, label %cdDB
cdDB:
  %lndSC = load i64, i64* %R1_Var
  %lndSD = inttoptr i64 %lndSC to i64*
  %lndSE = load i64, i64* %lndSD, !tbaa !4
  %lndSF = inttoptr i64 %lndSE to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndSG = load i64*, i64** %Sp_Var
  %lndSH = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndSF( i64* %Base_Arg, i64* %lndSG, i64* %Hp_Arg, i64 %lndSH, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
udGl:
  %lndSI = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdDA_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndSJ = load i64*, i64** %Sp_Var
  %lndSK = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndSI( i64* %Base_Arg, i64* %lndSJ, i64* %Hp_Arg, i64 %lndSK, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cdDA_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdDA_info$def to i8*)
define internal ghccc void @cdDA_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 1, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%udGK_srt_struct* @udGK_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdDA_info$def to i64)) to i32),i32 0)}>
{
cdDA:
  %R6_Var = alloca i64, i32 1
  store i64 undef, i64* %R6_Var
  %R5_Var = alloca i64, i32 1
  store i64 undef, i64* %R5_Var
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %lndSL = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdDF_info$def to i64
  %lndSM = getelementptr inbounds i64, i64* %Sp_Arg, i32 0
  store i64 %lndSL, i64* %lndSM, !tbaa !2
  %lndSN = ptrtoint %raBY_closure_struct* @raBY_closure$def to i64
  store i64 %lndSN, i64* %R6_Var
  %lndSO = add i64 %R1_Arg, 7
  %lndSP = inttoptr i64 %lndSO to i64*
  %lndSQ = load i64, i64* %lndSP, !tbaa !4
  store i64 %lndSQ, i64* %R5_Var
  %lndSR = add i64 %R1_Arg, 23
  %lndSS = inttoptr i64 %lndSR to i64*
  %lndST = load i64, i64* %lndSS, !tbaa !4
  store i64 %lndST, i64* %R4_Var
  %lndSU = add i64 %R1_Arg, 15
  %lndSV = inttoptr i64 %lndSU to i64*
  %lndSW = load i64, i64* %lndSV, !tbaa !4
  store i64 %lndSW, i64* %R3_Var
  %lndSX = ptrtoint %raBR_closure_struct* @raBR_closure$def to i64
  store i64 %lndSX, i64* %R2_Var
  %lndSY = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_zdwzdsconjugateGradient_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndSZ = load i64, i64* %R2_Var
  %lndT0 = load i64, i64* %R3_Var
  %lndT1 = load i64, i64* %R4_Var
  %lndT2 = load i64, i64* %R5_Var
  %lndT3 = load i64, i64* %R6_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndSY( i64* %Base_Arg, i64* %Sp_Arg, i64* %Hp_Arg, i64 %R1_Arg, i64 %lndSZ, i64 %lndT0, i64 %lndT1, i64 %lndT2, i64 %lndT3, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cdDF_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdDF_info$def to i8*)
define internal ghccc void @cdDF_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 1, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%udGJ_srt_struct* @udGJ_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdDF_info$def to i64)) to i32),i32 0)}>
{
cdDF:
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %lndT4 = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdDJ_info$def to i64
  %lndT5 = getelementptr inbounds i64, i64* %Sp_Arg, i32 0
  store i64 %lndT4, i64* %lndT5, !tbaa !2
  store i64 0, i64* %R2_Var
  %lndT6 = bitcast i8* @timezm1zi8zi0zi2_DataziTimeziClockziInternalziCTimespec_zdwclockGetTime_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndT7 = load i64, i64* %R2_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndT6( i64* %Base_Arg, i64* %Sp_Arg, i64* %Hp_Arg, i64 %R1_Arg, i64 %lndT7, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cdDJ_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdDJ_info$def to i8*)
define internal ghccc void @cdDJ_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 1, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%udGI_srt_struct* @udGI_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdDJ_info$def to i64)) to i32),i32 0)}>
{
cdDJ:
  %Hp_Var = alloca i64*, i32 1
  store i64* %Hp_Arg, i64** %Hp_Var
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %R1_Var = alloca i64, i32 1
  store i64 %R1_Arg, i64* %R1_Var
  %lndT8 = load i64*, i64** %Hp_Var
  %lndT9 = getelementptr inbounds i64, i64* %lndT8, i32 4
  %lndTa = ptrtoint i64* %lndT9 to i64
  %lndTb = inttoptr i64 %lndTa to i64*
  store i64* %lndTb, i64** %Hp_Var
  %lndTc = load i64*, i64** %Hp_Var
  %lndTd = ptrtoint i64* %lndTc to i64
  %lndTe = getelementptr inbounds i64, i64* %Base_Arg, i32 107
  %lndTf = bitcast i64* %lndTe to i64*
  %lndTg = load i64, i64* %lndTf, !tbaa !5
  %lndTh = icmp ugt i64 %lndTd, %lndTg
  %lndTi = call ccc i1 (i1, i1) @llvm.expect.i1( i1 %lndTh, i1 0 )
  br i1 %lndTi, label %cdGi, label %cdGh
cdGh:
  %lndTk = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @saMy_info$def to i64
  %lndTj = load i64*, i64** %Hp_Var
  %lndTl = getelementptr inbounds i64, i64* %lndTj, i32 -3
  store i64 %lndTk, i64* %lndTl, !tbaa !3
  %lndTn = load i64*, i64** %Sp_Var
  %lndTo = getelementptr inbounds i64, i64* %lndTn, i32 1
  %lndTp = bitcast i64* %lndTo to i64*
  %lndTq = load i64, i64* %lndTp, !tbaa !2
  %lndTm = load i64*, i64** %Hp_Var
  %lndTr = getelementptr inbounds i64, i64* %lndTm, i32 -1
  store i64 %lndTq, i64* %lndTr, !tbaa !3
  %lndTt = load i64, i64* %R1_Var
  %lndTs = load i64*, i64** %Hp_Var
  %lndTu = getelementptr inbounds i64, i64* %lndTs, i32 0
  store i64 %lndTt, i64* %lndTu, !tbaa !3
  %lndTw = ptrtoint void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdG7_info$def to i64
  %lndTv = load i64*, i64** %Sp_Var
  %lndTx = getelementptr inbounds i64, i64* %lndTv, i32 1
  store i64 %lndTw, i64* %lndTx, !tbaa !2
  %lndTy = ptrtoint i8* @ghczmprim_GHCziTypes_True_closure to i64
  %lndTz = add i64 %lndTy, 2
  store i64 %lndTz, i64* %R4_Var
  %lndTA = load i64*, i64** %Hp_Var
  %lndTB = getelementptr inbounds i64, i64* %lndTA, i32 -3
  %lndTC = ptrtoint i64* %lndTB to i64
  store i64 %lndTC, i64* %R3_Var
  %lndTD = ptrtoint i8* @base_GHCziIOziHandleziFD_stdout_closure to i64
  store i64 %lndTD, i64* %R2_Var
  %lndTE = load i64*, i64** %Sp_Var
  %lndTF = getelementptr inbounds i64, i64* %lndTE, i32 1
  %lndTG = ptrtoint i64* %lndTF to i64
  %lndTH = inttoptr i64 %lndTG to i64*
  store i64* %lndTH, i64** %Sp_Var
  %lndTI = bitcast i8* @base_GHCziIOziHandleziText_hPutStrzq_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndTJ = load i64*, i64** %Sp_Var
  %lndTK = load i64*, i64** %Hp_Var
  %lndTL = load i64, i64* %R1_Var
  %lndTM = load i64, i64* %R2_Var
  %lndTN = load i64, i64* %R3_Var
  %lndTO = load i64, i64* %R4_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndTI( i64* %Base_Arg, i64* %lndTJ, i64* %lndTK, i64 %lndTL, i64 %lndTM, i64 %lndTN, i64 %lndTO, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
cdGi:
  %lndTP = getelementptr inbounds i64, i64* %Base_Arg, i32 113
  store i64 32, i64* %lndTP, !tbaa !5
  %lndTQ = load i64, i64* %R1_Var
  store i64 %lndTQ, i64* %R1_Var
  %lndTR = bitcast i8* @stg_gc_unpt_r1 to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndTS = load i64*, i64** %Sp_Var
  %lndTT = load i64*, i64** %Hp_Var
  %lndTU = load i64, i64* %R1_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndTR( i64* %Base_Arg, i64* %lndTS, i64* %lndTT, i64 %lndTU, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@cdG7_info = internal alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdG7_info$def to i8*)
define internal ghccc void @cdG7_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i32, i32}><{i64 0, i32 30, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%udGm_srt_struct* @udGm_srt$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @cdG7_info$def to i64)) to i32),i32 0)}>
{
cdG7:
  %R4_Var = alloca i64, i32 1
  store i64 undef, i64* %R4_Var
  %R3_Var = alloca i64, i32 1
  store i64 undef, i64* %R3_Var
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %Sp_Var = alloca i64*, i32 1
  store i64* %Sp_Arg, i64** %Sp_Var
  %lndTV = ptrtoint i8* @ghczmprim_GHCziTypes_True_closure to i64
  %lndTW = add i64 %lndTV, 2
  store i64 %lndTW, i64* %R4_Var
  %lndTX = ptrtoint %raBT_closure_struct* @raBT_closure$def to i64
  store i64 %lndTX, i64* %R3_Var
  %lndTY = ptrtoint i8* @base_GHCziIOziHandleziFD_stdout_closure to i64
  store i64 %lndTY, i64* %R2_Var
  %lndTZ = load i64*, i64** %Sp_Var
  %lndU0 = getelementptr inbounds i64, i64* %lndTZ, i32 1
  %lndU1 = ptrtoint i64* %lndU0 to i64
  %lndU2 = inttoptr i64 %lndU1 to i64*
  store i64* %lndU2, i64** %Sp_Var
  %lndU3 = bitcast i8* @base_GHCziIOziHandleziText_hPutStrzq_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndU4 = load i64*, i64** %Sp_Var
  %lndU5 = load i64, i64* %R2_Var
  %lndU6 = load i64, i64* %R3_Var
  %lndU7 = load i64, i64* %R4_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndU3( i64* %Base_Arg, i64* %lndU4, i64* %Hp_Arg, i64 %R1_Arg, i64 %lndU5, i64 %lndU6, i64 %lndU7, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
%Main_main_closure_struct = type <{i64, i64}>
@Main_main_closure$def = internal global %Main_main_closure_struct<{i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_main_info$def to i64), i64 0}>
@Main_main_closure = alias i8, bitcast (%Main_main_closure_struct* @Main_main_closure$def to i8*)



==================== LLVM Code ====================
@Main_main_info = alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_main_info$def to i8*)
define ghccc void @Main_main_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i64, i32, i32}><{i64 4294967299, i64 0, i32 14, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%Main_main1_closure_struct* @Main_main1_closure$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_main_info$def to i64)) to i32),i32 0)}>
{
cdUc:
  %lndUf = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_main1_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndUf( i64* %Base_Arg, i64* %Sp_Arg, i64* %Hp_Arg, i64 %R1_Arg, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
%Main_main2_closure_struct = type <{i64, i64, i64, i64}>
@Main_main2_closure$def = internal global %Main_main2_closure_struct<{i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_main2_info$def to i64), i64 ptrtoint (i8* @base_GHCziTopHandler_runMainIO1_closure to i64), i64 ptrtoint (%Main_main1_closure_struct* @Main_main1_closure$def to i64), i64 0}>
@Main_main2_closure = alias i8, bitcast (%Main_main2_closure_struct* @Main_main2_closure$def to i8*)



==================== LLVM Code ====================
@Main_main2_info = alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_main2_info$def to i8*)
define ghccc void @Main_main2_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i64, i32, i32}><{i64 4294967299, i64 2, i32 14, i32 0}>
{
cdUk:
  %R2_Var = alloca i64, i32 1
  store i64 undef, i64* %R2_Var
  %lndUn = ptrtoint %Main_main1_closure_struct* @Main_main1_closure$def to i64
  %lndUo = add i64 %lndUn, 1
  store i64 %lndUo, i64* %R2_Var
  %lndUp = bitcast i8* @base_GHCziTopHandler_runMainIO1_info to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  %lndUq = load i64, i64* %R2_Var
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndUp( i64* %Base_Arg, i64* %Sp_Arg, i64* %Hp_Arg, i64 %R1_Arg, i64 %lndUq, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
%ZCMain_main_closure_struct = type <{i64, i64}>
@ZCMain_main_closure$def = internal global %ZCMain_main_closure_struct<{i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ZCMain_main_info$def to i64), i64 0}>
@ZCMain_main_closure = alias i8, bitcast (%ZCMain_main_closure_struct* @ZCMain_main_closure$def to i8*)



==================== LLVM Code ====================
@ZCMain_main_info = alias i8, bitcast (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ZCMain_main_info$def to i8*)
define ghccc void @ZCMain_main_info$def(i64* noalias nocapture %Base_Arg, i64* noalias nocapture %Sp_Arg, i64* noalias nocapture %Hp_Arg, i64 %R1_Arg, i64 %R2_Arg, i64 %R3_Arg, i64 %R4_Arg, i64 %R5_Arg, i64 %R6_Arg, i64 %SpLim_Arg) align 8 nounwind prefix <{i64, i64, i32, i32}><{i64 4294967299, i64 0, i32 14, i32 add (i32 trunc (i64 sub (i64 ptrtoint (%Main_main2_closure_struct* @Main_main2_closure$def to i64),i64 ptrtoint (void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @ZCMain_main_info$def to i64)) to i32),i32 0)}>
{
cdUv:
  %lndUy = bitcast void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)* @Main_main2_info$def to void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64)*
  tail call ghccc void (i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64) %lndUy( i64* %Base_Arg, i64* %Sp_Arg, i64* %Hp_Arg, i64 %R1_Arg, i64 undef, i64 undef, i64 undef, i64 undef, i64 undef, i64 %SpLim_Arg ) nounwind
  ret void
}



==================== LLVM Code ====================
@rintDouble = external global i8
@stg_SRT_1_info = external global i8
@integerzmgmp_GHCziIntegerziType_shiftLInteger_closure = external global i8
@integerzmgmp_GHCziIntegerziType_decodeDoubleInteger_info = external global i8
@integerzmgmp_GHCziIntegerziType_shiftLInteger_info = external global i8
@integerzmgmp_GHCziIntegerziType_integerToInt_info = external global i8
@integerzmgmp_GHCziIntegerziType_doubleFromInteger_info = external global i8
@integerzmgmp_GHCziIntegerziType_Szh_con_info = external global i8
@base_GHCziReal_ZCzv_con_info = external global i8
@base_GHCziReal_zdfIntegralInteger_closure = external global i8
@stg_upd_frame_info = external global i8
@stg_ap_p_fast = external global i8
@stg_ap_pp_fast = external global i8
@base_GHCziReal_zdp1Real_info = external global i8
@stg_gc_unpt_r1 = external global i8
@stg_ap_p_info = external global i8
@base_GHCziNum_fromInteger_info = external global i8
@ghczmprim_GHCziTuple_Z0T_closure = external global i8
@base_GHCziBase_return_info = external global i8
@stg_ap_pp_info = external global i8
@base_GHCziNum_zm_info = external global i8
@base_GHCziBase_zgzg_info = external global i8
@stg_ap_0_fast = external global i8
@ghczmprim_GHCziTypes_Dzh_con_info = external global i8
@hblaszm0zi0zi0zi0zminplace_HBLASziLevel1_axpyzq_closure = external global i8
@hblaszm0zi0zi0zi0zminplace_HBLASziLevel2_zdwgemvzq_closure = external global i8
@stg_SRT_2_info = external global i8
@vctrzm0zi12zi0zi2zm9a8f7398_DataziVectorziMutable_uninitialised_closure = external global i8
@stg_SRT_3_info = external global i8
@base_GHCziFloat_zdfFloatingDouble_closure = external global i8
@base_GHCziFloat_zdfNumDouble_closure = external global i8
@hblaszm0zi0zi0zi0zminplace_HBLASziLevel2_zdwgemvzq_info = external global i8
@hblaszm0zi0zi0zi0zminplace_HBLASziLevel1_axpyzq_info = external global i8
@stg_newArrayzh = external global i8
@stg_MUT_ARR_PTRS_DIRTY_info = external global i8
@stg_gc_noregs = external global i8
@stg_MUT_ARR_PTRS_FROZEN_DIRTY_info = external global i8
@vctrzm0zi12zi0zi2zm9a8f7398_DataziVector_Vector_con_info = external global i8
@stg_gc_unbx_r1 = external global i8
@hblaszm0zi0zi0zi0zminplace_HBLASziLevel1_zdwnrm2_info = external global i8
@base_GHCziReal_zdp1Fractional_info = external global i8
@base_GHCziNum_negate_info = external global i8
@base_GHCziFloat_zdp1Floating_info = external global i8
@base_GHCziReal_fromRational_info = external global i8
@base_GHCziNum_zt_info = external global i8
@stg_ap_2_upd_info = external global i8
@hblaszm0zi0zi0zi0zminplace_HBLASziLevel1_zdwdot_info = external global i8
@base_GHCziReal_zs_info = external global i8
@ghczmprim_GHCziClasses_zl_info = external global i8
@ghczmprim_GHCziTypes_TrNameS_con_info = external global i8
@ghczmprim_GHCziTypes_Module_con_info = external global i8
@hblaszm0zi0zi0zi0zminplace_HBLASziIOziVector_zdwcreateSymSq_closure = external global i8
@newCAF = external global i8
@stg_bh_upd_frame_info = external global i8
@hblaszm0zi0zi0zi0zminplace_HBLASziIOziVector_zdwcreateSymSq_info = external global i8
@hblaszm0zi0zi0zi0zminplace_HBLASziIOziVector_zdwcreateVecXzq_closure = external global i8
@hblaszm0zi0zi0zi0zminplace_HBLASziIOziVector_zdwcreateVecXzq_info = external global i8
@base_GHCziFloat_zdfShowDouble2_closure = external global i8
@base_GHCziFloat_minExpt_closure = external global i8
@ghczmprim_GHCziTypes_ZMZN_closure = external global i8
@base_GHCziFloat_zdwzdsshowSignedFloat_info = external global i8
@hblaszm0zi0zi0zi0zminplace_HBLASziIOziVector_zdwcreateVec0_closure = external global i8
@hblaszm0zi0zi0zi0zminplace_HBLASziIOziVector_zdwcreateVec0_info = external global i8
@base_GHCziShow_zdwshowSignedInt_info = external global i8
@ghczmprim_GHCziTypes_ZC_con_info = external global i8
@stg_gc_pp = external global i8
@ghczmprim_GHCziCString_unpackCStringzh_info = external global i8
@base_GHCziIOziHandleziFD_stdout_closure = external global i8
@base_GHCziIOziHandleziText_hPutStrzq_closure = external global i8
@timezm1zi8zi0zi2_DataziTimeziClockziInternalziNominalDiffTime_zdfShowNominalDiffTime3_closure = external global i8
@base_DataziFixed_showFixed_closure = external global i8
@integerzmgmp_GHCziIntegerziType_divInteger_closure = external global i8
@integerzmgmp_GHCziIntegerziType_timesInteger_closure = external global i8
@integerzmgmp_GHCziIntegerziType_minusInteger_closure = external global i8
@timezm1zi8zi0zi2_DataziTimeziClockziPOSIX_zdwutcTimeToPOSIXSeconds_closure = external global i8
@timezm1zi8zi0zi2_DataziTimeziClockziSystem_zdwsystemToUTCTime_closure = external global i8
@timezm1zi8zi0zi2_DataziTimeziClockziInternalziCTimespec_zdwclockGetTime_closure = external global i8
@stg_SRT_4_info = external global i8
@timezm1zi8zi0zi2_DataziTimeziClockziSystem_zdwsystemToUTCTime_info = external global i8
@timezm1zi8zi0zi2_DataziTimeziClockziPOSIX_zdwutcTimeToPOSIXSeconds_info = external global i8
@integerzmgmp_GHCziIntegerziType_minusInteger_info = external global i8
@integerzmgmp_GHCziIntegerziType_timesInteger_info = external global i8
@base_DataziFixed_zdfHasResolutionE5_closure = external global i8
@integerzmgmp_GHCziIntegerziType_divInteger_info = external global i8
@ghczmprim_GHCziTypes_True_closure = external global i8
@base_DataziFixed_zdfHasResolutionE12zuzdcresolution_closure = external global i8
@base_DataziFixed_showFixed_info = external global i8
@base_GHCziBase_zpzp_info = external global i8
@ghczmprim_GHCziCString_unpackAppendCStringzh_info = external global i8
@base_GHCziBase_zpzpzuzdszpzp_info = external global i8
@base_GHCziIOziHandleziText_hPutStrzq_info = external global i8
@timezm1zi8zi0zi2_DataziTimeziClockziInternalziCTimespec_zdwclockGetTime_info = external global i8
@base_GHCziTopHandler_runMainIO1_closure = external global i8
@base_GHCziTopHandler_runMainIO1_info = external global i8



==================== LLVM Code ====================
@llvm.used = appending constant [98 x i8*] [i8* bitcast (%ZCMain_main_closure_struct* @ZCMain_main_closure$def to i8*), i8* bitcast (%Main_main2_closure_struct* @Main_main2_closure$def to i8*), i8* bitcast (%Main_main_closure_struct* @Main_main_closure$def to i8*), i8* bitcast (%Main_main1_closure_struct* @Main_main1_closure$def to i8*), i8* bitcast (%udGO_srt_struct* @udGO_srt$def to i8*), i8* bitcast (%udGN_srt_struct* @udGN_srt$def to i8*), i8* bitcast (%udGM_srt_struct* @udGM_srt$def to i8*), i8* bitcast (%udGL_srt_struct* @udGL_srt$def to i8*), i8* bitcast (%udGK_srt_struct* @udGK_srt$def to i8*), i8* bitcast (%udGJ_srt_struct* @udGJ_srt$def to i8*), i8* bitcast (%udGI_srt_struct* @udGI_srt$def to i8*), i8* bitcast (%udGH_srt_struct* @udGH_srt$def to i8*), i8* bitcast (%udGG_srt_struct* @udGG_srt$def to i8*), i8* bitcast (%udGF_srt_struct* @udGF_srt$def to i8*), i8* bitcast (%udGE_srt_struct* @udGE_srt$def to i8*), i8* bitcast (%udGD_srt_struct* @udGD_srt$def to i8*), i8* bitcast (%udGC_srt_struct* @udGC_srt$def to i8*), i8* bitcast (%udGB_srt_struct* @udGB_srt$def to i8*), i8* bitcast (%udGA_srt_struct* @udGA_srt$def to i8*), i8* bitcast (%udGz_srt_struct* @udGz_srt$def to i8*), i8* bitcast (%udGy_srt_struct* @udGy_srt$def to i8*), i8* bitcast (%udGx_srt_struct* @udGx_srt$def to i8*), i8* bitcast (%udGw_srt_struct* @udGw_srt$def to i8*), i8* bitcast (%udGv_srt_struct* @udGv_srt$def to i8*), i8* bitcast (%udGu_srt_struct* @udGu_srt$def to i8*), i8* bitcast (%udGt_srt_struct* @udGt_srt$def to i8*), i8* bitcast (%udGs_srt_struct* @udGs_srt$def to i8*), i8* bitcast (%udGr_srt_struct* @udGr_srt$def to i8*), i8* bitcast (%udGq_srt_struct* @udGq_srt$def to i8*), i8* bitcast (%udGp_srt_struct* @udGp_srt$def to i8*), i8* bitcast (%udGo_srt_struct* @udGo_srt$def to i8*), i8* bitcast (%udGn_srt_struct* @udGn_srt$def to i8*), i8* bitcast (%udGm_srt_struct* @udGm_srt$def to i8*), i8* bitcast (%raC2_closure_struct* @raC2_closure$def to i8*), i8* bitcast (%raC1_bytes_struct* @raC1_bytes$def to i8*), i8* bitcast (%raC0_closure_struct* @raC0_closure$def to i8*), i8* bitcast (%raBZ_closure_struct* @raBZ_closure$def to i8*), i8* bitcast (%raBY_closure_struct* @raBY_closure$def to i8*), i8* bitcast (%udxz_srt_struct* @udxz_srt$def to i8*), i8* bitcast (%raBX_closure_struct* @raBX_closure$def to i8*), i8* bitcast (%raBW_bytes_struct* @raBW_bytes$def to i8*), i8* bitcast (%raBV_bytes_struct* @raBV_bytes$def to i8*), i8* bitcast (%raBU_bytes_struct* @raBU_bytes$def to i8*), i8* bitcast (%raBT_closure_struct* @raBT_closure$def to i8*), i8* bitcast (%udwm_srt_struct* @udwm_srt$def to i8*), i8* bitcast (%udwl_srt_struct* @udwl_srt$def to i8*), i8* bitcast (%raBS_closure_struct* @raBS_closure$def to i8*), i8* bitcast (%udvo_srt_struct* @udvo_srt$def to i8*), i8* bitcast (%raBR_closure_struct* @raBR_closure$def to i8*), i8* bitcast (%uduv_srt_struct* @uduv_srt$def to i8*), i8* bitcast (%Main_zdtrModule_closure_struct* @Main_zdtrModule_closure$def to i8*), i8* bitcast (%Main_zdtrModule1_closure_struct* @Main_zdtrModule1_closure$def to i8*), i8* bitcast (%Main_zdtrModule2_bytes_struct* @Main_zdtrModule2_bytes$def to i8*), i8* bitcast (%Main_zdtrModule3_closure_struct* @Main_zdtrModule3_closure$def to i8*), i8* bitcast (%Main_zdtrModule4_bytes_struct* @Main_zdtrModule4_bytes$def to i8*), i8* bitcast (%Main_conjugateGradient_closure_struct* @Main_conjugateGradient_closure$def to i8*), i8* bitcast (%Main_zdwconjugateGradient_closure_struct* @Main_zdwconjugateGradient_closure$def to i8*), i8* bitcast (%ucuT_srt_struct* @ucuT_srt$def to i8*), i8* bitcast (%ucuS_srt_struct* @ucuS_srt$def to i8*), i8* bitcast (%ucuR_srt_struct* @ucuR_srt$def to i8*), i8* bitcast (%ucuQ_srt_struct* @ucuQ_srt$def to i8*), i8* bitcast (%ucuP_srt_struct* @ucuP_srt$def to i8*), i8* bitcast (%ucuO_srt_struct* @ucuO_srt$def to i8*), i8* bitcast (%ucuN_srt_struct* @ucuN_srt$def to i8*), i8* bitcast (%ucuM_srt_struct* @ucuM_srt$def to i8*), i8* bitcast (%ucuL_srt_struct* @ucuL_srt$def to i8*), i8* bitcast (%ucuK_srt_struct* @ucuK_srt$def to i8*), i8* bitcast (%ucuJ_srt_struct* @ucuJ_srt$def to i8*), i8* bitcast (%ucuI_srt_struct* @ucuI_srt$def to i8*), i8* bitcast (%raBQ_closure_struct* @raBQ_closure$def to i8*), i8* bitcast (%raBP_closure_struct* @raBP_closure$def to i8*), i8* bitcast (%Main_zdwzdsconjugateGradient_closure_struct* @Main_zdwzdsconjugateGradient_closure$def to i8*), i8* bitcast (%ubmu_srt_struct* @ubmu_srt$def to i8*), i8* bitcast (%ubmt_srt_struct* @ubmt_srt$def to i8*), i8* bitcast (%ubms_srt_struct* @ubms_srt$def to i8*), i8* bitcast (%ubmr_srt_struct* @ubmr_srt$def to i8*), i8* bitcast (%ubmq_srt_struct* @ubmq_srt$def to i8*), i8* bitcast (%ubmp_srt_struct* @ubmp_srt$def to i8*), i8* bitcast (%ubmo_srt_struct* @ubmo_srt$def to i8*), i8* bitcast (%ubmn_srt_struct* @ubmn_srt$def to i8*), i8* bitcast (%ubmm_srt_struct* @ubmm_srt$def to i8*), i8* bitcast (%ubml_srt_struct* @ubml_srt$def to i8*), i8* bitcast (%ubmk_srt_struct* @ubmk_srt$def to i8*), i8* bitcast (%ubmj_srt_struct* @ubmj_srt$def to i8*), i8* bitcast (%raBO_closure_struct* @raBO_closure$def to i8*), i8* bitcast (%Main_repeatNTimes_closure_struct* @Main_repeatNTimes_closure$def to i8*), i8* bitcast (%Main_zdwrepeatNTimes_closure_struct* @Main_zdwrepeatNTimes_closure$def to i8*), i8* bitcast (%Main_repeatNTimes1_closure_struct* @Main_repeatNTimes1_closure$def to i8*), i8* bitcast (%Main_round4dp_closure_struct* @Main_round4dp_closure$def to i8*), i8* bitcast (%Main_zdwround4dp_closure_struct* @Main_zdwround4dp_closure$def to i8*), i8* bitcast (%uaPR_srt_struct* @uaPR_srt$def to i8*), i8* bitcast (%uaPQ_srt_struct* @uaPQ_srt$def to i8*), i8* bitcast (%uaPP_srt_struct* @uaPP_srt$def to i8*), i8* bitcast (%Main_round4dp1_closure_struct* @Main_round4dp1_closure$def to i8*), i8* bitcast (%Main_repeatNTimes2_closure_struct* @Main_repeatNTimes2_closure$def to i8*), i8* bitcast (%Main_round4dp2_closure_struct* @Main_round4dp2_closure$def to i8*), i8* bitcast (%Main_zdwzdsround4dp_closure_struct* @Main_zdwzdsround4dp_closure$def to i8*), i8* bitcast (%uaNq_srt_struct* @uaNq_srt$def to i8*)], section "llvm.metadata"


